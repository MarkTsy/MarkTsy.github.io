<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>命令模式</title>
    <url>/2021/03/27/minglingmoshi/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>命令模式是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<a id="more"></a>



<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>去饭店点餐， 服务员记下你点的食物， 写在一张纸上。 订单贴在墙上。 过了一段时间， 厨师拿到了订单， 他根据订单来准备食物。 厨师将做好的食物和订单一起放在托盘上。 服务员看到托盘后对订单进行检查， 确保所有食物都是你要的， 然后将食物放到了你的桌上。 </p>
<p>那张纸就是一个命令， 它在厨师开始烹饪前一直位于队列中。 命令中包含与烹饪这些食物相关的所有信息。 厨师能够根据它马上开始烹饪， 而无需跑来直接和你确认订单详情。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210323172153743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>如果你需要通过操作来参数化对象， 可使用命令模式。</li>
</ol>
<blockquote>
<p> 命令模式可将特定的方法调用转化为独立对象。 这一改变也带来了许多有趣的应用： 你可以将命令作为方法的参数进行传递、<br>将命令保存在其他对象中， 或者在运行时切换已连接的命令等。</p>
<p>举个例子： 你正在开发一个 GUI 组件 （例如上下文菜单）， 你希望用户能够配置菜单项， 并在点击菜单项时触发操作。</p>
</blockquote>
<ol start="2">
<li>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</li>
</ol>
<blockquote>
<p> 同其他对象一样， 命令也可以实现序列化 （序列化的意思是转化为字符串）， 从而能方便地写入文件或数据库中。 一段时间后，<br>该字符串可被恢复成为最初的命令对象。 因此， 你可以延迟或计划命令的执行。 但其功能远不止如此！ 使用同样的方式， 你还可以将命令放入队列、 记录命令或者通过网络发送命令。</p>
</blockquote>
<ol start="3">
<li>如果你想要实现操作回滚功能， 可使用命令模式。</li>
</ol>
<blockquote>
<p> 尽管有很多方法可以实现撤销和恢复功能， 但命令模式可能是其中最常用的一种。</p>
<p>为了能够回滚操作， 你需要实现已执行操作的历史记录功能。 命令历史记录是一种包含所有已执行命令对象及其相关程序状态备份的栈结构。</p>
<p>这种方法有两个缺点。 首先， 程序状态的保存功能并不容易实现， 因为部分状态可能是私有的。 你可以使用备忘录模式来在一定程度上解决这个问题。</p>
<p>其次， 备份状态可能会占用大量内存。 因此， 有时你需要借助另一种实现方式： 命令无需恢复原始状态， 而是执行反向操作。 反向操作也有代价：<br>它可能会很难甚至是无法实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2021/03/27/jieshiqimoshi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>现实中的翻译员</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>自定义语法结构的时候需要翻译器</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2021/03/27/beiwanglumoshi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>备忘录模式是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>玩游戏的时候的存档， 什么都不用关心， 只要点击存档， 就会保存当前游戏进度， 下次可以读取寸档来恢复游戏进度。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>1.内部类方式<br><img src="https://img-blog.csdnimg.cn/20210324100234873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>2.接口实现方式<br><img src="https://img-blog.csdnimg.cn/20210324100240785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>3.封装更加严格的实现<br><img src="https://img-blog.csdnimg.cn/2021032410024868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。</li>
</ol>
<blockquote>
<p>备忘录模式允许你复制对象中的全部状态 （包括私有成员变量）， 并将其独立于对象进行保存。 尽管大部分人因为 “撤销” 这个用例才记得该模式，<br>但其实它在处理事务 （比如需要在出现错误时回滚一个操作） 的过程中也必不可少。</p>
</blockquote>
<ol start="2">
<li>当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。</li>
</ol>
<blockquote>
<p> 备忘录让对象自行负责创建其状态的快照。 任何其他对象都不能读取快照， 这有效地保障了数据的安全性。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2021/03/27/diedaiqimoshi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>迭代器模式是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>无论去哪游玩， 找个向导就ok了， 他会给你安排游玩路线</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/2021031617550925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</li>
</ol>
<blockquote>
<p> 迭代器封装了与复杂数据结构进行交互的细节， 为客户端提供多个访问集合元素的简单方法。 这种方式不仅对客户端来说非常方便，<br>而且能避免客户端在直接与集合交互时执行错误或有害的操作， 从而起到保护集合的作用。</p>
</blockquote>
<ol start="2">
<li>使用该模式可以减少程序中重复的遍历代码。</li>
</ol>
<blockquote>
<p> 重要迭代算法的代码往往体积非常庞大。 当这些代码被放置在程序业务逻辑中时， 它会让原始代码的职责模糊不清， 降低其可维护性。 因此，  将遍历代码移到特定的迭代器中可使程序代码更加精炼和简洁。</p>
</blockquote>
<ol start="3">
<li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</li>
</ol>
<blockquote>
<p> 该模式为集合和迭代器提供了一些通用接口。 如果你在代码中使用了这些接口， 那么将其他实现了这些接口的集合和迭代器传递给它时， 它仍将可以正常运行。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2021/03/27/zerenlianmoshi/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>富士康里面的流水线， 每个环节安装不同的零件</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210315213721101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>流水线安装笔记本电脑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    Worker next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Computer c)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WorkerA</span> </span>&#123;</span><br><span class="line">    Worker next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Computer c)</span> </span>&#123;</span><br><span class="line">        pring(<span class="string">"安装cpu"</span>);</span><br><span class="line">        next.work(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WorkerB</span> </span>&#123;</span><br><span class="line">    Worker next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Computer c)</span> </span>&#123;</span><br><span class="line">        pring(<span class="string">"安装内存"</span>);</span><br><span class="line">        next.work(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WorkerC</span> </span>&#123;</span><br><span class="line">    Worker next;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(Computer c)</span> </span>&#123;</span><br><span class="line">        pring(<span class="string">"安装显卡"</span>);</span><br><span class="line">        next.work(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> A B C;</span><br><span class="line">    A.next=B;</span><br><span class="line">    B.next=C;</span><br><span class="line">    A.work(<span class="keyword">new</span> Computer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol>
<li>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</li>
</ol>
<blockquote>
<p>该模式能将多个处理者连接成一条链。 接收到请求后， 它会 “询问” 每个处理者是否能够对其进行处理。 这样所有处理者都有机会来处理请求。</p>
</blockquote>
<ol start="2">
<li>当必须按顺序执行多个处理者时， 可以使用该模式。</li>
</ol>
<blockquote>
<p>无论你以何种顺序将处理者连接成一条链， 所有请求都会严格按照顺序通过链上的处理者。</p>
</blockquote>
<ol start="3">
<li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li>
</ol>
<blockquote>
<p>如果在处理者类中有对引用成员变量的设定方法， 你将能动态地插入和移除处理者， 或者改变其顺序。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2021/03/27/fangwenzhemoshi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>访问者模式是一种行为设计模式， 它能将算法与其所作用的对象隔离开来</p>
<a id="more"></a>

<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210315213011758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参</span></span><br><span class="line"><span class="comment">// 数。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">move</span>(<span class="title">x</span>, <span class="title">y</span>)</span></span><br><span class="line"><span class="class">    <span class="title">method</span> <span class="title">draw</span>()</span></span><br><span class="line">    method accept(v: Visitor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的</span></span><br><span class="line"><span class="comment">// 访问者方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dot</span> <span class="keyword">implements</span> <span class="title">Shape</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // ...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    // 注意我们正在调用的`<span class="title">visitDot</span>（访问点）`方法与当前类的名称相匹配。</span></span><br><span class="line"><span class="class">    // 这样我们能让访问者知晓与其交互的元素类。</span></span><br><span class="line">    method accept(v: Visitor) is</span><br><span class="line">        v.visitDot(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // ...</span></span><br><span class="line">    method accept(v: Visitor) is</span><br><span class="line">        v.visitCircle(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // ...</span></span><br><span class="line">    method accept(v: Visitor) is</span><br><span class="line">        v.visitRectangle(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompoundShape</span> <span class="keyword">implements</span> <span class="title">Shape</span> <span class="title">is</span></span></span><br><span class="line"><span class="class">    // ...</span></span><br><span class="line">    method accept(v: Visitor) is</span><br><span class="line">        v.visitCompoundShape(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准</span></span><br><span class="line"><span class="comment">// 确辨别出与其交互的元素所属的类。</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> <span class="title">is</span></span></span><br><span class="line">    method visitDot(d: Dot)</span><br><span class="line">    <span class="function">method <span class="title">visitCircle</span><span class="params">(c: Circle)</span></span></span><br><span class="line"><span class="function">    method <span class="title">visitRectangle</span><span class="params">(r: Rectangle)</span></span></span><br><span class="line"><span class="function">    method <span class="title">visitCompoundShape</span><span class="params">(cs: CompoundShape)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。</span></span></span><br><span class="line"><span class="function"><span class="comment">//</span></span></span><br><span class="line"><span class="function"><span class="comment">// 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情</span></span></span><br><span class="line"><span class="function"><span class="comment">// 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问</span></span></span><br><span class="line"><span class="function"><span class="comment">// 者方法。这可能会非常有帮助。</span></span></span><br><span class="line"><span class="function">class XMLExportVisitor implements Visitor is</span></span><br><span class="line"><span class="function">    method <span class="title">visitDot</span><span class="params">(d: Dot)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 导出点（dot）的 ID 和中心坐标。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">visitCircle</span><span class="params">(c: Circle)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 导出圆（circle）的 ID 、中心坐标和半径。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">visitRectangle</span><span class="params">(r: Rectangle)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 导出长方形（rectangle）的 ID 、左上角坐标、宽和长。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">visitCompoundShape</span><span class="params">(cs: CompoundShape)</span> is</span></span><br><span class="line"><span class="function">        <span class="comment">// 导出图形（shape）的 ID 和其子项目的 ID 列表。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操</span></span></span><br><span class="line"><span class="function"><span class="comment">// 作会将调用定位到访问者对象的相应操作上。</span></span></span><br><span class="line"><span class="function">class Application is</span></span><br><span class="line"><span class="function">    field allShapes: array of Shapes</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    method <span class="title">export</span><span class="params">()</span> is</span></span><br><span class="line"><span class="function">        exportVisitor </span>= <span class="keyword">new</span> XMLExportVisitor()</span><br><span class="line"></span><br><span class="line">        foreach (shape in allShapes) <span class="keyword">do</span></span><br><span class="line">            shape.accept(exportVisitor)</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。</li>
</ol>
<blockquote>
<p>访问者模式通过在访问者对象中为多个目标类提供相同操作的变体， 让你能在属于不同类的一组对象上执行同一操作。</p>
</blockquote>
<ol start="2">
<li>可使用访问者模式来清理辅助行为的业务逻辑。</li>
</ol>
<blockquote>
<p>该模式会将所有非主要的行为抽取到一组访问者类中， 使得程序的主要类能更专注于主要的工作。</p>
</blockquote>
<ol start="3">
<li>当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。</li>
</ol>
<blockquote>
<p>你可将该行为抽取到单独的访问者类中， 只需实现接收相关类的对象作为参数的访问者方法并将其他方法留空即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/03/07/shipeiqimoshi/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><ul>
<li>服务端数据源可能是xml活json， 通过不同的适配器来解析数据</li>
<li>电源插口可能有两口或三口， 通过不同的插头转换为usb插口</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210307201338796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>适配器模式还是比较好理解的， 就是抽象出来一个中间件用来接口或数据的统一</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/03/07/qiaojiemoshi/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>桥接模式属于结构型的一种， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<a id="more"></a>

<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>一体机和组装台式机， 一体机封闭的无法更换硬件， 组装台式机只要接口类型符合就可随意更换cpu/内存等。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210307194304162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看桥接模式的简介感觉有点懵， 翻译过来就是将整体拆分成抽象接口， 就像上面的例子一样， 定义好不同硬件的插口， 更方便更换硬件。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title> 组合模式</title>
    <url>/2021/03/07/zuhemoshi/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。</p>
<a id="more"></a>

<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul>
<li>公司职级架构</li>
<li>AndroidView 架构</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://img-blog.csdnimg.cn/20210307164543647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NlZXlvdU1U,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>示例代码(伪代码)</strong><br>以android view体系来说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">	  </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextView</span> <span class="title">extentds</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"im TextView"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageView</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"im ImageView"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewGroup</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;</span><br><span class="line">	List&lt;View&gt; childViews;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View v)</span> </span>&#123; childViews.add(v)&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View v)</span> </span>&#123; childViews.remove(v)&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> draw &#123; </span><br><span class="line">		<span class="keyword">for</span> v : childs  </span><br><span class="line">		c.draw </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>可以将对象关系抽象为树状结构的时候，采用组合模式， 可通过一个入口递归遍历到所有的子节点，方便管理。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下制作 Ubuntu U盘启动</title>
    <url>/2020/06/20/macmakeubuntuiso/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>采用U盘安装Ubuntu系统是目前比较常见的安装方式之一，在Windows上有制作安装U盘的工具（比如Universal USB Installer），那么在Mac OS上面如何制作安装U盘呢?<br>答案是命令行!</p>
<a id="more"></a>

<h4 id="hdiutil"><a href="#hdiutil" class="headerlink" title="hdiutil"></a>hdiutil</h4><p>第一步,需要到<a href="http://www.ubuntu.com/download" target="_blank" rel="noopener">Ubuntu</a>下载需要的Ubuntu的安装文件。<br>然后就需要使用第一个命令hdiutil。<br>hdituil:是一个Mac OS上面处理镜像文件的命令,可以对镜像文件进行制作，验证和转换等…<br>我们知道DMG格式是Mac OS上常用的打包格式文件，需要把下载的Ubuntu安装文件（.iso）转换成(.dmg)格式的文件,方便在Mac OS上面进行操作，转换命令:</p>
<blockquote>
<p>hdiutil convert -format UDRW -o ubuntu.iso ubuntu-14.04.5-desktop-amd64.iso</p>
</blockquote>
<p><code>-format</code>为生成文件的权限</p>
<p><code>UDRW</code> :表示转换成有</p>
<p><code>read/write</code>的权限的镜像<br>等待转换完成</p>
<h4 id="diskutil"><a href="#diskutil" class="headerlink" title="diskutil"></a>diskutil</h4><p>第二步需要需要对U盘进行操作，而diskutil就是用来对Mac OS的磁盘操作的命令。<br><code>diskutil</code>:操作本地磁盘，可以对磁盘进行卸载，挂载等操作。<br>列出当前挂载的磁盘:</p>
<blockquote>
<p>diskutil list</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dev&#x2F;disk0 (internal, physical):</span><br><span class="line">   #:                  TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:      GUID_partition_scheme                        *251.0 GB   disk0</span><br><span class="line">   1:                        EFI EFI                     209.7 MB   disk0s1</span><br><span class="line">   2:          Apple_CoreStorage Macintosh HD            250.1 GB   disk0s2</span><br><span class="line">   3:                 Apple_Boot Recovery HD             650.0 MB   disk0s3</span><br><span class="line">&#x2F;dev&#x2F;disk1 (internal, virtual):</span><br><span class="line">   #:                 TYPE NAME                    SIZE       IDENTIFIER</span><br><span class="line">   0:             Apple_HFS Macintosh HD           +249.8 GB   disk1</span><br><span class="line">                  Logical Volume on disk0s2</span><br><span class="line">                  45CD1187-14DE-4203-9895-FBB1B3770F1E</span><br><span class="line">                  Unencrypted</span><br><span class="line">&#x2F;dev&#x2F;disk2 (external, physical):</span><br><span class="line">   #:              TYPE NAME                        SIZE       IDENTIFIER</span><br><span class="line">   0: Apple_partition_scheme                        *8.1 GB     disk2</span><br><span class="line">   1:    Apple_partition_map                         4.1 KB     disk2s1</span><br><span class="line">   2:              Apple_HFS                         2.4 MB     disk2s2</span><br></pre></td></tr></table></figure>

<p>其中/dev/disk2就是U盘。<br>需要先卸载掉U盘，然后在把安装文件写入到U盘中，这样就需要用到卸载命令：</p>
<blockquote>
<p>diskutil unmountDisk /dev/disk2</p>
</blockquote>
<p>再次使用diskutil list命令就不会显示出<em>disk2</em>了。</p>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>第三步，把安装文件写入U盘，这里需要使用命令dd<br>dd:是Unix和类Unix系统上的命令，作用就是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<p>在进行拷贝之前，还需要做的一件时间,因为使用hdiutil转换的文件后缀名为.dmg,所以需要把文件重命名为.iso，在安装的时候系统才能够更好的识别。</p>
<blockquote>
<p>mv ubuntu.iso.dmg ubuntu.iso</p>
</blockquote>
<p>然后把安装文件拷贝到U盘中</p>
<blockquote>
<p>sudo dd if=./ubuntu.iso of=/dev/rdisk2 bs=1m</p>
</blockquote>
<p>这行命令必须使用<code>root</code>权限，</p>
<ul>
<li><p><code>if</code>:输入的文件名</p>
</li>
<li><p><code>of</code>:输出的文件名</p>
</li>
<li><p><code>bs</code>:是块大小，这里使用<code>1m</code>的块大小<br>漫长的等待….</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1052+1 records in</span><br><span class="line">1052+1 records out</span><br><span class="line">1104052224 bytes transferred in 249.471583 secs (4425563 bytes&#x2F;sec)</span><br></pre></td></tr></table></figure>

<p>操作完成之后，安全地拔出U盘</p>
<blockquote>
<p>sudo eject /dev/rdisk2</p>
</blockquote>
<p>可以使用U盘进行Ubuntu的安装了！</p>
<h4 id="销毁安装数据"><a href="#销毁安装数据" class="headerlink" title="销毁安装数据"></a>销毁安装数据</h4><p>安装完成之后，U盘上面的安装文件还在，这样会影响我们正常使用U盘。可以把U盘格式化一次，清除数据，也可以使用<code>dd</code>命令销毁磁盘数据:</p>
<blockquote>
<p>sudo dd if=/dev/urandom of=/dev/rdisk2</p>
</blockquote>
<p>使用随机数填充U盘，可以用来销毁数据，一般用于重要数据否则没有必要使用随机数填充。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>ubuntu u盘启动</tag>
      </tags>
  </entry>
  <entry>
    <title>模版方法模式</title>
    <url>/2020/05/22/moshimoban/</url>
    <content><![CDATA[<h4 id="模版方法模式介绍"><a href="#模版方法模式介绍" class="headerlink" title="模版方法模式介绍"></a>模版方法模式介绍</h4><p>在软件开发中，有时会遇到类似的情况，某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用模板方法模式来应对这类情况。</p>
<a id="more"></a>

<h4 id="模版方法模式定义"><a href="#模版方法模式定义" class="headerlink" title="模版方法模式定义"></a>模版方法模式定义</h4><p>定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤。</p>
<h4 id="模版方法模式结构图"><a href="#模版方法模式结构图" class="headerlink" title="模版方法模式结构图"></a>模版方法模式结构图</h4><ul>
<li>AbstractClass：抽象类，定义了一套算法。</li>
<li>ConcreteClass：具体实现类。</li>
</ul>
<p><img src="/2020/05/22/moshimoban/1111.png" alt></p>
<h4 id="模版方法模式的简单实现"><a href="#模版方法模式的简单实现" class="headerlink" title="模版方法模式的简单实现"></a>模版方法模式的简单实现</h4><p>我们举一个武侠的例子</p>
<h4 id="创建抽象类，定义算法框架"><a href="#创建抽象类，定义算法框架" class="headerlink" title="创建抽象类，定义算法框架"></a>创建抽象类，定义算法框架</h4><p>一个武侠要战斗的时候，也有一套固定的通用模式，那就是运行内功、开通经脉、准备武器和使用招式，我们把这些用代码表示就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSwordsman</span> </span>&#123;</span><br><span class="line">  <span class="comment">//该方法为final，防止算法框架被覆写</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//运行内功，抽象方法</span></span><br><span class="line">      neigong();</span><br><span class="line">      <span class="comment">//调整经脉,具体方法</span></span><br><span class="line">      meridian();</span><br><span class="line">      <span class="comment">//如果有武器则准备武器</span></span><br><span class="line">      <span class="keyword">if</span>(hasWeapons()) &#123;</span><br><span class="line">          weapons();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//使用招式</span></span><br><span class="line">      moves();</span><br><span class="line">      <span class="comment">//钩子方法</span></span><br><span class="line">      hook();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//空实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">neigong</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">weapons</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">moves</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">meridian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开通正经与奇经"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有武器，默认是有武器的，钩子方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasWeapons</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是这个抽象类包含了三种类型的方法，分别是抽象方法、具体方法和钩子方法。抽象方法是交由子类去实现，具体方法则在父类实现了子类公共的方法实现，在上面的例子就是武侠开通经脉的方式都一样，所以就在具体方法中实现。钩子方法则分为两类，第一类是15行，它有一个空实现的方法，子类可以视情况来决定是否要覆盖它；第二类则是第9行，这类钩子方法的返回类型通常是bool类型的，一般用于对某个条件进行判断，如果条件满足则执行某一步骤，否则将不执行。</p>
<h4 id="定义具体实现类"><a href="#定义具体实现类" class="headerlink" title="定义具体实现类"></a>定义具体实现类</h4><p>本文就拿张无忌、张三丰来作为例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuJi</span> <span class="keyword">extends</span> <span class="title">AbstractSwordsman</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">neigong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"运行九阳神功"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">weapons</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">moves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"使用招式乾坤大挪移"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasWeapons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>张无忌没有武器所以hasWeapons方法返回false，这样也不会走weapons方法了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangSanFeng</span> <span class="keyword">extends</span> <span class="title">AbstractSwordsman</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">neigong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"运行纯阳无极功"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">weapons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"使用真武剑"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">moves</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"使用招式神门十三剑"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"突然肚子不舒服，老夫先去趟厕所"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后张三丰突然肚子不舒服所以就实现了钩子方法hook。</p>
<h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   ZhangWuJi zhangWuJi=<span class="keyword">new</span> ZhangWuJi();</span><br><span class="line">   zhangWuJi.fighting();</span><br><span class="line">   ZhangSanFeng zhangSanFeng=<span class="keyword">new</span> ZhangSanFeng();</span><br><span class="line">   zhangSanFeng.fighting();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>运行九阳神功<br>开通正经与奇经<br>使用招式乾坤大挪移<br>运行纯阳无极功<br>开通正经与奇经<br>使用真武剑<br>使用招式神门十三剑<br>突然肚子不舒服，老夫先去趟厕所</p>
<h4 id="模版方法模式的优缺点和使用场景"><a href="#模版方法模式的优缺点和使用场景" class="headerlink" title="模版方法模式的优缺点和使用场景"></a>模版方法模式的优缺点和使用场景</h4><p><strong>优点</strong></p>
<ul>
<li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。</li>
<li>子类实现算法的某些细节，有助于算法的扩展。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
<li>面对重要复杂的算法，可以把核心算法设计为模版方法，周边相关细节功能则有各个子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>模版方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2020/05/22/moshizhongjie/</url>
    <content><![CDATA[<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>中介者模式是行为型模式的一种，旨在处理类或对象如何交互及如何分配职责。<br>中介者模式又叫做调停者模式，名字跟出国留学中介和房产中介是类似的。拿房产中介来说，现在房子买家和房子卖家非常多，如果任由房子买家和房子卖家自由交易，则会导致不同的买家和卖家之间有很多交互，一个买家会和多个卖家进行交涉，同样的一个卖家也会和多个买家进行交涉。如果在买房的过程中出现纠纷问题，则很难进行解决。就如下图所示一样。</p>
<a id="more"></a>

<p><img src="/2020/05/22/moshizhongjie/1111.png" alt></p>
<p>可以看出房子买家和卖家进行了很多错综复杂的交互，并且买家A和卖家B，买家D和卖家D还产生了纠纷，一看到这个图我们就觉得的晕，当然比我们晕的还有房子买家和卖家。我们在设计原则文章讲过迪米特原则，这个原则所说的就是要尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。迪米特原则同样适用于本场景，我们可以引入第三者也就是房产中介。它的出现不需要买家和卖家进行直接交涉，而是通过房产中介而进行交涉。并且也不容易出现买卖家之间纠纷，因为有中介者房产中介进行第三方监督。如下图所示。<br><img src="/2020/05/22/moshizhongjie/2222.png" alt></p>
<p>图中的关系清晰了很多。回到我们软件开发中，我们为了减少对象之间的交互和耦合，符合迪米特原则，那么就可以使用中介者模式，先来学习下中介者模式的定义。</p>
<h4 id="中介者模式定义"><a href="#中介者模式定义" class="headerlink" title="中介者模式定义"></a>中介者模式定义</h4><p><strong>定义：用一个中介者对象来封装一系列的对象交互。中介者使得各对象不需要显式地相互引用，从而使其松散耦合，而且可以独立地改变它们之间的交互。</strong></p>
<p>中介者模式结构图如下图所示。</p>
<p><img src="/2020/05/22/moshizhongjie/3333.png" alt><br>在中介者模式中有如下角色：</p>
<ul>
<li>Mediator：抽象中介者角色，定义了同事对象到中介者对象的接口。</li>
<li>ConcreteMediator：具体中介者角色，它从具体的同事对象接收消息，向具体同事发出命令。</li>
<li>Colleague：抽象同事角色，定义了中介者对象接口，它只知道中介者而不知道其他同事对象。</li>
<li>ConcreteColleague：具体同事角色，每个具体同事类都知道自己在小范围内的行为，而不知道它在大范围内的目的。</li>
</ul>
<h4 id="中介者模式简单实现"><a href="#中介者模式简单实现" class="headerlink" title="中介者模式简单实现"></a>中介者模式简单实现</h4><p>中介者模式可以拿武侠来举例，江湖中门派众多，门派之前因为想法不同会有很多的利益冲突，这样就会带来无休止的纷争。为了江湖的安宁，大家推举出了一个大家都认可的武林盟主来对江湖纷争进行调停。<br>前段时间武当派和峨眉派的的弟子被大力金刚指所杀，大力金刚指是少林派的绝学，因为事情重大，而且少林派实力强大，武当派和峨眉派不能够直接去少林派去问罪，只能上报武林盟主由武林盟主出面进行调停，如下图所示。</p>
<p><img src="/2020/05/22/moshizhongjie/4444.png" alt></p>
<h5 id="抽象中介者角色"><a href="#抽象中介者角色" class="headerlink" title="抽象中介者角色"></a>抽象中介者角色</h5><p>首先我们创建抽象中介者类，在这个例子中，它是一个武林联盟类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WulinAlliance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(String message, United united)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>notice方法用于向门派发送通知，其中United为抽象同事类也就是门派类，接下来我们来创建它。</p>
<h5 id="抽象同事角色"><a href="#抽象同事角色" class="headerlink" title="抽象同事角色"></a>抽象同事角色</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">United</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> WulinAlliance wulinAlliance;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">United</span><span class="params">(WulinAlliance wulinAlliance)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.wulinAlliance=wulinAlliance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>门派类（抽象同事类）会在构造方法中得到武林联盟类（抽象中介者类）。</p>
<h5 id="具体同事角色"><a href="#具体同事角色" class="headerlink" title="具体同事角色"></a>具体同事角色</h5><p>具体同事类包括武当派、峨眉派和少林派，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体同事类（武当）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wudang</span> <span class="keyword">extends</span> <span class="title">United</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wudang</span><span class="params">(WulinAlliance wulinAlliance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(wulinAlliance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAlliance</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        wulinAlliance.notice(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNotice</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"武当收到消息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体同事类（峨眉派）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emei</span> <span class="keyword">extends</span> <span class="title">United</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emei</span><span class="params">(WulinAlliance wulinAlliance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(wulinAlliance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAlliance</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        wulinAlliance.notice(message, Emei.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNotice</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"峨眉收到消息："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体同事类（少林派）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shaolin</span> <span class="keyword">extends</span> <span class="title">United</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shaolin</span><span class="params">(WulinAlliance wulinAlliance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(wulinAlliance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAlliance</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        wulinAlliance.notice(message,Shaolin.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNotice</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"少林收到消息："</span>+message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>武当、峨眉和少林类都有两个方法，其中getNotice方法是自有方法，对于其他的门派（同事类）和武林联盟（中介者）没有依赖，只是用来接收武林盟主的通知。sendAlliance方法则是依赖方法，它必须通过武林盟主才能完成行为。</p>
<h5 id="具体中介者角色"><a href="#具体中介者角色" class="headerlink" title="具体中介者角色"></a>具体中介者角色</h5><p>具体中介者类则是武林盟主类，如下所示  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Champions</span> <span class="keyword">extends</span> <span class="title">WulinAlliance</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Wudang wudang;</span><br><span class="line"> <span class="keyword">private</span> Shaolin shaolin;</span><br><span class="line"> <span class="keyword">private</span> Emei emei;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWudang</span><span class="params">(Wudang wudang)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.wudang = wudang;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmei</span><span class="params">(Emei emei)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.emei = emei;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShaolin</span><span class="params">(Shaolin shaolin)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.shaolin = shaolin;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(String message, United united)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (united == wudang) &#123;</span><br><span class="line">       shaolin.getNotice(message);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (united == emei) &#123;</span><br><span class="line">       shaolin.getNotice(message);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (united == shaolin) &#123;</span><br><span class="line">       wudang.getNotice(message);</span><br><span class="line">       emei.getNotice(message);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>武林盟主需要了解所有的门派，所以需要用setter来持有武当、峨眉和少林的引用。notice方法会根据不同门派发来的消息，转而通知给其他的门派。比如武当发来的消息，武林盟主就会将消息通知给少林。</p>
<h5 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">   Champions champions=<span class="keyword">new</span> Champions();</span><br><span class="line">   Wudang wudang=<span class="keyword">new</span> Wudang(champions);</span><br><span class="line">   Shaolin shaolin=<span class="keyword">new</span> Shaolin(champions);</span><br><span class="line">   Emei emei=<span class="keyword">new</span> Emei(champions);</span><br><span class="line">   champions.setWudang(wudang);</span><br><span class="line">   champions.setShaolin(shaolin);</span><br><span class="line">   champions.setEmei(emei);</span><br><span class="line">   wudang.sendAlliance(<span class="string">"武当弟子被少林大力金刚指所杀"</span>);</span><br><span class="line">   emei.sendAlliance(<span class="string">"峨眉弟子被少林大力金刚指所杀"</span>);</span><br><span class="line">   shaolin.sendAlliance(<span class="string">"少林弟子绝不会做出这种事情"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建武林盟主类Champions 并传入到各个门派类，接着调用武林盟主类的setter方法传入各个门派类，最后调用各个门派的sendAlliance方法通过武林盟主类向其他门派发送消息。</p>
<p>输出结果为：<br>少林收到消息：武当弟子被少林大力金刚指所杀<br>少林收到消息：峨眉弟子被少林大力金刚指所杀<br>武当收到消息：少林弟子绝不会做出这种事情<br>峨眉收到消息：少林弟子绝不会做出这种事情</p>
<p>接下来给出这个例子的UML图，如下所示。<br><img src="/2020/05/22/moshizhongjie/5555.png" alt></p>
<h4 id="中介者模式的优缺点和使用场景"><a href="#中介者模式的优缺点和使用场景" class="headerlink" title="中介者模式的优缺点和使用场景"></a>中介者模式的优缺点和使用场景</h4><p><strong>优点</strong><br>符合迪米特原则，将原有的一对多的依赖变成了一对一的依赖，降低类间的耦合。</p>
<p><strong>缺点</strong><br>中介者会变得庞大且复杂，原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
<p><strong>使用场景</strong><br>中介者模式很容易实现呢，但是也容易误用，不要着急使用，先要思考你的设计是否合理。<br>当对象之间的交互变多时，为了防止一个类会涉及修改其他类的行为，可以使用中介者模式，将系统从网状结构变为以中介者为中心的星型结构。</p>
<h4 id="代理模式、外观模式和中介者模式对比"><a href="#代理模式、外观模式和中介者模式对比" class="headerlink" title="代理模式、外观模式和中介者模式对比"></a>代理模式、外观模式和中介者模式对比</h4><p>当我们学完中介者模式是不是会觉得和此前讲过的代理模式和外观模式有些类似呢？现在我们一一来将它们进行对比。</p>
<h4 id="代理模式和中介者模式"><a href="#代理模式和中介者模式" class="headerlink" title="代理模式和中介者模式"></a>代理模式和中介者模式</h4><p>代理模式是结构型设计模式，它有很多种类型，主要是在访问对象时引入一定程度的间接性，由于有间接性，就可以附加多种的用途，比如进行权限控制。中介者模式则是为了减少对象之间的相互耦合。虽然网上有很多代理模式和中介者模式的对比，但是在我看来这两者实际上并没有可比性，只是看起来有些类似罢了。</p>
<h4 id="外观模式和中介者模式"><a href="#外观模式和中介者模式" class="headerlink" title="外观模式和中介者模式"></a>外观模式和中介者模式</h4><p>外观模式主要是以封装和隔离为主要任务，中介者则是调停同事类之间的关系，因此，中介者具有部分业务的逻辑控制。他们之间的主要区别为：</p>
<ul>
<li>外观模式的子系统如果脱离外观模式还是可以运行的，而中介者模式增加了业务逻辑，同事类不能脱离中介者而独自存在。</li>
<li>外观模式中，子系统是不知道外观类的存在的，而中介者模式中，每个同事类都知道中介者。</li>
<li>外观模式将子系统的逻辑隐藏，用户不知道子系统的存在，而中介者模式中，用户知道同事类的存在。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2020/05/08/moshiguancha/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>观察者模式（又被称为发布-订阅（Publish/Subscribe）模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<a id="more"></a>

<h4 id="观察者模式结构图"><a href="#观察者模式结构图" class="headerlink" title="观察者模式结构图"></a>观察者模式结构图</h4><p><img src="/2020/05/08/moshiguancha/guancha.png" alt></p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，是实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<h4 id="观察者模式简单实"><a href="#观察者模式简单实" class="headerlink" title="观察者模式简单实"></a>观察者模式简单实</h4><p>观察者模式这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。好了我们来看看用代码如何实现：</p>
<h4 id="抽象观察者（Observer）"><a href="#抽象观察者（Observer）" class="headerlink" title="抽象观察者（Observer）"></a>抽象观察者（Observer）</h4><p>里面定义了一个更新的方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体观察者（ConcrereObserver）"><a href="#具体观察者（ConcrereObserver）" class="headerlink" title="具体观察者（ConcrereObserver）"></a>具体观察者（ConcrereObserver）</h4><p>微信用户是观察者，里面实现了更新的方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 微信用户名</span></span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">     System.out.println(name + <span class="string">"-"</span> + message);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象被观察者（Subject）"><a href="#抽象被观察者（Subject）" class="headerlink" title="抽象被观察者（Subject）"></a>抽象被观察者（Subject）</h4><p>抽象主题，提供了attach、detach、notify三个方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 增加订阅者</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 删除订阅者</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体被观察者"><a href="#具体被观察者" class="headerlink" title="具体被观察者"></a>具体被观察者</h4><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"> <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">     weixinUserlist.add(observer);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">     weixinUserlist.remove(observer);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">     observer.update(message);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> SubscriptionSubject();</span><br><span class="line"> <span class="comment">//创建微信用户</span></span><br><span class="line"> WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">"A"</span>);</span><br><span class="line"> WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">"B"</span>);</span><br><span class="line"> WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">"C"</span>);</span><br><span class="line"> <span class="comment">//订阅公众号</span></span><br><span class="line"> mSubscriptionSubject.attach(user1);</span><br><span class="line"> mSubscriptionSubject.attach(user2);</span><br><span class="line"> mSubscriptionSubject.attach(user3);</span><br><span class="line"> <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line"> mSubscriptionSubject.notify(<span class="string">"更新了"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<blockquote>
<p>A-更新了<br>B-更新了<br>C-更新了</p>
</blockquote>
<h4 id="使用观察者模式的场景和优缺点"><a href="#使用观察者模式的场景和优缺点" class="headerlink" title="使用观察者模式的场景和优缺点"></a>使用观察者模式的场景和优缺点</h4><p><strong>使用场景</strong></p>
<ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。</li>
<li>事件多级触发场景。</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制。</li>
</ul>
<p><strong>优点</strong></p>
<p>解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。</p>
<p><strong>缺点</strong></p>
<p>在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。</p>
<h4 id="Android中的观察者模式"><a href="#Android中的观察者模式" class="headerlink" title="Android中的观察者模式"></a>Android中的观察者模式</h4><p>android源码中也有很多使用了观察者模式，比如OnClickListener、ContentObserver、android.database.Observable等；还有组件通讯库RxJava、RxAndroid、EventBus；在这里将拿我们最常用的Adapter的notifyDataSetChanged()方法来举例：<br>当我们用ListView的时候，数据发生变化的时候我们都会调用Adapter的notifyDataSetChanged()方法，这个方法定义在BaseAdaper中，我们来看看BaseAdaper的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">ListAdapter</span>, <span class="title">SpinnerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据集观察者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataSetObservable mDataSetObservable = <span class="keyword">new</span> DataSetObservable();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasStableIds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</span><br><span class="line">        mDataSetObservable.registerObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterDataSetObserver</span><span class="params">(DataSetObserver observer)</span> </span>&#123;</span><br><span class="line">        mDataSetObservable.unregisterObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当数据集变化时，通知所有观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyDataSetChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDataSetObservable.notifyChanged();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>很明显BaseAdapter用的是观察者模式，BaseAdapter是具体被观察者，接下来看看mDataSetObservable.notifyChanged()：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSetObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span>&lt;<span class="title">DataSetObserver</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mObservers) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mObservers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                mObservers.get(i).onChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到了mObservers，这就是观察者的集合，这些观察者是在ListView通过setAdaper()设置Adaper时产生的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(ListAdapter adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span> &amp;&amp; mDataSetObserver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAdapter.unregisterDataSetObserver(mDataSetObserver);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">super</span>.setAdapter(adapter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();</span><br><span class="line">            mOldItemCount = mItemCount;</span><br><span class="line">            mItemCount = mAdapter.getCount();</span><br><span class="line">            checkFocus();</span><br><span class="line">            <span class="comment">//创建数据观察者</span></span><br><span class="line">            mDataSetObserver = <span class="keyword">new</span> AdapterDataSetObserver();</span><br><span class="line">            <span class="comment">//注册观察者</span></span><br><span class="line">            mAdapter.registerDataSetObserver(mDataSetObserver);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看观察者AdapterDataSetObserver中处理了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> <span class="keyword">extends</span> <span class="title">AdapterView</span>&lt;<span class="title">ListAdapter</span>&gt;.<span class="title">AdapterDataSetObserver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onChanged();</span><br><span class="line">            <span class="keyword">if</span> (mFastScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFastScroller.onSectionsChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInvalidated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onInvalidated();</span><br><span class="line">            <span class="keyword">if</span> (mFastScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mFastScroller.onSectionsChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码看不出什么，再看看AdapterDataSetObserver的父类AdapterView的AdapterDataSetObserver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdapterDataSetObserver</span> <span class="keyword">extends</span> <span class="title">DataSetObserver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Parcelable mInstanceState = <span class="keyword">null</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mDataChanged = <span class="keyword">true</span>;</span><br><span class="line">            mOldItemCount = mItemCount;</span><br><span class="line">            mItemCount = getAdapter().getCount();</span><br><span class="line">            <span class="keyword">if</span> (AdapterView.<span class="keyword">this</span>.getAdapter().hasStableIds() &amp;&amp; mInstanceState != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; mOldItemCount == <span class="number">0</span> &amp;&amp; mItemCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                AdapterView.<span class="keyword">this</span>.onRestoreInstanceState(mInstanceState);</span><br><span class="line">                mInstanceState = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rememberSyncState();</span><br><span class="line">            &#125;</span><br><span class="line">            checkFocus();</span><br><span class="line">            <span class="comment">//重新布局</span></span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearSavedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mInstanceState = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在onChanged()方法中调用了requestLayout()方法来重新进行布局。好了，看到这里我们都明白了，当ListView的数据发生变化时，我们调用Adapter的notifyDataSetChanged()方法，这个方法又会调用观察者们（AdapterDataSetObserver）的onChanged()方法，onChanged()方法又会调用requestLayout()方法来重新进行布局。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Android事件分发</title>
    <url>/2020/05/06/androidshijian/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于Android屏幕的事件分发，中高级的Android开发人员应该会时常的提起，因为了解了事件分发之后，我们可以处理一些事件冲突，自定义一些触摸反馈。 其实事件分发机制并不难理解，开发中ontouchevent中的逻辑处理才是核心。</p>
<a id="more"></a>

<p><img src="/2020/05/06/androidshijian/shijianfenfa.png" alt></p>
<p>事件的传递流程一张图就可以说明， </p>
<p>手指在触摸屏幕的时候会产生事件流  action_down -&gt; (… action_move …) -&gt;activon_up</p>
<p>总之系统将事件向子view传递， 直至找到处理事件的view，每个view通过dispatchtouchevent来告知父view我是否处理这个事件，如果down事件都不进行消费，后续的事件将不会传递过来, 可以理解， 在做事件判断的时候，首先就要捕获down事件记录起始位置，或者记录被点击的时刻。 如果你是父view，还需要在onintercepttouchevent中进行拦截的判断， 通常down事件不应该拦截， 询问子view是否需要事件处理，可以在onintercepttouchevent方法中添加拦截事件的条件， 判断成功，交由自己的ontouchevent来处理。 比如说做一个滑动的列表， 点击事件需要交由子view来处理， 手指在y轴滑动一定距离，拦截事件进行滚动。</p>
<p><strong>问题？</strong></p>
<p>listview中的子view如果有长按事件是否会出现事件的冲突？又滑动又触发                                                                                                          了子view的长按</p>
<p>查看源码得知， listview进入滑动状态时会调用item的 view.setPressed(false);</p>
<p>这样子view就会取消长按事件的判断了</p>
<p><strong>总结</strong></p>
<p>理解事件分发流程不难， 看看源码， 看看事件是如何传递的便可， 中心思想也就是找到处理事件的view，理解了之后， 对于事件的触摸反馈逻辑处理才是难点核心点。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解</title>
    <url>/2020/04/23/javazhujie/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>注解对于Java开发人员来说肯定都不陌生, Web开发中许多java框架都大量使用注解，如Hibernate\Jersey\Spring. Android开发中Retofit以及Dragger等一些依赖注入的框架也都很常见.自Java5.0版本引入注解之后，它就成为了Java平台中非常重要的一部分. 并且在Java8.0之后进行了加强. </p>
<a id="more"></a>

<p><strong>官方英文教程地址</strong>: <a href="https://docs.oracle.com/javase/tutorial/java/annotations/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/annotations/</a><br><strong>个人翻译教程地址</strong>: <a href="http://blog.csdn.net/lihenair/article/details/51134716" target="_blank" rel="noopener">http://blog.csdn.net/lihenair/article/details/51134716</a></p>
<h3 id="1-什么是注解"><a href="#1-什么是注解" class="headerlink" title="1.什么是注解"></a>1.什么是注解</h3><p>用一个词就可以描述注解, 那就是元数据, 即一种描述数据的数据. 所以, 可以说注解就是源代码的元数据.</p>
<h3 id="2-修饰对象"><a href="#2-修饰对象" class="headerlink" title="2.修饰对象"></a>2.修饰对象</h3><p>注解可以被用在包, 类, 方法, 变量, 参数上. 自Java8起, 有一种注解几乎可以被放在代码的任何位置, 叫做类型注解.</p>
<h3 id="3-消费器"><a href="#3-消费器" class="headerlink" title="3.消费器"></a>3.消费器</h3><p>注解本身并不包含任何功能逻辑, 它们是利用被注解代码并根据注解信息产生不同行为的系统或者应用程序.<br>例如，在Java自带的内建注解（元注解）中，消费器是执行被注解代码的JVM。还有其他稍后谈到的其他例子，例如JUnit，消费器是读取，分析被注解代码的JUnit处理程序，它还可以决定测试单元和方法执行顺序.<br>消费器使用Java中的反射机制来读取和分析被注解的源代码。使用的主要的包有：java.lang, java.lang.reflect.</p>
<h3 id="4-注解语法和元素"><a href="#4-注解语法和元素" class="headerlink" title="4.注解语法和元素"></a>4.注解语法和元素</h3><p>声明一个注解需要使用“@”作为前缀，这便向编译器说明，该元素为注解。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Annotation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMehod</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>上述的注解名称为Annotation，它正在注解annotatedMethod方法。编译器会处理它。注解可以以键值对的形式持有有很多元素，即注解的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Annotation</span>(</span><br><span class="line"> info = <span class="string">"I am an annotation"</span>,</span><br><span class="line"> counter = <span class="string">"55"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMehod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果注解只包含一个元素（或者只需要指定一个元素的值，其它则使用默认值），可以像这样声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Annotation</span>(<span class="string">"I am an annotation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMehod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像我们看到的一样，如果没有元素需要被指定，则不需要括号。多个注解可以使用在同一代码上，例如类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@ Annotation (info = <span class="string">"Uauo"</span>)</span><br><span class="line">@ Annotation2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotatedClass</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>一些java本身提供的开箱即用的注解，我们称之为内建注解。也可以定义你自己的注解，称之为子定义注解。</p>
<h3 id="5-內建注解"><a href="#5-內建注解" class="headerlink" title="5.內建注解"></a>5.內建注解</h3><p>Java语言自带了一系列的注解。在本章中我们将阐述最重要的一部分。这个清单只涉及了Java语言最核心的包，未包含标准JRE中所有包和库如JAXB或Servlet规范。</p>
<p>以下讨论到的注解中有一些被称之为Meta注解，它们的目的注解其他注解，并且包含关于其它注解的信息。</p>
<p><strong>@Retention：</strong></p>
<p>这个注解注在其他注解上，并用来说明如何存储已被标记的注解。这是一种元注解，用来标记注解并提供注解的信息。<br>可能的值是：<br>SOURCE：表明这个注解会被编译器忽略，并只会保留在源代码中。<br>CLASS:表明这个注解会通过编译驻留在CLASS文件，但会被JVM在运行时忽略,正因为如此,其在运行时不可见。<br>RUNTIME：表示这个注解会被JVM获取，并在运行时通过反射获取。<br>java.lang.annotation.RetentionPolicy 类中通过enum封装以上内容</p>
<p><strong>@Target：</strong></p>
<p>这个注解用于限制某个元素可以被注解的类型。例如：</p>
<blockquote>
<p>ANNOTATION_TYPE 表示该注解可以应用到其他注解上<br>CONSTRUCTOR 表示可以使用到构造器上<br>FIELD 表示可以使用到域或属性上<br>LOCAL_VARIABLE表示可以使用到局部变量上。<br>METHOD可以使用到方法级别的注解上。<br>PACKAGE可以使用到包声明上。<br>PARAMETER可以使用到方法的参数上。<br>TYPE可以使用到一个类的任何元素上。</p>
</blockquote>
<p>java.lang.annotation.ElementType 类中通过enum封住以上类型</p>
<p><strong>@Documented：</strong></p>
<p>被注解的元素将会作为Javadoc产生的文档中的内容。注解都默认不会成为成为文档中的内容。这个注解可以对其它注解使用。</p>
<p><strong>@Inherited：</strong></p>
<p>在默认情况下，注解不会被子类继承。被此注解标记的注解会被所有子类继承。这个注解可以对类使用。</p>
<p><strong>@Deprecated：</strong></p>
<p>说明被标记的元素不应该再度使用。这个注解会让编译器产生警告消息。可以使用到方法，类和域上。相应的解释和原因，包括另一个可取代的方法应该同时和这个注解使用。</p>
<p><strong>@SuppressWarnings：</strong></p>
<p>说明编译器不会针对指定的一个或多个原因产生警告。例如：如果我们不想因为存在尚未使用的私有方法而得到警告可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>( <span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">myNotUsedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常,编译器会因为没调用该方而产生警告; 用了注解抑制了这种行为。该注解需要一个或多个参数来指定抑制的警告类型。</p>
<p><strong>@Override：</strong></p>
<p>向编译器说明被注解元素是重写的父类的一个元素。在重写父类元素的时候此注解并非强制性的，不过可以在重写错误时帮助编译器产生错误以提醒我们。比如子类方法的参数和父类不匹配，或返回值类型不同。</p>
<p><strong>@SafeVarargs：</strong></p>
<p>断言方法或者构造器的代码不会对参数进行不安全的操作。在Java的后续版本中，使用这个注解时将会令编译器产生一个错误在编译期间防止潜在的不安全操作<br>更多信息请参考：<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/lang/SafeVarargs.html</a></p>
<h3 id="6-自定义注解"><a href="#6-自定义注解" class="headerlink" title="6.自定义注解"></a>6.自定义注解</h3><p><strong>声明:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationDemo &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指定注解修饰方法, 运行时有效, 两个元素为name和type<br><strong>使用:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AnnotationDemo</span>(type = <span class="string">"fruit"</span>, name = <span class="string">"apple"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anno</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析注解:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method method = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          method = AnnotationActivity.class.getMethod("anno");</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Log.e(<span class="string">"Seeyou"</span>, method.getName());</span><br><span class="line"></span><br><span class="line">      AnnotationDemo annotation = method.getAnnotation(AnnotationDemo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">      Log.e(<span class="string">"Seeyou"</span>, <span class="string">"type : "</span> + annotation.type());</span><br><span class="line">      Log.e(<span class="string">"Seeyou"</span>, <span class="string">"name : "</span> + annotation.name());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2020/04/23/moshistate/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>虽说状态模式和策略模式的结构几乎是相同的，但是它们所解决的问题是不同的。</p>
<a id="more"></a>

<h3 id="1-状态模式定义"><a href="#1-状态模式定义" class="headerlink" title="1.状态模式定义"></a>1.状态模式定义</h3><h4 id="状态模式定义"><a href="#状态模式定义" class="headerlink" title="状态模式定义"></a>状态模式定义</h4><p><strong>定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</strong></p>
<h4 id="状态模式UML图"><a href="#状态模式UML图" class="headerlink" title="状态模式UML图"></a>状态模式UML图</h4><p><img src="/2020/04/23/moshistate/moshistate1.png" alt></p>
<h4 id="在享元模式中有如下角色："><a href="#在享元模式中有如下角色：" class="headerlink" title="在享元模式中有如下角色："></a>在享元模式中有如下角色：</h4><ul>
<li>Context：环境角色，定义客户端需要的接口，并且负责具体状态的切换。</li>
<li>State：抽象状态角色，可以是抽象类或者接口，负责对象状态定义，并封装了环境角色。</li>
<li>ConcreteState：具体状态角色，实现抽象角色类，定义了本状态所要做的事情。</li>
</ul>
<h4 id="2-简单实现状态模式"><a href="#2-简单实现状态模式" class="headerlink" title="2.简单实现状态模式"></a>2.简单实现状态模式</h4><p>拿用mp3听歌来说，mp3有四种基本状态，分别是开机、关机、上一首歌和下一首歌。如果我们要写一个对mp3进行控制的类，你可能会这样写，如下所示。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp3Controller</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POWER_ON = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POWER_OFF = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> state = POWER_OFF;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (state == POWER_OFF) &#123;</span><br><span class="line"> System.out.println(<span class="string">"开机"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> state = POWER_ON;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (state == POWER_ON) &#123;</span><br><span class="line"> System.out.println(<span class="string">"关机"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> state = POWER_OFF;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (state == POWER_ON) &#123;</span><br><span class="line"> System.out.println(<span class="string">"上一首歌"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (state == POWER_ON) &#123;</span><br><span class="line"> System.out.println(<span class="string">"下一首歌"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在powerOn和powerOff方法中我们会将state置为相应的状态，在preSong和nextSong方法中，首先要判断当前mp3的state，如果是POWER_OFF，则不做任何处理，写到这里你可能会觉得实现很简单啊。那么我再添加些状态，比如待机状态、休眠状态、亮屏状态等等，顺便再添加些功能，比如调大音量、调小音量、降噪等。这样你实现起来，就会发现你会定义很多种状态，在功能中可能要用到多个条件语句进行判断，这会使得代码变得臃肿.<br>状态模式就是为了解决这一问题，将多个条件语句去掉，使得代码更加清晰，下面来进行实现。</p>
<h4 id="抽象状态角色"><a href="#抽象状态角色" class="headerlink" title="抽象状态角色"></a>抽象状态角色</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mp3State</span> </span>&#123;</span><br><span class="line"> <span class="comment">//开机</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//关机</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//上一首歌曲</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSong</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//下一首歌曲</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口Mp3State中定义了四种功能，接下来我们来实现Mp3State。</p>
<h4 id="具体状态角色"><a href="#具体状态角色" class="headerlink" title="具体状态角色"></a>具体状态角色</h4><p>我们先来实现开机状态，代码如下所示。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOnState</span> <span class="keyword">implements</span> <span class="title">Mp3State</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"已开机"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"关机"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"上一首歌"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"下一首歌"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较特殊的是powerOn方法中，打印了“已开机”，因为在PowerOnState 状态下进行开机操作是多此一举的。<br>接着实现关机状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOffState</span> <span class="keyword">implements</span> <span class="title">Mp3State</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"开机"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在关机状态中只实现了powerOn方法，其他的方法都是空实现。</p>
<h4 id="环境角色"><a href="#环境角色" class="headerlink" title="环境角色"></a>环境角色</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Mp3State mp3State;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMp3State</span><span class="params">(Mp3State mp3State)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.mp3State=mp3State;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>&#123;</span><br><span class="line"> mp3State.powerOn();</span><br><span class="line"> setMp3State(<span class="keyword">new</span> PowerOnState());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span>&#123;</span><br><span class="line"> mp3State.powerOff();</span><br><span class="line"> setMp3State(<span class="keyword">new</span> PowerOffState());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSong</span><span class="params">()</span></span>&#123;</span><br><span class="line"> mp3State.preSong();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextSong</span><span class="params">()</span></span>&#123;</span><br><span class="line"> mp3State.nextSong();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context 中定义了setMp3State方法，用来设定状态，其中powerOn方法中会调用setMp3State方法将状态置为PowerOffState，同理powerOff中将状态置为PowerOffState。</p>
<h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"> Context context=<span class="keyword">new</span> Context();</span><br><span class="line"> context.setMp3State(<span class="keyword">new</span> PowerOffState());</span><br><span class="line"> context.preSong();</span><br><span class="line"> context.powerOn();</span><br><span class="line"> context.nextSong();</span><br><span class="line"> context.powerOff();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要先设定mp3的初始状态，就可以调用各种功能方法了，不需要再考虑功能和状态之间的关系。输出结果为</p>
<blockquote>
<p>开机<br>下一首歌<br>关机</p>
</blockquote>
<p>虽然这个例子的代码很简单，这里还是给出UML图，如下所示。<br><img src="/2020/04/23/moshistate/moshistate2.png" alt></p>
<h3 id="3-状态模式的使用场景和优缺点"><a href="#3-状态模式的使用场景和优缺点" class="headerlink" title="3.状态模式的使用场景和优缺点"></a>3.状态模式的使用场景和优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>避免了过多的条件语句，使得结构更清晰，提高代码的可维护性。</li>
<li>每个状态都是一个子类，方便增加和修改状态。</li>
<li>状态被放置到类的内部，外部调用不需要知道类的内部如何实现状态和行为的变换。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>完全使用状态模式，可能会导致子类会过多。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>代码中包含大量与对象状态有关的条件语句。</li>
<li>对象的行为依赖着状态，并且行为随着状态的改变而改变。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2020/04/23/moshicelue/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>当我们写代码时总会遇到一种情况就是我们会有很多的选择，由此衍生出很多的if…else，或者case。如果每个条件语句中包含了一个简单的逻辑，那还比较容易处理，如果在一个条件语句中又包含了多个条件语句就会使得代码变得臃肿，维护的成本也会加大，这显然违背了开放封闭原则。这一讲我们就来讲策略模式，来看看它是怎么解决如上所说的问题的。  </p>
<a id="more"></a>

<h3 id="1-策略模式简介"><a href="#1-策略模式简介" class="headerlink" title="1.策略模式简介"></a>1.策略模式简介</h3><h4 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h4><p>定义一系列的算法，把每一个算法封装起来, 并且使它们可相互替换。策略模式模式使得算法可独立于使用它的客户而独立变化。</p>
<h4 id="策略模式UML图"><a href="#策略模式UML图" class="headerlink" title="策略模式UML图"></a>策略模式UML图</h4><p><img src="/2020/04/23/moshicelue/celue.png" alt></p>
<ul>
<li>Context：用来操作策略的上下文环境。</li>
<li>Stragety：策略的抽象。</li>
<li>ConcreteStragetyA、ConcreteStragetyB：具体的策略实现。</li>
</ul>
<h3 id="2-策略模式简单实现"><a href="#2-策略模式简单实现" class="headerlink" title="2.策略模式简单实现"></a>2.策略模式简单实现</h3><p>这回我们还举武侠的例子，张无忌作为一个大侠会遇到很多的对手，如果每遇到一个对手都用自己最厉害的武功去应战这显然是不明智的，于是张无忌想出了三种应战的策略分别对付三个实力层次的对手。</p>
<h4 id="定义策略接口"><a href="#定义策略接口" class="headerlink" title="定义策略接口"></a>定义策略接口</h4><p>策略接口有一个fighting的方法用于战斗：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FightingStrategy</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体策略实现"><a href="#具体策略实现" class="headerlink" title="具体策略实现"></a>具体策略实现</h4><p>分别定义三个策略来实现策略接口，用来对付三个实力层次的对手：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakRivalStrategy</span> <span class="keyword">implements</span> <span class="title">FightingStrategy</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"遇到了较弱的对手，张无忌使用太极剑"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonRivalStrategy</span> <span class="keyword">implements</span> <span class="title">FightingStrategy</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"遇到了普通的对手，张无忌使用圣火令神功"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrongRivalStrategy</span> <span class="keyword">implements</span> <span class="title">FightingStrategy</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"遇到了强大的对手，张无忌使用乾坤大挪移"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现环境类"><a href="#实现环境类" class="headerlink" title="实现环境类"></a>实现环境类</h4><p>环境类的构造函数包含了策略类，通过传进来不同的具体策略来调用不同策略的fighting方法：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> FightingStrategy fightingStrategy;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(FightingStrategy fightingStrategy)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.fightingStrategy = fightingStrategy;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fighting</span><span class="params">()</span></span>&#123;</span><br><span class="line"> fightingStrategy.fighting();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><p>张无忌会对不同实力层次的对手，采用了不同的策略来应战，为了举例，这里省略了对不同实力层次进行判断的条件语句，代码如下所示。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuJi</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Context context;</span><br><span class="line"> <span class="comment">//如果遇到弱的对手</span></span><br><span class="line"> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> WeakRivalStrategy());</span><br><span class="line"> context.fighting();</span><br><span class="line"> <span class="comment">//如果遇到普通的对手</span></span><br><span class="line"> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> CommonRivalStrategy());</span><br><span class="line"> context.fighting();</span><br><span class="line"> <span class="comment">//如果遇到强劲的对手</span></span><br><span class="line"> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> StrongRivalStrategy());</span><br><span class="line"> context.fighting();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面只是举了一个简单的例子，其实情况会很多，比如遇到普通的对手，也不能完全用圣火令神功，比如当遇到周芷若和赵敏时就需要手下留情，采用太极剑。又比如遇到强劲的对手张三丰，也不能用乾坤大挪移，类似这样的情况会很多，这样在每个策略类中可能会出现很多条件语句，但是试想一下如果我们不用策略模式来封装这些条件语句，那么可能会导致一个条件语句中又包含了多个条件语句，这样会使得代码变得臃肿，维护的成本也会加大。</p>
<h3 id="3-策略模式优缺点和使用场景"><a href="#3-策略模式优缺点和使用场景" class="headerlink" title="3.策略模式优缺点和使用场景"></a>3.策略模式优缺点和使用场景</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。</li>
<li>使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。</li>
<li>策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>一个类定义了很多行为，而且这些行为在这个类里的操作以多个条件语句的形式出现。策略模式将相关的条件分支移入它们各自的 Strategy 类中以代替这些条件语句。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Gson使用</title>
    <url>/2020/04/23/androidgson/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Gson是google推出的用来解析json数据的开源框架,  简单的数据格式通过原生的框架JsonObject或者JsonArray还好, 复杂的数据格式的情况下会很繁琐, 了解了一下Gson的简单用法记录下来, 也方便看到这篇blog的同学能够快速上手这个框架</p>
<a id="more"></a>

<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用:"></a><strong>简单使用:</strong></h4><p><strong>Json语法:</strong></p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>Gson解析Bean:</strong></p>
<p><strong>Json数据内容:</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"App"</span>: <span class="string">"http://apk.yoolauncher.com/apk/14588716557753.apk"</span>,</span><br><span class="line">    <span class="attr">"Apps"</span>: <span class="string">"3.42M"</span>,</span><br><span class="line">    <span class="attr">"Auth"</span>: <span class="string">"邻家胖子"</span>,</span><br><span class="line">    <span class="attr">"DC"</span>: <span class="number">11628</span>,</span><br><span class="line">    <span class="attr">"Id"</span>: <span class="string">"6510"</span>,</span><br><span class="line">    <span class="attr">"Name"</span>: <span class="string">"淡雅女子7"</span>,</span><br><span class="line">    <span class="attr">"Rem"</span>: <span class="string">"&lt;p&gt;when can i see you again，淡雅女子第七季。&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;本主题不包含YOO桌面，必需下载安装YOO桌面才能正常使用.YOO桌面自适配所有机型，占用内存少，可以实现多屏壁纸，新增了天气时钟和一键开关、一键清理、搜索条的插件;YOO桌面拥有海量主题随心换，专业的主题制作团队，海量精美主题免费下载！YOO桌面主题技术支持:143659751.&lt;/p&gt;"</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>** 创建Theme Bean**</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String App;</span><br><span class="line">    <span class="keyword">private</span> String Apps;</span><br><span class="line">    <span class="keyword">private</span> String Auth;</span><br><span class="line">    <span class="keyword">private</span> String DC;</span><br><span class="line">    <span class="keyword">private</span> String Id;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> String Rem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getApp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> App; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApp</span><span class="params">(String app)</span> </span>&#123; App = app; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getApps</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Apps; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApps</span><span class="params">(String apps)</span> </span>&#123; Apps = apps; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Auth; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuth</span><span class="params">(String auth)</span> </span>&#123; Auth = auth; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDC</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> DC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDC</span><span class="params">(String DC)</span> </span>&#123; <span class="keyword">this</span>.DC = DC; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123; Id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; Name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRem</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Rem; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRem</span><span class="params">(String rem)</span> </span>&#123; Rem = rem; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析Bean代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().create();</span><br><span class="line">Bean bean = gson.fromJson(jsonString, Bean<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Gson解析数组:</strong></p>
<p><strong>Json数据内容</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"hotword"</span>: <span class="string">"向艳梅斩获金牌"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://m.yz2.sm.cn/s?q=%E5%90%91%E8%89%B3%E6%A2%85%E6%96%A9%E8%8E%B7%E9%87%91%E7%89%8C&amp;by=hot&amp;from=wm635479"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"hotword"</span>: <span class="string">"傅园慧网络直播"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://m.yz2.sm.cn/s?q=%E5%82%85%E5%9B%AD%E6%85%A7%E7%BD%91%E7%BB%9C%E7%9B%B4%E6%92%AD&amp;by=hot&amp;from=wm635479"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"hotword"</span>: <span class="string">"亲哥偷走23万"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://m.yz2.sm.cn/s?q=%E4%BA%B2%E5%93%A5%E5%81%B7%E8%B5%B023%E4%B8%87&amp;by=hot&amp;from=wm635479"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>创建热词Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotWords</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String hotword;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHotword</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hotword; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHotword</span><span class="params">(String hotword)</span> </span>&#123; <span class="keyword">this</span>.hotword = hotword; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123; <span class="keyword">this</span>.url = url; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().create();</span><br><span class="line">Bean bean = gson.fromJson(jsonString, <span class="keyword">new</span> TypeToken&lt;List&lt;Bean&gt;&gt;()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>

<p><strong>复杂解析方式:</strong></p>
<p>内部进行对象 集合嵌套</p>
<p>复杂数据格式: (天气数据)</p>
<p><img src="/2020/04/23/androidgson/20160812191747_76678.png" alt></p>
<p>整体视为 status,  内部包含 results 数组, results 单个项目内包含 weather_data 数组</p>
<p><strong>首先定义status Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>   </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> String error;  </span><br><span class="line">        <span class="keyword">private</span> String status;  </span><br><span class="line">        <span class="keyword">private</span> String date;  </span><br><span class="line">        <span class="keyword">private</span> List&lt;Results&gt; results;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span></span>&#123;   <span class="keyword">return</span> error;   &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span></span>&#123; <span class="keyword">this</span>.error = error;   &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span> status; &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span></span>&#123;  <span class="keyword">this</span>.status = status; &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span></span>&#123;  <span class="keyword">return</span> date;  &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span></span>&#123; <span class="keyword">this</span>.date = date;&#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Results&gt; <span class="title">getResults</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> results;&#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResults</span><span class="params">(List&lt;Results&gt; results)</span></span>&#123; <span class="keyword">this</span>.results = results; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义Results Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Results</span>   </span></span><br><span class="line"><span class="class"></span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> String currentCity;  </span><br><span class="line">    <span class="keyword">private</span> List&lt;Weather&gt; weather_data;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCurrentCity</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> currentCity;  &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentCity</span><span class="params">(String currentCity)</span> </span>&#123; <span class="keyword">this</span>.currentCity = currentCity; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Weather&gt; <span class="title">getWeather_data</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weather_data; &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeather_data</span><span class="params">(List&lt;Weather&gt; weather_data)</span> </span>&#123; <span class="keyword">this</span>.weather_data = weather_data; &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义Weather Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String date;  </span><br><span class="line">                <span class="keyword">private</span> String dayPictureUrl;  </span><br><span class="line">                <span class="keyword">private</span> String nightPictureUrl;  </span><br><span class="line">                <span class="keyword">private</span> String weather;  </span><br><span class="line">                <span class="keyword">private</span> String wind;  </span><br><span class="line">                <span class="keyword">private</span> String temperature;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> date; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123; <span class="keyword">this</span>.date = date; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getDayPictureUrl</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dayPictureUrl; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDayPictureUrl</span><span class="params">(String dayPictureUrl)</span> </span>&#123; <span class="keyword">this</span>.dayPictureUrl = dayPictureUrl; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getNightPictureUrl</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nightPictureUrl; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNightPictureUrl</span><span class="params">(String nightPictureUrl)</span> </span>&#123; <span class="keyword">this</span>.nightPictureUrl = nightPictureUrl; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getWeather</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> weather; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeather</span><span class="params">(String weather)</span> </span>&#123; <span class="keyword">this</span>.weather = weather; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getWind</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> wind; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWind</span><span class="params">(String wind)</span> </span>&#123; <span class="keyword">this</span>.wind = wind; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">getTemperature</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> temperature; &#125;  </span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemperature</span><span class="params">(String temperature)</span> </span>&#123; <span class="keyword">this</span>.temperature = temperature; &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解析代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Gson gson = <span class="keyword">new</span> GsonBuilder().setPrettyPrinting().create();</span><br><span class="line">Status s = gson.fromJson(Constant.themeBean, Status<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gson</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/04/22/moshidaili/</url>
    <content><![CDATA[<h3 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式-代理模式"></a>设计模式-代理模式</h3><h4 id="1-代理模式简介"><a href="#1-代理模式简介" class="headerlink" title="1.代理模式简介"></a>1.代理模式简介</h4><h5 id="代理模式介绍"><a href="#代理模式介绍" class="headerlink" title="代理模式介绍"></a>代理模式介绍</h5><p>代理模式也叫委托模式，是结构型设计模式的一种。在现实生活中我们用到类似代理模式的场景有很多，比如代购、代理上网、打官司等。</p>
<a id="more"></a>

<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>为其他对象提供一种代理以控制这个对象的访问。</p>
<h4 id="2-代理模式的简单实现"><a href="#2-代理模式的简单实现" class="headerlink" title="2.代理模式的简单实现"></a>2.代理模式的简单实现</h4><p>假设我要买一个国际奢侈品品牌的包，国内的太贵了，我找了个代购来帮我海外购买，这样能省好多钱，哈哈。</p>
<h5 id="抽象主题类（Subject）"><a href="#抽象主题类（Subject）" class="headerlink" title="抽象主题类（Subject）"></a>抽象主题类（Subject）</h5><p>抽象主题类具有真实主题类和代理的共同接口方法，我想要代购，那共同的方法就是购买：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShop</span> </span>&#123;</span><br><span class="line">    <span class="comment">//购买</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="真实主题类（RealSubject）"><a href="#真实主题类（RealSubject）" class="headerlink" title="真实主题类（RealSubject）"></a>真实主题类（RealSubject）</h5><p>这个购买者Mark也就是我，实现了IShop接口提供的 buy()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mark</span> <span class="keyword">implements</span> <span class="title">IShop</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代理类（ProxySubject）"><a href="#代理类（ProxySubject）" class="headerlink" title="代理类（ProxySubject）"></a>代理类（ProxySubject）</h5><p>我找的代理类同样也要实现IShop接口，并且要持有被代理者，在buy()方法中调用了被代理者的buy()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Purchasing</span> <span class="keyword">implements</span> <span class="title">IShop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IShop mShop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Purchasing</span><span class="params">(IShop shop)</span></span>&#123;</span><br><span class="line">        mShop=shop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端类（Client）"><a href="#客户端类（Client）" class="headerlink" title="客户端类（Client）"></a>客户端类（Client）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建Mark</span></span><br><span class="line">        IShop mark = <span class="keyword">new</span> Mark();</span><br><span class="line">        <span class="comment">//创建代购者并将Mark作为构造函数传</span></span><br><span class="line">        IShop purchasing = <span class="keyword">new</span> Purchasing(mark);</span><br><span class="line">        purchasing.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完客户端类的代码，其实也是很好理解，就是代理类包含了真实主题类（被代理者），最终调用的都是真实主题类（被代理者）实现的方法，在上面的例子就是Mark类的buy()方法，所以运行的结果就是“购买”。</p>
<h4 id="3-动态代理的简单实现"><a href="#3-动态代理的简单实现" class="headerlink" title="3.动态代理的简单实现"></a>3.动态代理的简单实现</h4><p>从编码的角度来说，代理模式分为静态代理和动态代理，上面的例子是静态代理，在代码运行前就已经存在了代理类的class编译文件，而动态代理则是在代码运行时通过反射来动态的生成代理类的对象，并确定到底来代理谁。也就是我们在编码阶段不需要知道代理谁，代理谁我们将会在代码运行时决定。Java提供了动态的代理接口InvocationHandler，实现该接口需要重写invoke()方法。下面我们在上面静态代理的例子上做修改：</p>
<p>创建动态代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicPurchasing</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicPurchasing</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = method.invoke(obj, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在动态代理类中我们声明一个Object的引用，该引用指向被代理类，我们调用被代理类的具体方法在invoke()方法中执行。接下来我们修改客户端类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建Mark</span></span><br><span class="line">        IShop mark=<span class="keyword">new</span> Mark();</span><br><span class="line">        <span class="comment">//创建动态代理</span></span><br><span class="line">        DynamicPurchasing  mDynamicPurchasing=<span class="keyword">new</span> DynamicPurchasing(mark);</span><br><span class="line">        <span class="comment">//创建Mark的ClassLoader</span></span><br><span class="line">        ClassLoader loader=mark.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">//动态创建代理类</span></span><br><span class="line">        IShop purchasing= (IShop) Proxy.newProxyInstance(loader,<span class="keyword">new</span> Class[]&#123;IShop<span class="class">.<span class="keyword">class</span>&#125;,<span class="title">mDynamicPurchasing</span>)</span>;</span><br><span class="line">        purchasing.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-代理模式的应用"><a href="#4-代理模式的应用" class="headerlink" title="4.代理模式的应用"></a>4.代理模式的应用</h4><p><strong>代理模式类型</strong><br>代理模式的类型主要有以下几点：</p>
<ul>
<li><p>远程代理：为一个对象在不同的地址空间提供局部代表，这样系统可以将Server部分的事项隐藏。</p>
</li>
<li><p>虚拟代理：使用一个代理对象表示一个十分耗资源的对象并在真正需要时才创建。</p>
</li>
<li><p>安全代理：用来控制真实对象访问时的权限。</p>
</li>
<li><p>智能指引：当调用真实的对象时，代理处理另外一些事，比如计算真实对象的引用计数，当该对象没有引用时，可以自动释放它；或者访问一个实际对象时，检查是否已经能够锁定它，以确保其他对象不能改变它。</p>
</li>
</ul>
<h5 id="代理模式使用场景"><a href="#代理模式使用场景" class="headerlink" title="代理模式使用场景"></a>代理模式使用场景</h5><p>无法或者不想直接访问某个对象时可以通过一个代理对象来间接的访问。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2020/04/22/moshiwaiguan/</url>
    <content><![CDATA[<h3 id="设计模式-外观模式"><a href="#设计模式-外观模式" class="headerlink" title="设计模式-外观模式"></a>设计模式-外观模式</h3><h4 id="1-外观模式简介"><a href="#1-外观模式简介" class="headerlink" title="1.外观模式简介"></a>1.外观模式简介</h4><h5 id="外观模式介绍"><a href="#外观模式介绍" class="headerlink" title="外观模式介绍"></a>外观模式介绍</h5><p>当我们开发Android的时候，无论是做SDK还是封装API，我们大多都会用到外观模式，它通过一个外观类使得整个系统的结构只有一个统一的高层接口，这样能降低用户的使用成本。</p>
<a id="more"></a>

<h5 id="外观模式定义"><a href="#外观模式定义" class="headerlink" title="外观模式定义"></a>外观模式定义</h5><p>为系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得子系统更加容易使用。</p>
<h4 id="2-外观模式的简单实现"><a href="#2-外观模式的简单实现" class="headerlink" title="2.外观模式的简单实现"></a>2.外观模式的简单实现</h4><p>在上一篇设计模式之装饰模式我们举了武侠的例子，这一篇我们还举武侠的例子，首先我们把武侠张无忌当作一个系统，他作为一个武侠，他本身分为三个系统分别是招式、内功和经脉。</p>
<p><strong>子系统类（Subsystem）</strong><br>我们知道张无忌的三个系统分别是招式、内功和经脉。那我们来创建它们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 子系统招式 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhaoShi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TaiJiQuan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"使用着招式太极拳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QiShangQuan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"使用招式七伤拳"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShengHuo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"使用招式圣火令"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** * 子系统内功 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JiuYang</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"使用九阳神功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QianKun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"使用乾坤大挪移"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** * 子系统经脉 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingMai</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jingmai</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"开启经脉"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>张无忌有很多的武学和内功，怎么将他们搭配，并对外界隐藏呢，我们接下来看看外观类：</p>
<p><strong>外观类（Facade）</strong><br>这里的外观类就是张无忌，他负责将自己的招式、内功和经脉通过不同的情况合理的运用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 外观类张无忌 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZhangWuJi</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JingMai jingMai;</span><br><span class="line">    <span class="keyword">private</span> ZhaoShi zhaoShi;</span><br><span class="line">    <span class="keyword">private</span> NeiGong neiGong;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZhangWuJi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jingMai=<span class="keyword">new</span> JingMai();</span><br><span class="line">        zhaoShi=<span class="keyword">new</span> ZhaoShi();</span><br><span class="line">        neiGong=<span class="keyword">new</span> NeiGong();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**     * 使用乾坤大挪移     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qiankun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jingMai.jingmai();<span class="comment">//开启经脉</span></span><br><span class="line">        neiGong.QianKun();<span class="comment">//使用内功乾坤大挪移</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**     * 使用七伤拳     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">QiShang</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jingMai.jingmai(); <span class="comment">//开启经脉</span></span><br><span class="line">        neiGong.JiuYang();<span class="comment">//使用内功九阳神功</span></span><br><span class="line">        zhaoShi.QiShangQuan();<span class="comment">//使用招式七伤拳</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化外观类的同时将各个子系统类创建好。很明显张无忌很好的将自身的各个系统搭配好，如果使用七伤拳的话就需要开启经脉、使用内功九阳神功接下来使用招式七伤拳，如果不开经脉或者使用九阳神功的话那么七伤拳的威力会大打折扣。</p>
<p><strong>客户端调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ZhangWuJi zhangWuJi=<span class="keyword">new</span> ZhangWuJi();</span><br><span class="line">        <span class="comment">//张无忌使用乾坤大挪移</span></span><br><span class="line">        zhangWuJi.Qiankun();</span><br><span class="line">        <span class="comment">//张无忌使用七伤拳</span></span><br><span class="line">        zhangWuJi.QiShang();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当张无忌使用乾坤大挪移或者七伤拳的时候，比武的对手显然不知道张无忌本身运用了什么，同时张无忌也不需要去重新计划使用七伤拳的时候需要怎么做，他已经早就计划好了。如果每次使用七伤拳或者乾坤大挪移时都要计划怎么做很显然会增加成本并贻误战机。另外张无忌也可以改变自己的内功、招式和经脉，这些都是对比武的对手有所隐藏的。<br>外观模式本身就是将子系统的逻辑和交互隐藏起来，为用户提供一个高层次的接口，使得系统更加易用，同时也隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会感知到。</p>
<h4 id="3-外观模式使用场景"><a href="#3-外观模式使用场景" class="headerlink" title="3.外观模式使用场景"></a>3.外观模式使用场景</h4><ul>
<li><p>构建一个有层次结构的子系统时，使用外观模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，则可以让他们通过外观接口进行通信，减少子系统之间的依赖关系。</p>
</li>
<li><p>子系统往往会因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生很多很小的类，这给外部调用他们的用户程序带来了使用的困难，我们可以使用外观类提供一个简单的接口，对外隐藏子系统的具体实现并隔离变化。</p>
</li>
<li><p>当维护一个遗留的大型系统时，可能这个系统已经非常难以维护和拓展，但因为它含有重要的功能，新的需求必须依赖于它，则可以使用外观类，来为设计粗糙或者复杂的遗留代码提供一个简单的接口，让新系统和外观类交互，而外观类负责与遗留的代码进行交互。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2020/04/22/moshizhuangshi/</url>
    <content><![CDATA[<h3 id="设计模式-装饰模式"><a href="#设计模式-装饰模式" class="headerlink" title="设计模式-装饰模式"></a>设计模式-装饰模式</h3><h4 id="1-装饰模式简介"><a href="#1-装饰模式简介" class="headerlink" title="1.装饰模式简介"></a>1.装饰模式简介</h4><h5 id="装饰模式介绍"><a href="#装饰模式介绍" class="headerlink" title="装饰模式介绍"></a>装饰模式介绍</h5><p>装饰模式是结构型设计模式之一，不必改变类文件和使用继承的情况下，动态地扩展一个对象的功能，是继承的替代方案之一。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。</p>
<a id="more"></a>

<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<h4 id="2-装饰模式的简单实现"><a href="#2-装饰模式的简单实现" class="headerlink" title="2.装饰模式的简单实现"></a>2.装饰模式的简单实现</h4><p>装饰模式在现实生活中有很多例子，比如给一个人穿上各种衣服，给一幅画涂色上框等等，这次我要举得例子有些不同，举一个武侠修炼武功的例子：杨过本身就会全真剑法，有两位武学前辈洪七公和欧阳锋分别传授杨过打狗棒法和蛤蟆功，这样杨过除了会全真剑法还会打狗棒法和蛤蟆功。</p>
<h5 id="抽象组件（Component）"><a href="#抽象组件（Component）" class="headerlink" title="抽象组件（Component）"></a>抽象组件（Component）</h5><p>作为武侠肯定要会使用武功的，我们先定义一个武侠的抽象类，里面有使用武功的抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Swordsman</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**     </span></span><br><span class="line"><span class="comment">    * Swordsman武侠有使用武功的抽象方法     </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attackMagic</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="组件具体实现类（ConcreteComponent）"><a href="#组件具体实现类（ConcreteComponent）" class="headerlink" title="组件具体实现类（ConcreteComponent）"></a>组件具体实现类（ConcreteComponent）</h5><p>被装饰的具体对象，在这里就是被教授武学的具体的武侠，他就是杨过，杨过作为武侠当然也会武学，虽然不怎么厉害：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangGuo</span> <span class="keyword">extends</span> <span class="title">Swordsman</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackMagic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//杨过初始的武学是全真剑法</span></span><br><span class="line">        System.out.println(<span class="string">"杨过使用全真剑法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象装饰者（Decorator）"><a href="#抽象装饰者（Decorator）" class="headerlink" title="抽象装饰者（Decorator）"></a>抽象装饰者（Decorator）</h5><p>抽象装饰者保持了一个对抽象组件的引用，方便调用被装饰对象中的方法。在这个例子中就是武学前辈要持有武侠的引用，方便教授他武学并“融会贯通”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Master</span> <span class="keyword">extends</span> <span class="title">Swordsman</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Swordsman mSwordsman;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Master</span><span class="params">(Swordsman mSwordsman)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mSwordsman=mSwordsman;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackMagic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mSwordsman.attackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="装饰者具体实现类（ConcreteDecorator）"><a href="#装饰者具体实现类（ConcreteDecorator）" class="headerlink" title="装饰者具体实现类（ConcreteDecorator）"></a>装饰者具体实现类（ConcreteDecorator）</h5><p>这个例子中用两个装饰者具体实现类，分别是洪七公和欧阳锋，他们负责来传授杨过新的武功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HongQiGong</span> <span class="keyword">extends</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HongQiGong</span><span class="params">(Swordsman mSwordsman)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mSwordsman);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teachAttackMagic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洪七公教授打狗棒法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"杨过使用打狗棒法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackMagic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attackMagic();</span><br><span class="line">        teachAttackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuYangFeng</span> <span class="keyword">extends</span> <span class="title">Master</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuYangFeng</span><span class="params">(Swordsman mSwordsman)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mSwordsman);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teachAttackMagic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"欧阳锋教授蛤蟆功"</span>);</span><br><span class="line">        System.out.println(<span class="string">"杨过使用蛤蟆功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attackMagic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attackMagic();</span><br><span class="line">        teachAttackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h5><p>经过洪七公和欧阳锋的教导，杨过除了初始武学全真剑法又学会了打狗棒法和蛤蟆功：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建杨过</span></span><br><span class="line">        YangGuo mYangGuo=<span class="keyword">new</span> YangGuo();</span><br><span class="line">        <span class="comment">//洪七公教授杨过打狗棒法，杨过会了打狗棒法</span></span><br><span class="line">        HongQiGong mHongQiGong=<span class="keyword">new</span> HongQiGong(mYangGuo);</span><br><span class="line">        mHongQiGong.attackMagic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//欧阳锋教授杨过蛤蟆功，杨过学会了蛤蟆功</span></span><br><span class="line">        OuYangFeng mOuYangFeng=<span class="keyword">new</span> OuYangFeng(mYangGuo);</span><br><span class="line">        mOuYangFeng.attackMagic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-装饰模式的优缺点和使用场景"><a href="#3-装饰模式的优缺点和使用场景" class="headerlink" title="3.装饰模式的优缺点和使用场景"></a>3.装饰模式的优缺点和使用场景</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>通过组合而非继承的方式，动态的来扩展一个对象的功能，在运行时选择不同的装饰器，从而实现不同的行为。<br>有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。<br>具体组件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体组件类和具体装饰类，在使用时再对其进行组合，原有代码无须改变，符合“开闭原则”。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>装饰链不能过长，否则会影响效率。<br>因为所有对象都是继承于Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，如果基类改变，势必影响对象的内部。<br>比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐，所以只在必要的时候使用装饰者模式。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。<br>需要动态地给一个对象增加功能，这些功能可以动态的撤销。<br>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<h4 id="4-装饰模式和代理模式"><a href="#4-装饰模式和代理模式" class="headerlink" title="4.装饰模式和代理模式"></a>4.装饰模式和代理模式</h4><p>代理模式和装饰模式有点像，都是持有了被代理或者被装饰对象的引用。它们两个最大的不同就是装饰模式对引用的对象增加了功能，而代理模式只是对引用对象进行了控制却没有对引用对象本身增加功能。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2020/04/22/moshixiangyuan/</url>
    <content><![CDATA[<h3 id="设计模式-享元模式"><a href="#设计模式-享元模式" class="headerlink" title="设计模式-享元模式"></a>设计模式-享元模式</h3><h4 id="享元模式定义"><a href="#享元模式定义" class="headerlink" title="享元模式定义"></a>享元模式定义</h4><p>享元模式是结构型设计模式的一种，是池技术的重要实现方式，它可以减少应用程序创建的对象，降低程序内存的占用，提高程序的性能。</p>
<a id="more"></a>

<h4 id="定义：使用共享对象有效的支持大量细粒度的对象"><a href="#定义：使用共享对象有效的支持大量细粒度的对象" class="headerlink" title="定义：使用共享对象有效的支持大量细粒度的对象"></a>定义：使用共享对象有效的支持大量细粒度的对象</h4><p>要求细粒度对象，那么不可避免地使得对象数量多且性质相近，这些对象分为两个部分：内部状态和外部状态。内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变。而外部状态是对象依赖的一个标记是随环境改变而改变的并且不可共享的状态。</p>
<p><strong>抽象享元角色</strong><br>抽象享元角色是一个商品接口，它定义了showGoodsPrice方法用来展示商品的价格：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGoods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGoodsPrice</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体享元角色</strong><br>定义类Goods，它实现IGoods 接口，并实现了showGoodsPrice方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">IGoods</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> String version;<span class="comment">//版本</span></span><br><span class="line">    Goods(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGoodsPrice</span><span class="params">(String version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(version.equals(<span class="string">"32G"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"价格为5199元"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(version.equals(<span class="string">"128G"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"价格为5999元"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中name为内部状态，version为外部状态。showGoodsPrice方法根据version的不同会打印出不同的价格。</p>
<h4 id="享元工厂"><a href="#享元工厂" class="headerlink" title="享元工厂"></a>享元工厂</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Goods&gt; pool=<span class="keyword">new</span> HashMap&lt;String, Goods&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Goods <span class="title">getGoods</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pool.containsKey(name))&#123;</span><br><span class="line">            System.out.println(<span class="string">"使用缓存,key为:"</span>+name);</span><br><span class="line">            <span class="keyword">return</span> pool.get(name);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Goods goods=<span class="keyword">new</span> Goods(name);</span><br><span class="line">            pool.put(name,goods);</span><br><span class="line">            System.out.println(<span class="string">"创建商品,key为:"</span>+name);</span><br><span class="line">            <span class="keyword">return</span> goods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>享元工厂GoodsFactory 用来创建Goods对象。通过Map容器来存储Goods对象，将内部状态name作为Map的key，以便标识Goods对象。如果Map容器中包含此key，则使用Map容器中存储的Goods对象，否则就新创建Goods对象，并放入Map容器中。</p>
<h4 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h4><p>客户端中调用GoodsFactory的getGoods方法来创建Goods对象，并调用Goods 的showGoodsPrice方法来显示产品的价格，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">        Goods goods1=GoodsFactory.getGoods(<span class="string">"iphonex"</span>);</span><br><span class="line">        goods1.showGoodsPrice(<span class="string">"32G"</span>);</span><br><span class="line">        Goods goods2=GoodsFactory.getGoods(<span class="string">"iphonex"</span>);</span><br><span class="line">        goods2.showGoodsPrice(<span class="string">"32G"</span>);</span><br><span class="line">        Goods goods3=GoodsFactory.getGoods(<span class="string">"iphonex"</span>);</span><br><span class="line">        goods3.showGoodsPrice(<span class="string">"128G"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>创建商品,key为:iphonex<br>价格为5199元<br>使用缓存,key为:iphonex<br>价格为5199元<br>使用缓存,key为:iphonex<br>价格为5999元</p>
</blockquote>
<p>从输出看出，只有第一次是创建Goods对象，后面因为key值相同，所以都是使用了对象池中的Goods对象。在这个例子中，name作为内部状态是不变的，并且作为Map的key值是可以共享的。而showGoodsPrice方法中需要传入的version值则是外部状态，他的值是变化的。</p>
<h4 id="享元模式的使用场景"><a href="#享元模式的使用场景" class="headerlink" title="享元模式的使用场景"></a>享元模式的使用场景</h4><p>系统中存在大量的相似对象。<br>需要缓冲池的场景。<br>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p>
<h4 id="现实应用举例"><a href="#现实应用举例" class="headerlink" title="现实应用举例"></a>现实应用举例</h4><p>JAVA整型中128陷阱<br>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer a = <span class="number">68</span>;</span><br><span class="line">    Integer b = <span class="number">68</span>;</span><br><span class="line">    Integer c = <span class="number">127</span>;</span><br><span class="line">    Integer d = <span class="number">127</span>;</span><br><span class="line">    Integer e = <span class="number">128</span>;</span><br><span class="line">    Integer f = <span class="number">128</span>;</span><br><span class="line">    System.out.print(<span class="string">"a和b:"</span>);</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">    System.out.print(<span class="string">"c和d:"</span>);</span><br><span class="line">    System.out.println(c == d);</span><br><span class="line">    System.out.print(<span class="string">"e和f:"</span>);</span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a和b:<span class="keyword">true</span></span><br><span class="line">c和d:<span class="keyword">true</span></span><br><span class="line">e和f:<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>java在 -128~127 区间的Integer就会采用享元设计模式来重复使用, 不会创建新的对象</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/04/19/moshiyuanxing/</url>
    <content><![CDATA[<h3 id="设计模式-原型模式"><a href="#设计模式-原型模式" class="headerlink" title="设计模式-原型模式"></a>设计模式-原型模式</h3><h4 id="1-原型模式定义"><a href="#1-原型模式定义" class="headerlink" title="1.原型模式定义"></a>1.原型模式定义</h4><p>原型模式定义<br>定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<a id="more"></a>

<h4 id="2-原型模式简单实现"><a href="#2-原型模式简单实现" class="headerlink" title="2.原型模式简单实现"></a>2.原型模式简单实现</h4><p>原型模式的核心是clone方法，通过该方法进行拷贝，这里举一个名片拷贝的例子。<br>现在已经流行电子名片了，只要扫一下就可以将名片拷贝到自己的名片库中， 我们先实现名片类。</p>
<p><strong>具体的原型类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessCard</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessCard</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行构造函数BusinessCard"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompany</span><span class="params">(String company)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BusinessCard <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BusinessCard businessCard = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            businessCard = (BusinessCard) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> businessCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"company:"</span> + company);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BusinessCard类实现了Cloneable接口，它是一个标识接口，表示这个对象是可拷贝的，只要重写clone方法就可以实现拷贝。如果实现了Cloneable接口却没有重写clone方法就会报错。需要注意的是，clone方法不是在Cloneable接口中定义的（Cloneable接口中没有定义任何方法），而是在Object中定义的。</p>
<p><strong>客户端调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BusinessCard businessCard = <span class="keyword">new</span> BusinessCard();</span><br><span class="line">        businessCard.setName(<span class="string">"钱三"</span>);</span><br><span class="line">        businessCard.setCompany(<span class="string">"阿里"</span>);</span><br><span class="line">        <span class="comment">//拷贝名片</span></span><br><span class="line">        BusinessCard cloneCard1 = businessCard.clone();</span><br><span class="line">        cloneCard1.setName(<span class="string">"赵四"</span>);</span><br><span class="line">        cloneCard1.setCompany(<span class="string">"百度"</span>);</span><br><span class="line"></span><br><span class="line">        BusinessCard cloneCard2 = businessCard.clone();</span><br><span class="line">        cloneCard2.setName(<span class="string">"孙五"</span>);</span><br><span class="line">        cloneCard2.setCompany(<span class="string">"腾讯"</span>);</span><br><span class="line"></span><br><span class="line">        businessCard.show();</span><br><span class="line">        cloneCard1.show();</span><br><span class="line">        cloneCard2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了第一个名片，其他两个名片都是通过clone方法得到的，需要注意的是，clone方法并不会执行cloneCard1和cloneCard2的构造函数，运行结果为：</p>
<blockquote>
<p>执行构造函数BusinessCard<br>name:钱三<br>company:阿里<br>name:赵四<br>company:百度<br>name:孙五<br>company:腾讯</p>
</blockquote>
<h4 id="3-浅拷贝和深拷贝"><a href="#3-浅拷贝和深拷贝" class="headerlink" title="3.浅拷贝和深拷贝"></a>3.浅拷贝和深拷贝</h4><p>原型模式涉及到浅拷贝和深拷贝的知识点，为了更好的理解它们，还需要举一些例子。</p>
<p><strong>实现浅拷贝</strong><br>上述的例子中，BusinessCard的字段都是String类型的，如果字段是引用的类型的，会出现什么情况呢？如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepBusinessCard</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Company company = <span class="keyword">new</span> Company();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompany</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.company.setName(name);</span><br><span class="line">        <span class="keyword">this</span>.company.setAddress(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeepBusinessCard <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DeepBusinessCard businessCard = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            businessCard = (DeepBusinessCard) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> businessCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"company:"</span> + company.getName() + <span class="string">"-address-"</span> + company.getAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了DeepBusinessCard 类，它的字段company是引用类型的，Company类如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ```在客户端使用DeepBusinessCard：```Java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       DeepBusinessCard businessCard=<span class="keyword">new</span> DeepBusinessCard();</span><br><span class="line">        businessCard.setName(<span class="string">"钱三"</span>);</span><br><span class="line">        businessCard.setCompany(<span class="string">"阿里"</span>,<span class="string">"北京望京"</span>);</span><br><span class="line"></span><br><span class="line">        DeepBusinessCard cloneCard1=businessCard.clone();</span><br><span class="line">        cloneCard1.setName(<span class="string">"赵四"</span>);</span><br><span class="line">        cloneCard1.setCompany(<span class="string">"百度"</span>,<span class="string">"北京西二旗"</span>);</span><br><span class="line"></span><br><span class="line">        DeepBusinessCard cloneCard2=businessCard.clone();</span><br><span class="line">        cloneCard2.setName(<span class="string">"孙五"</span>);</span><br><span class="line">        cloneCard2.setCompany(<span class="string">"腾讯"</span>,<span class="string">"北京中关村"</span>);</span><br><span class="line"></span><br><span class="line">        businessCard.show();</span><br><span class="line">        cloneCard1.show();</span><br><span class="line">        cloneCard2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为： </p>
<blockquote>
<p>name:钱三<br>company:腾讯-address-北京中关村<br>name:赵四<br>company:腾讯-address-北京中关村<br>name:孙五<br>company:腾讯-address-北京中关村</p>
</blockquote>
<p>从结果可以看出company字段为最后设置的”腾讯”、”北京中关村”。这是因为Object类提供的clone方法，不会拷贝对象中的内部数组和引用对象，导致它们仍旧指向原来对象的内部元素地址，这种拷贝叫做浅拷贝。<br>company字段是引用类型，businessCard被拷贝后，company字段仍旧指向原来的businessCard对象的company字段的地址。这样我们每次设置company字段，都会覆盖上一次设置的值，最终留下的就是最后一次设置的值：”腾讯”、”北京中关村”。</p>
<p>拷贝businessCard对象的同时，也将它内部的引用对象company进行拷贝，使得每个拷贝的对象之间无任何关联，都指向了自身对应的company，这种拷贝就是深拷贝。</p>
<p><strong>实现深拷贝</strong><br>首先需要修改Company类，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Company company=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            company= (Company) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> company;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现Company类能被拷贝，Company类也需要实现Cloneable接口并且覆写clone方法。接着修改DeepBusinessCard的clone方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepBusinessCard</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Company company = <span class="keyword">new</span> Company();</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeepBusinessCard <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DeepBusinessCard businessCard = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            businessCard = (DeepBusinessCard) <span class="keyword">super</span>.clone();</span><br><span class="line">            businessCard.company = <span class="keyword">this</span>.company.clone();<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> businessCard;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在注释1处增加了对company字段的拷贝处理。最后在客户端调用，输出的结果为：  </p>
<blockquote>
<p>name:钱三<br>company:阿里-address-北京望京<br>name:赵四<br>company:百度-address-北京西二旗<br>name:孙五<br>company:腾讯-address-北京中关村</p>
</blockquote>
<h4 id="4-原型模式的使用场景"><a href="#4-原型模式的使用场景" class="headerlink" title="4.原型模式的使用场景"></a>4.原型模式的使用场景</h4><p>如果类的初始化需要耗费较多的资源，那么可以通过原型拷贝避免这些消耗。<br>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。<br>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以拷贝多个对象供调用者使用，即保护性拷贝。</p>
<h4 id="5-原型模式的优缺点"><a href="#5-原型模式的优缺点" class="headerlink" title="5.原型模式的优缺点"></a>5.原型模式的优缺点</h4><p><strong>优点</strong><br>原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要产生大量对象时。</p>
<p><strong>缺点</strong><br>直接在内存中拷贝，构造函数是不会执行的，这样就减少了约束，这既是优点也是缺点，需要在实际应用中去考量。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2020/04/19/moshijianzaozhe/</url>
    <content><![CDATA[<h3 id="设计模式-建造者模式"><a href="#设计模式-建造者模式" class="headerlink" title="设计模式-建造者模式"></a>设计模式-建造者模式</h3><h4 id="1-建造者模式简介"><a href="#1-建造者模式简介" class="headerlink" title="1.建造者模式简介"></a>1.建造者模式简介</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>建造者模式（builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<a id="more"></a>

<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>建造者模式（builder）是创建一个复杂对象的创建型模式，将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示分离开来。<br>例如我们要DIY一个台式机电脑，我们找到DIY商家，我们可以要求这台电脑的cpu或者主板或者其他的部件都是什么牌子的什么配置的，这些部件是我们可以根据我们的需求来变化的，但是这些部件组装成电脑的过程是一样的，我们不需要知道这些部件是怎样组装成电脑的，我们只需要提供部件的牌子和配置就可以了。对于这种情况我们就可以采用建造者模式，将部件和组装过程分离，使得构建过程和部件都可以自由拓展，两者之间的耦合也降到最低。</p>
<h4 id="2-建造者模式简单实现"><a href="#2-建造者模式简单实现" class="headerlink" title="2.建造者模式简单实现"></a>2.建造者模式简单实现</h4><p>这里我们就用DIY组装电脑的例子来实现一下建造者模式。</p>
<p><strong>创建产品类</strong><br>我要组装一台电脑，电脑被抽象为Computer类，它有三个部件:CPU 、主板和内存。并在里面提供了三个方法分别用来设置CPU 、主板和内存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mCpu;</span><br><span class="line">    <span class="keyword">private</span> String mMainboard;</span><br><span class="line">    <span class="keyword">private</span> String mRam;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmCpu</span><span class="params">(String mCpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mCpu = mCpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmMainboard</span><span class="params">(String mMainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mMainboard = mMainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setmRam</span><span class="params">(String mRam)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mRam = mRam;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建Builder类规范产品的组建</strong><br>商家组装电脑有一套组装方法的模版，就是一个抽象的Builder类,里面提供了安装CPU、主板和内存的方法，以及组装成电脑的create方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCpu</span><span class="params">(String cpu)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildMainboard</span><span class="params">(String mainboard)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildRam</span><span class="params">(String ram)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>商家实现了抽象的Builder类，MoonComputerBuilder类用于组装电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoonComputerBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> Computer();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        mComputer.setmCpu(cpu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMainboard</span><span class="params">(String mainboard)</span> </span>&#123;</span><br><span class="line">        mComputer.setmMainboard(mainboard);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRam</span><span class="params">(String ram)</span> </span>&#123;</span><br><span class="line">        mComputer.setmRam(ram);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用Dirextor指挥者类来统一组装过程</strong><br>商家的指挥者类用来规范组装电脑的流程规范，先安装主板，再安装CPU，最后安装内存并组装成电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Direcror</span> </span>&#123;</span><br><span class="line">    Builder mBuild=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Direcror</span><span class="params">(Builder build)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBuild=build;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">CreateComputer</span><span class="params">(String cpu,String mainboard,String ram)</span></span>&#123;</span><br><span class="line">        <span class="comment">//规范建造流程</span></span><br><span class="line">       <span class="keyword">this</span>.mBuild.buildMainboard(mainboard);</span><br><span class="line">       <span class="keyword">this</span>.mBuild.buildCpu(cpu);</span><br><span class="line">       <span class="keyword">this</span>.mBuild.buildRam(ram);</span><br><span class="line">       <span class="keyword">return</span> mBuild.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用指挥者类</strong><br>最后商家用指挥者类组装电脑。我们只需要提供我们想要的CPU，主板和内存就可以了，至于商家怎样组装的电脑我们无需知道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        Builder mBuilder=<span class="keyword">new</span> MoonComputerBuilder();</span><br><span class="line">        Direcror mDirecror=<span class="keyword">new</span> Direcror(mBuilder);</span><br><span class="line">        <span class="comment">//组装电脑</span></span><br><span class="line">        mDirecror.CreateComputer(<span class="string">"i7-6700"</span>,<span class="string">"华擎玩家至尊"</span>,<span class="string">"三星DDR4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用建造者模式的场景和优缺点"><a href="#3-使用建造者模式的场景和优缺点" class="headerlink" title="3.使用建造者模式的场景和优缺点"></a>3.使用建造者模式的场景和优缺点</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>相同的方法，不同的执行顺序，产生不同的事件结果时。<br>多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时.<br>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能.<br>创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>使用建造者模式可以使客户端不必知道产品内部组成的细节。<br>具体的建造者类之间是相互独立的，容易扩展。<br>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>产生多余的Build对象以及Dirextor类。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂</title>
    <url>/2020/04/19/moshichouxianggongchang/</url>
    <content><![CDATA[<h3 id="设计模式-抽象工厂模式"><a href="#设计模式-抽象工厂模式" class="headerlink" title="设计模式-抽象工厂模式"></a>设计模式-抽象工厂模式</h3><h4 id="1-抽象工厂模式定义"><a href="#1-抽象工厂模式定义" class="headerlink" title="1.抽象工厂模式定义"></a>1.抽象工厂模式定义</h4><p>抽象工厂模式可以说是是工厂方法模式的升级版，当需要创建的产品有多个产品线（产品族）时使用抽象工厂模式是比较好的选择。那什么是多个产品线呢？我们一直都是生产联想和惠普的电脑，但是电脑也有多个产品线：台式机、笔记本和平板等等，联想和惠普都在生产这些不同产品线上的电脑，使用工厂方法模式已经满足不了需求，这一篇文章我们就用抽象工厂模式来解决这一问题。</p>
<a id="more"></a>

<h5 id="抽象工厂模式定义"><a href="#抽象工厂模式定义" class="headerlink" title="抽象工厂模式定义"></a>抽象工厂模式定义</h5><p>为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类。</p>
<h4 id="2-抽象工厂模式简单实现"><a href="#2-抽象工厂模式简单实现" class="headerlink" title="2.抽象工厂模式简单实现"></a>2.抽象工厂模式简单实现</h4><p>联想和惠普生产的电脑分为了两个产品线，一个台式机，一个是笔记本。为了解决增加产品线的问题，我们用抽象工厂模式来进行实现。</p>
<p><strong>抽象产品</strong><br>首先定义抽象产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DesktopComputer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NotebookComputer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个抽象产品类分别为DesktopComputer和NotebookComputer ，用来定义两个产品线：台式机和笔记本。它们都定义了start方法，用来启动电脑。</p>
<p><strong>具体产品</strong><br>具体产品为联想和惠普旗下的台式机和笔记本，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoDesktopComputer</span> <span class="keyword">extends</span> <span class="title">DesktopComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想台式电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpDesktopComputer</span> <span class="keyword">extends</span> <span class="title">DesktopComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"惠普台式电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoNotebookComputer</span> <span class="keyword">extends</span> <span class="title">NotebookComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想笔记本电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpNotebookComputer</span> <span class="keyword">extends</span> <span class="title">NotebookComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"惠普笔记本电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象工厂</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DesktopComputer <span class="title">createDesktopComputer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> NotebookComputer <span class="title">createNotebookComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个方法，分别用来生产台式电脑和笔记本电脑。</p>
<p><strong>具体工厂</strong><br>定义联想和惠普工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DesktopComputer <span class="title">createDesktopComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoDesktopComputer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NotebookComputer <span class="title">createNotebookComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LenovoNotebookComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpFactory</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DesktopComputer <span class="title">createDesktopComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpDesktopComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NotebookComputer <span class="title">createNotebookComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpNotebookComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联想工厂和惠普工厂用来生产台式机和笔记本这两个不同产品线的电脑。</p>
<p><strong>客户端调用</strong><br>最后编写客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory lenocoFactory=<span class="keyword">new</span> LenovoFactory();</span><br><span class="line">        lenocoFactory.createDesktopComputer().start();</span><br><span class="line">        lenocoFactory.createNotebookComputer().start();</span><br><span class="line">        ComputerFactory hpFactory=<span class="keyword">new</span> HpFactory();</span><br><span class="line">        hpFactory.createDesktopComputer().start();</span><br><span class="line">        hpFactory.createNotebookComputer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别用LenovoFactory和HpFactory生产台式和笔记本电脑，并调用start方法启动它们。<br>运行结果为： </p>
<blockquote>
<p>联想台式电脑启动<br>联想笔记本电脑启动<br>惠普台式电脑启动<br>惠普笔记本电脑启动</p>
</blockquote>
<h4 id="3-抽象工厂模式的优缺点"><a href="#3-抽象工厂模式的优缺点" class="headerlink" title="3.抽象工厂模式的优缺点"></a>3.抽象工厂模式的优缺点</h4><p><strong>优点</strong><br>具体类的创建实例过程与客户端分离，客户端通过工厂的抽象接口操纵实例，客户端并不知道具体的实现是谁。</p>
<p><strong>缺点</strong><br>如果增加新的产品族则也需要修改抽象工厂和所有的具体工厂。</p>
<p><strong>抽象工厂模式的使用场景</strong> </p>
<ol>
<li>一个系统不依赖于产品线实例如何被创建、组合和表达的细节。  </li>
<li>系统中有多于一个的产品线，而每次只使用其中某一产品线。  </li>
<li>一个产品线（或是一组没有任何关系的对象）拥有相同的约束。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法</title>
    <url>/2020/04/19/moshigongchangfangfa/</url>
    <content><![CDATA[<h3 id="设计模式-工厂方法模式"><a href="#设计模式-工厂方法模式" class="headerlink" title="设计模式-工厂方法模式"></a>设计模式-工厂方法模式</h3><h4 id="1-工厂方法模式简介"><a href="#1-工厂方法模式简介" class="headerlink" title="1.工厂方法模式简介"></a>1.工厂方法模式简介</h4><p>工厂方法模式定义<br>定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p>
<a id="more"></a>

<h4 id="2-工厂方法模式简单实现"><a href="#2-工厂方法模式简单实现" class="headerlink" title="2.工厂方法模式简单实现"></a>2.工厂方法模式简单实现</h4><p><strong>创建抽象产品</strong><br>电脑产品类，它有一个start方法用于启动电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建具体产品</strong><br>具体的电脑产品分别是联想、惠普和华硕电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"惠普电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华硕电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建抽象工厂</strong><br>里面有一个createComputer方法，想生产哪个品牌的电脑就生产那个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>具体工厂</strong><br>广达代工厂是一个具体的工厂，他继承抽象工厂，通过反射来生产不同厂家的电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 广达代工厂 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GDComputerFactor</span> <span class="keyword">extends</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Computer&gt; <span class="function">T <span class="title">createComputer</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</span><br><span class="line">        Computer computer=<span class="keyword">null</span>;</span><br><span class="line">        String classname=clz.getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射来生产不同厂家的电脑</span></span><br><span class="line">            computer= (Computer) Class.forName(classname).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> </span>&#123;</span><br><span class="line">        ComputerFactory computerFactory = <span class="keyword">new</span> GDComputerFactor();</span><br><span class="line">        LenovoComputer mLenovoComputer=computerFactory.createComputer(LenovoComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mLenovoComputer.start();</span><br><span class="line">        HpComputer mHpComputer=computerFactory.createComputer(HpComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mHpComputer.start();</span><br><span class="line">        AsusComputer mAsusComputerr=computerFactory.createComputer(AsusComputer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        mAsusComputerr.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构很简单</p>
<h4 id="3-工厂方法与简单工厂"><a href="#3-工厂方法与简单工厂" class="headerlink" title="3.工厂方法与简单工厂"></a>3.工厂方法与简单工厂</h4><p>简单工厂模式我们都知道，在工厂类中包含了必要的逻辑判断，根据不同的条件来动态实例化相关的类，对客户端来说，去除了与具体产品的依赖，与此同时也会带来一个问题：如果我们去增加产品，比如我们要生产苹果电脑，那我们就需要在工厂类中在添加一个Case分支条件，这违背了开放封闭原则，我们对修改也开放了。而工厂方法模式就没有违背这个开放封闭原则，如果我们需要生产苹果电脑，并不需要去修改工厂类，直接创建产品就好了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂</title>
    <url>/2020/04/19/moshijiandangongchang/</url>
    <content><![CDATA[<h3 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>简单工厂模式属于创建型模式又叫做静态工厂方法模式，是由一个工厂对象决定创建出哪一种产品类的实例。</p>
<a id="more"></a>

<h4 id="1-简单工厂模式简单实现"><a href="#1-简单工厂模式简单实现" class="headerlink" title="1.简单工厂模式简单实现"></a>1.简单工厂模式简单实现</h4><p>这里我们用生产电脑来举例，假设有一个电脑的代工生产商，它目前已经可以代工生产联想电脑了，随着业务的拓展，这个代工生产商还要生产惠普和华硕的电脑，这样我们就需要用一个单独的类来专门生产电脑，这就用到了简单工厂模式。下面我们来实现简单工厂模式：</p>
<p><strong>创建抽象产品类</strong><br>我们创建一个电脑的抽象产品类，他有一个抽象方法用于启动电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**     * 产品的抽象方法，由具体的产品类去实现     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建具体产品类</strong><br>接着我们创建各个品牌的电脑，他们都继承了他们的父类Computer ，并实现了父类的start方法：</p>
<p>联想电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"联想电脑启动"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>惠普电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"惠普电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>华硕电脑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"华硕电脑启动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建工厂类</strong><br>接下来创建一个工厂类，它提供了一个静态方法createComputer用来生产电脑。你只需要传入你想生产的电脑的品牌，它就会实例化相应品牌的电脑对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Computer mComputer=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"lenovo"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> LenovoComputer();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hp"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> HpComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"asus"</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> AsusComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端调用工厂类</strong><br>客户端调用工厂类，传入“hp”生产出惠普电脑并调用该电脑对象的start方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">      ComputerFactory.createComputer(<span class="string">"hp"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用简单工厂模式的场景和优缺点"><a href="#使用简单工厂模式的场景和优缺点" class="headerlink" title="使用简单工厂模式的场景和优缺点"></a>使用简单工厂模式的场景和优缺点</h4><p><strong>使用场景</strong><br>工厂类负责创建的对象比较少<br>客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心<br>简单工厂模式优缺点</p>
<p><strong>优点</strong>:<br>使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性。</p>
<p><strong>缺点</strong>:<br>可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂，违背了开放封闭原则(ASD) 。 简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>简单工厂</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/04/18/moshidanli/</url>
    <content><![CDATA[<h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<a id="more"></a>

<h4 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();       </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> instance;       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p>
<h4 id="2-懒汉模式（线程不安全）"><a href="#2-懒汉模式（线程不安全）" class="headerlink" title="2. 懒汉模式（线程不安全）"></a>2. 懒汉模式（线程不安全）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p>
<h4 id="3-懒汉模式（线程安全）"><a href="#3-懒汉模式（线程安全）" class="headerlink" title="3. 懒汉模式（线程安全）"></a>3. 懒汉模式（线程安全）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;            </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;        </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p>
<h4 id="4-双重检查模式-（DCL）"><a href="#4-双重检查模式-（DCL）" class="headerlink" title="4. 双重检查模式 （DCL）"></a>4. 双重检查模式 （DCL）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;            </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;            </span><br><span class="line">                <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;                </span><br><span class="line">                        instance= <span class="keyword">new</span> Singleton();            </span><br><span class="line">                    &#125;           </span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;       <span class="keyword">return</span> singleton;       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字，不了解volatile关键字的可以查看Java多线程（三）volatile域这篇文章，在这篇文章我也提到了双重检查模式是正确使用volatile关键字的场景之一。<br>在这里使用volatile会或多或少的影响性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》一书建议用静态内部类单例模式来替代DCL。</p>
<h4 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5. 静态内部类单例模式"></a>5. 静态内部类单例模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;          <span class="string">'</span></span><br><span class="line"><span class="string">        return SingletonHolder.sInstance;      </span></span><br><span class="line"><span class="string">    &#125;      </span></span><br><span class="line"><span class="string">    private static class SingletonHolder &#123;          </span></span><br><span class="line"><span class="string">        private static final Singleton sInstance = new Singleton();      </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p>
<h4 id="6-枚举单例"><a href="#6-枚举单例" class="headerlink" title="6. 枚举单例"></a>6. 枚举单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;       </span><br><span class="line">    INSTANCE;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p>
<h4 id="7-使用容器实现单例模式"><a href="#7-使用容器实现单例模式" class="headerlink" title="7. 使用容器实现单例模式"></a>7. 使用容器实现单例模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123; 　　<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; 　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Objectinstance)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>到这里七中写法都介绍完了，至于选择用哪种形式的单例模式，取决于你的项目本身，是否是有复杂的并发环境，还是需要控制单例对象的资源消耗。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Android音视频基础</title>
    <url>/2020/04/13/androidmediabase/</url>
    <content><![CDATA[<h4 id="多媒体基础概念"><a href="#多媒体基础概念" class="headerlink" title="多媒体基础概念"></a>多媒体基础概念</h4><p><strong>视频分辨率</strong></p>
<p>标清、高清、720P…</p>
<p><strong>视频编码</strong></p>
<p>H.264、H.265…</p>
<a id="more"></a>

<p><strong>音频编码</strong></p>
<p>AAC、MP3、AC3…</p>
<p><strong>视频封装格式</strong></p>
<p>TS、RMVB 、MKV</p>
<p><strong>多媒体播放组件(Android)</strong></p>
<p>MediaPlayer、MediaCodec、OMX、Stagefright</p>
<h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p><strong>分辨率</strong></p>
<p>一帧视频的大小，表示长宽像素个数(720x576, 1280x720, 1920x1080 …)</p>
<p><strong>帧率</strong></p>
<p>每秒钟视频帧数(24/25/30/48/60 FPS)</p>
<p><strong>编码格式</strong></p>
<ul>
<li>编码：目的是压缩数据量，采用编码算法压缩冗余数据</li>
</ul>
<p>MPEG(MPEG-2, MPEG-4)</p>
<p>H.26X(H.263, H.264/AVC, H.265/HEVC)</p>
<ul>
<li>封装格式</li>
</ul>
<p>把编码后的音、视频数据以一定格式封装到一个容器</p>
<p>MKV/AVI/TS …</p>
<h4 id="Android平台播放器"><a href="#Android平台播放器" class="headerlink" title="Android平台播放器"></a>Android平台播放器</h4><p><strong>多媒体播放器基本组成</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-d5bca585f1baad41.webp" alt></p>
<p><strong>MediaPlayer状态周期</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C3480018-0ce2bc54d69a017b..webp" alt></p>
<p><strong>MediaPlayer简介</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-f9dafaecc77070b0.webp" alt></p>
<p><strong>什么是MediaCodec</strong></p>
<p>在Android中用于访问底层的媒体编解码器的类，是Android底层多媒体基础框架的一部分，通常与MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface和AudioTrack一起使用</p>
<p>•它本身并不是Codec，它是通过调用底层编解码组件具有Codec能力</p>
<p>•适用的Android版本</p>
<p>•Android 4.1以后的版本(API 16+)</p>
<p><strong>MediaCodec状态</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-9703a4ce9dc1363d.webp" alt></p>
<h4 id="常见音视频开发中的问题总结"><a href="#常见音视频开发中的问题总结" class="headerlink" title="常见音视频开发中的问题总结"></a>常见音视频开发中的问题总结</h4><p><strong>黑屏</strong></p>
<p>播放过程中黑屏</p>
<p>当播放器遇到不支持的视频格式，或者数据内容/格式异常，则会解码失败，从而导致无解码视频输出</p>
<p>定位：播放器播放时的报错日志，用合适的播放模式播放。数据异常，需要分析码流文件本身，送入解码器的帧数据不完整，H.264 的视频码流，缺失了 SPS，PPS 等必要的信息头，部分 Android 机型硬编出来的数据有额外的 NALU 头</p>
<p><strong>重新起播/进入时黑屏</strong></p>
<p>这时是由于没有渲染出帧，进入时黑屏，可以增加loading动画，直到渲染出首帧，loading动画消失，另外一种是应用退到后台，再回到应界播放界面时黑屏，可以在pause时，保存视频最后播放的帧，重新进来时，看到时之前退出时的画面，等播放器重新缓冲好后，开始画面连续播放</p>
<p><strong>卡顿/卡死</strong></p>
<p>卡顿分网络差，数据跟不上造成的卡顿，还有一种就是画面很慢的变化卡顿。卡死一般是卡住不动</p>
<p>分析：网络差的卡顿，可以在播放器加入数据代理，用于缓存足够多的数据。画面解码卡顿，可以降低清晰度或用其他播放模式播放。卡死，有时是调用某个方法后，一直得不到回调引起，如我们在VLC上发现，stop时，迟迟得不到onStopped状态。导致时间过长无相应ANR</p>
<p><strong>马赛克</strong></p>
<p>马赛克，这里指局部/半局部马赛克，常出现在很高画质视频，给播放器播放出现。如果画面偶尔出现马赛克，通常是数据错误造成的。注意区分</p>
<p>分析：视频帧中主要是一个一个宏块组成，频编码算法以宏块为单位，逐个宏块进行编码，组织成连续的视频码流。解码同样也是。画质越高，压缩越厉害</p>
<p><strong>H.264 有四种画质级别</strong></p>
<p>•Baseline profile</p>
<p>•Extended profile</p>
<p>•Main profile</p>
<p>•High profile</p>
<p>画质越高，对解码能力要求也越高</p>
<p><strong>花屏/绿屏</strong></p>
<p>播放画面出现图像紊乱，像被刮花了一样。大面积的异常颜色的方块图，绿屏或其他颜色现象</p>
<p>丢失参考帧导致， I 帧由于是帧内压缩，因此可以独立解码播放，而 B 帧，一旦丢失了 I 帧或者后面的 P 帧，则会解码失败，而 P 帧一旦丢失了前面的 I/B/P 帧，也会导致解码失败。不要丢弃编码后、解码前的视频帧数据，实在要丢，一次丢一整个 GOP（一个I帧到下一个I帧中间的数据）</p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-75b87ef440b0afbf.webp" alt></p>
<p><strong>音画不同步</strong></p>
<p>遇到log中大量打印“Past duration XXX too large”且伴有frame drop相关信息的打印</p>
<p>分析方法：将输入视频包的时间戳信息打印出来，发现一些视频帧未设置DTS/PTS，这些视频帧携带的时间戳都是默认值为AV_NOPTS_VALUE，代码中对该值的定义如下</p>
<p>#define AV_NOPTS_VALUE ((int64_t)UINT64_C(0x8000000000000000))</p>
<p>而这些帧在编码输出之前会被Drop掉，为了满足设定的帧率，后面的有效时间戳的帧会提前输出，导致视频提前而音频滞后</p>
<p>解决方法：由于我们为这些未设置时间戳的输入帧填充有效时间戳不是一件很容易的</p>
<h4 id="播放方案"><a href="#播放方案" class="headerlink" title="播放方案"></a>播放方案</h4><p><strong>1、ExoPlayer</strong></p>
<p>ExoPlayer 是一个Google开源项目，它不属于Android framework，独立于Android SDK</p>
<p>Android支持通过MediaExtractor和MediaCodec实现自定义播放。ExoPlayer介于MediaPlayer和自定义播放器之间的播放器，比MediaPlayer更强的扩展能力</p>
<p>ExoPlayer可以通过进一步扩展来处理多种媒体格式</p>
<p>由于它是内置于app中，所以可以随着app进行升级事(需要结合输入视频是否采用B帧等)，因此在输入输出帧率相同时，我们可以将这些携带无效时间戳的帧正常送至编码器编码并输出，而不是丢弃</p>
<p><strong>ExoPlayer优点</strong></p>
<ul>
<li><p>支持 Dynamic Adaptive Streaming over HTTP (DASH) 和SmoothStreaming，更多支持请参阅支持的格式）详细信息页面。</p>
</li>
<li><p>支持高级 HLS (HTTP Live Streaming)功能，如正确处理 #EXT-X-DISCONTINUITY的标签</p>
</li>
</ul>
<p><strong>ExoPlayer缺点</strong></p>
<ul>
<li>ExoPlayer的音频和视频组件依赖Android的 MediaCodec接口，该接口发布于Android4.1（API 等级16）。因此它不能工作于之前的Android版本</li>
</ul>
<p><strong>使用</strong></p>
<p>YouTube(Android平台客户端)使用ExoPlayer</p>
<p><a href="https://github.com/google/ExoPlayer" target="_blank" rel="noopener">https://github.com/google/ExoPlayer</a></p>
<p><strong>2、Ijkplayer</strong></p>
<p>是基于ffmpeg开源的轻量级视频播放器，跨平台</p>
<p>封装ffplay、MediaPlayer，MediaCodec，ExoPlayer</p>
<p>支持几乎所有视频封装格式</p>
<p>音频AudioTrack，OpenSL ES</p>
<p><strong>Ijkplayer</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-971a8f0b62873958.webp" alt></p>
<p><strong>使用</strong></p>
<p>B站和主流直播软件都在使用</p>
<p><a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">https://github.com/Bilibili/ijkplayer</a></p>
<p><strong>3、VLC</strong></p>
<p>VLC(Video Lan Client)是一个完整的多媒体框架，最大特点是可以根据需要动态加载许多插件模块，支持视频传输，封装和编码格式。框架核心是利用程序将各模块链接起来。对输入媒体数据，经过各模块处理后输出</p>
<ul>
<li><p>可在所有平台运行：Windows, Linux, Mac OS X, Unix, iOS, Android ..</p>
</li>
<li><p>支持Dolby，及多音轨，多字幕</p>
</li>
<li><p>内置MediaCodec，ffmpeg，有自己专门的Demuxing，和自己接入OpenMax组件</p>
</li>
</ul>
<p><strong>VLC</strong></p>
<p><img src="/2020/04/13/androidmediabase/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidmediabase%5C7344457-8642c86b720aa2fe.webp" alt></p>
<p><strong>使用</strong></p>
<p>小米Android ROM集成VLC作为播放器</p>
<p><a href="http://www.videolan.org/vlc/" target="_blank" rel="noopener">http://www.videolan.org/vlc/</a></p>
<p>git://git.videolan.org/vlc.git</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频开发基础</title>
    <url>/2020/04/13/videobase/</url>
    <content><![CDATA[<h4 id="一-视频基础概念"><a href="#一-视频基础概念" class="headerlink" title="一. 视频基础概念"></a>一. 视频基础概念</h4><h5 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧(Frame)"></a>帧(Frame)</h5><p>简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。</p>
<a id="more"></a>

<h5 id="帧数-Frames"><a href="#帧数-Frames" class="headerlink" title="帧数(Frames)"></a>帧数(Frames)</h5><p>帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量</p>
<h5 id="帧率-Frame-Rate"><a href="#帧率-Frame-Rate" class="headerlink" title="帧率(Frame Rate)"></a>帧率(Frame Rate)</h5><p>帧率(Frame rate) = 帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)。</p>
<h5 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h5><p>屏幕每秒画面被刷新的次数，分为垂直刷新率和水平刷新率，一般我们提到的都是指垂直刷新率，以赫兹(Hz)为单位，刷新率越高，图像就越稳定，图像显示就越自然清晰。</p>
<p>目前， 大多数显示器根据其设定按 30Hz、 60Hz、 120Hz 或者 144Hz 的频率进行刷新。 而其中最常见的刷新频率是 60 Hz。 这样做是为了继承以前电视机刷新频率为 60Hz 的设定。</p>
<h5 id="帧率关键值"><a href="#帧率关键值" class="headerlink" title="帧率关键值"></a>帧率关键值</h5><ul>
<li>10~12 FPS：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约10至12帧的时候，就会认为是连贯的，此现象称之为视觉暂留。</li>
<li>24 FPS：一般电影的拍摄及播放帧数是每秒24帧。</li>
<li>60 FPS：这个帧率对人眼识别来说已经具备较高的平滑度。</li>
<li>85 FPS：人类大脑处理视频的极限，人眼无法分辨更高频率的差异。</li>
</ul>
<h5 id="60FPS"><a href="#60FPS" class="headerlink" title="60FPS"></a>60FPS</h5><p>在做页面性能优化时，常用60FPS作为一个基准，所以需要尽量让每一帧的渲染控制在16ms内，这样才能达到一秒60帧的流畅度。</p>
<h5 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h5><p>视频、图片的画面大小或尺寸。</p>
<h5 id="码率-比特率"><a href="#码率-比特率" class="headerlink" title="码率/比特率"></a>码率/比特率</h5><p>单位时间播放连续的媒体如压缩后的音频或视频的比特数量。常用单位“比特每秒”，缩写是“bit/s”。比特率越高，带宽消耗得越多。</p>
<h4 id="二-CPU-amp-GPU"><a href="#二-CPU-amp-GPU" class="headerlink" title="二. CPU &amp; GPU"></a>二. CPU &amp; GPU</h4><p><strong>CPU</strong>：中央处理器(英文全名：Central Processing Unit)，包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。</p>
<p><strong>GPU</strong>：图形处理器（英语全名：Graphics Processing Unit），专为执行复杂的数学和几何计算而设计的，拥有2D或3D图形加速功能。</p>
<p>GPU相比于CPU，更强大的2D、3D图形计算能力，可以让CPU从图形处理的任务中解放出来，执行其他更多的系统任务，这样可以大大提高计算机的整体性能。</p>
<h5 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h5><p>硬件加速（Hardware acceleration）就是利用硬件模块来替代软件算法以充分利用硬件所固有的快速特性。硬件加速通常比软件算法的效率要高。</p>
<p>将2D、3D图形计算相关工作交给GPU处理，从而释放CPU的压力，也是属于硬件加速的一种。</p>
<h5 id="硬解和软解"><a href="#硬解和软解" class="headerlink" title="硬解和软解"></a>硬解和软解</h5><p>硬解和上面的硬件加速对应，即使用硬件模块来解析视频、音频文件等，而软解即是用CPU去计算解析。</p>
<h4 id="三-视频封装格式-Container-format"><a href="#三-视频封装格式-Container-format" class="headerlink" title="三. 视频封装格式(Container format)"></a>三. 视频封装格式(Container format)</h4><table>
<thead>
<tr>
<th>格式</th>
<th>全名</th>
<th>开发商</th>
<th>初版年限</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>MP4</td>
<td>MP4</td>
<td>Moving Picture Experts Group，即 MPEG(动态图像专家组)</td>
<td>1998</td>
<td>常用有损压缩格式，通用性强</td>
</tr>
<tr>
<td>AVI</td>
<td>Audio Video Interleaved(音频视频交错格式)</td>
<td>微软</td>
<td>1992</td>
<td>体积大算法简单</td>
</tr>
<tr>
<td>MOV</td>
<td>QuickTime 影片格式</td>
<td>Apple</td>
<td>1991</td>
<td>苹果专属格式对很多其他的播放器支持不是很友好</td>
</tr>
<tr>
<td>WMV</td>
<td>Windows Media Video</td>
<td>微软</td>
<td>2003</td>
<td>微软的专业视频格式，兼容性并不是很好</td>
</tr>
<tr>
<td>FLV</td>
<td>Adobe Flash 网络流媒体格式</td>
<td>Adobe</td>
<td>2002</td>
<td>被淘汰的早期网络视频格式</td>
</tr>
<tr>
<td>MKV</td>
<td>Matroska 多媒体容器</td>
<td>Matroska.org</td>
<td>2002</td>
<td>最有包容性的视频格式，能容纳无限量、多种不同类型编码的视频、音频及字幕流</td>
</tr>
<tr>
<td>WebM</td>
<td>WebM</td>
<td>Google</td>
<td>2010</td>
<td>谷歌推出的 HTML5 标准的网络视频标准,以MKV容器格式为基础开发</td>
</tr>
<tr>
<td>RMVB</td>
<td>RMVB</td>
<td>Real Networks</td>
<td>1997</td>
<td>根据不同的网络传输速率，而制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放，具有体积小，画质不错的优点。已过时。</td>
</tr>
</tbody></table>
<h4 id="四-视频编码格式-Codec"><a href="#四-视频编码格式-Codec" class="headerlink" title="四. 视频编码格式(Codec)"></a>四. 视频编码格式(Codec)</h4><h5 id="1-MPEG：-Moving-Picture-Experts-Group-ISO旗下的组织"><a href="#1-MPEG：-Moving-Picture-Experts-Group-ISO旗下的组织" class="headerlink" title="1. MPEG：(Moving Picture Experts Group, ISO旗下的组织)"></a>1. MPEG：(Moving Picture Experts Group, ISO旗下的组织)</h5><p>MPEG是Moving Picture Experts Group的简称。这个名字本来的含义是指一个研究视频和音频编码标准的“动态图像专家组”组织，成立于1988年，致力开发视频、音频的压缩编码技术。</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>MPEG - 1</td>
<td>VCD</td>
</tr>
<tr>
<td>MPEG - 2</td>
<td>DVD、数字有线电视信号</td>
</tr>
<tr>
<td>MPEG - 4(第二部分)</td>
<td>视频电话、网络传输、广播和媒体存储</td>
</tr>
</tbody></table>
<h5 id="2-H-26X-ITU-T-VCEG-Visual-Coding-Experts-Group，国际电联旗下的标准化组织-制定"><a href="#2-H-26X-ITU-T-VCEG-Visual-Coding-Experts-Group，国际电联旗下的标准化组织-制定" class="headerlink" title="2. H.26X : ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)制定"></a>2. H.26X : ITU-T VCEG(Visual Coding Experts Group，国际电联旗下的标准化组织)制定</h5><table>
<thead>
<tr>
<th>版本</th>
<th>用于</th>
</tr>
</thead>
<tbody><tr>
<td>H.261</td>
<td>老的视频会议和视频电话产品</td>
</tr>
<tr>
<td>H.262</td>
<td>DVD、数字有线电视信号(与MPEG共同制定，与MPEG-2完全一致)</td>
</tr>
<tr>
<td>H.263</td>
<td>视频会议、视频电话和网络视频</td>
</tr>
<tr>
<td>H.264</td>
<td>高精度视频的录制、压缩和发布格式(与MPEG-4第十部分完全一致)，当前主流</td>
</tr>
<tr>
<td>H.265</td>
<td>H.264的两倍之压缩率，可支持4K分辨率甚至到超高画质电视，最高分辨率可达到8192×4320（8K分辨率）</td>
</tr>
</tbody></table>
<h5 id="3-H-264"><a href="#3-H-264" class="headerlink" title="3. H.264"></a>3. H.264</h5><p>当前主流的编码格式是H.264，这是由ITU-T VCEG和MPEG共同制定的标准，MPEG - 4第十部分内容也是H.264。</p>
<h5 id="视频封装格式-amp-视频编码格式"><a href="#视频封装格式-amp-视频编码格式" class="headerlink" title="视频封装格式 &amp; 视频编码格式"></a>视频封装格式 &amp; 视频编码格式</h5><p>封装格式是提供了一个容器，用于存放视频、音频以及其他配置信息，而编码格式是指对视频画面内容进行压缩的一种标准。</p>
<h4 id="五-音频格式"><a href="#五-音频格式" class="headerlink" title="五. 音频格式"></a>五. 音频格式</h4><ul>
<li><strong>WAV</strong>：因其文件扩展名为wav，微软和IBM联合开发的标准，数据本身的格式为PCM或压缩型，属于无损格式。</li>
<li><strong>MP3</strong> : MP3是一种音频压缩技术，其全称是动态影像专家压缩标准音频层面3（Moving Picture Experts Group Audio Layer III），简称为MP3。压缩比4:1~10:1之间。</li>
<li><strong>AAC</strong>：Advanced Audio Coding， 出现于1997年，由Fraunhofer IIS、杜比实验室、AT&amp;T、Sony、Nokia等公司共同开发。AAC压缩比通常为18：1。相比MP3，采用更高效的编码算法，音质更佳，文件更小。</li>
<li><strong>Opus</strong>：Opus格式是一个开放格式，使用上没有任何专利或限制，比MP3、AAC、HE-AAC等常见格式，有更低的延迟和更好的声音压缩率。2012年7月2日，Opus被IETF批准用于标准化。</li>
</ul>
<h4 id="六-H-264编码介绍"><a href="#六-H-264编码介绍" class="headerlink" title="六. H.264编码介绍"></a>六. H.264编码介绍</h4><h5 id="IPB帧"><a href="#IPB帧" class="headerlink" title="IPB帧"></a>IPB帧</h5><ul>
<li>I帧：帧内编码帧(intra picture)，采用帧内压缩去掉空间冗余信息。</li>
<li>P帧：前向预测编码帧(predictive-frame)，通过将图像序列中前面已经编码帧的时间冗余信息来压缩传输数据量的编码图像。参考前面的I帧或者P帧。</li>
<li>B帧：双向预测内插编码帧(bi-directional interpolated prediction frame)，既考虑源图像序列前面的已编码帧，又顾及源图像序列后面的已编码帧之间的冗余信息，来压缩传输数据量的编码图像，也称为双向编码帧。参考前面一个的I帧或者P帧及其后面的一个P帧。</li>
</ul>
<h5 id="PTS和DTS"><a href="#PTS和DTS" class="headerlink" title="PTS和DTS"></a>PTS和DTS</h5><ul>
<li>DTS(Decoding Time Stamp)是标识读入内存中bit流在什么时候开始送入解码器中进行解码。也就是解码顺序的时间戳。</li>
<li>PTS(Presentation Time Stamp)用于度量解码后的视频帧什么时候被显示出来。在没有B帧的情况下，DTS和PTS的输出顺序是一样的，一旦存在B帧，PTS和DTS则会不同。也就是显示顺序的时间戳。</li>
</ul>
<h5 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h5><p>即Group of picture(图像组)，指两个I帧之间的距离，Reference(参考周期)指两个P帧之间的距离。</p>
<p>一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。所以在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p>
<p>简而言之：</p>
<ul>
<li>字节大小：I &gt; P &gt; B</li>
<li>解码顺序：I -&gt; P -&gt; B</li>
</ul>
<p><img src="/2020/04/13/videobase/780b83e181.webp" alt></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>资源分享</title>
    <url>/2020/04/13/pdfshare/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>收录一些pdf资源</p>
<a id="more"></a>

<p>当然还是建议大家购买书籍学习</p>
<p><strong>1.深入理解Android网络编程-技术详解与最佳实践</strong></p>
<p><a href="http://pan.baidu.com/s/1dDVZR7F" target="_blank" rel="noopener">http://pan.baidu.com/s/1dDVZR7F</a></p>
<p><strong>2.Android 高手进阶教程</strong></p>
<p><a href="http://pan.baidu.com/s/1cskagI" target="_blank" rel="noopener">http://pan.baidu.com/s/1cskagI</a></p>
<p><strong>3.Android内核剖析-柯元丹</strong></p>
<p><a href="http://pan.baidu.com/s/1qYL3Fbe" target="_blank" rel="noopener">http://pan.baidu.com/s/1qYL3Fbe</a></p>
<p><strong>4.第一行代码</strong></p>
<p><a href="http://pan.baidu.com/s/1miKpVAg" target="_blank" rel="noopener">http://pan.baidu.com/s/1miKpVAg</a></p>
<p><strong>5.App研发录—架构设计,Crash分析和竞品技术分析</strong></p>
<p><a href="http://pan.baidu.com/s/1dFgiiD7" target="_blank" rel="noopener">http://pan.baidu.com/s/1dFgiiD7</a></p>
<p><strong>6.Android开发艺术探索</strong></p>
<p><a href="http://pan.baidu.com/s/1bpMkovd" target="_blank" rel="noopener">http://pan.baidu.com/s/1bpMkovd</a></p>
<p><strong>7.Java从入门到精通</strong></p>
<p><a href="https://pan.baidu.com/s/1kU8lmXx" target="_blank" rel="noopener">https://pan.baidu.com/s/1kU8lmXx</a></p>
<p><strong>8.Java数据结构和算法</strong></p>
<p><a href="https://pan.baidu.com/s/1dFEJwx7" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFEJwx7</a></p>
<p><strong>9.计算机网络</strong></p>
<p><a href="https://pan.baidu.com/s/1slVWcHn" target="_blank" rel="noopener">https://pan.baidu.com/s/1slVWcHn</a></p>
<p><strong>10.深入理解Android热修复</strong></p>
<p><a href="https://pan.baidu.com/s/1dFAbCtF" target="_blank" rel="noopener">https://pan.baidu.com/s/1dFAbCtF</a></p>
<p><strong>11.think in java</strong></p>
<p><a href="https://pan.baidu.com/s/1kVQhLyB" target="_blank" rel="noopener">https://pan.baidu.com/s/1kVQhLyB</a></p>
<p><strong>12.Python 3 极简教程</strong></p>
<p><a href="https://pan.baidu.com/s/1geX5Kdl" target="_blank" rel="noopener">https://pan.baidu.com/s/1geX5Kdl</a></p>
<p><strong>13.阿里巴巴Java开发手册(终极版)</strong></p>
<p><a href="https://pan.baidu.com/s/1nvyyk6t" target="_blank" rel="noopener">https://pan.baidu.com/s/1nvyyk6t</a></p>
<p><strong>14.C语言从入门到精通</strong></p>
<p><a href="https://pan.baidu.com/s/1bzSt0i" target="_blank" rel="noopener">https://pan.baidu.com/s/1bzSt0i</a></p>
<p><strong>15.Android多媒体开发高级编程</strong></p>
<p><a href="https://pan.baidu.com/s/1Sz5C-RKv2kJPALrugQzM0Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1Sz5C-RKv2kJPALrugQzM0Q</a> </p>
<p>提取码: 5ssv</p>
<p><strong>15.OpenGl ES</strong></p>
<p><a href="https://pan.baidu.com/s/14ErAY7PSlJk7YTPKXAJXTQ" target="_blank" rel="noopener">https://pan.baidu.com/s/14ErAY7PSlJk7YTPKXAJXTQ</a> </p>
<p>提取码: is1b</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>PDF分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ARouter</title>
    <url>/2020/04/10/androidarouter/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>目前组件化开发已经很成熟， 今天来说一下组件化开发框架ARouter</p>
<a id="more"></a>

<h4 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h4><p><a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">https://github.com/alibaba/ARouter</a></p>
<p>项目中的中文文档已经非常的详尽了</p>
<h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4><ol>
<li><p>添加依赖和配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">AROUTER_MODULE_NAME:</span> project.getName()]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 替换成最新版本, 需要注意的是api</span></span><br><span class="line">    <span class="comment">// 要与compiler匹配使用，均使用最新版可以保证兼容</span></span><br><span class="line">    compile <span class="string">'com.alibaba:arouter-api:x.x.x'</span></span><br><span class="line">    annotationProcessor <span class="string">'com.alibaba:arouter-compiler:x.x.x'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'</span></span><br><span class="line"><span class="comment">// Kotlin配置参考文末'其他#5'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在支持路由的页面上添加注解(必选)</span></span><br><span class="line"><span class="comment">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourActivity</span> <span class="title">extend</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化SDK</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDebug()) &#123;           <span class="comment">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span></span><br><span class="line">    ARouter.openLog();     <span class="comment">// 打印日志</span></span><br><span class="line">    ARouter.openDebug();   <span class="comment">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span></span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication); <span class="comment">// 尽可能早，推荐在Application中初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发起路由操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/activity"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 跳转并携带参数</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/1"</span>)</span><br><span class="line">            .withLong(<span class="string">"key1"</span>, <span class="number">666L</span>)</span><br><span class="line">            .withString(<span class="string">"key3"</span>, <span class="string">"888"</span>)</span><br><span class="line">            .withObject(<span class="string">"key4"</span>, <span class="keyword">new</span> Test(<span class="string">"Jack"</span>, <span class="string">"Rose"</span>))</span><br><span class="line">            .navigation();</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加混淆规则(如果使用了Proguard)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep public class com.alibaba.android.arouter.routes.**&#123;*;&#125;</span><br><span class="line">-keep public class com.alibaba.android.arouter.facade.**&#123;*;&#125;</span><br><span class="line">-keep class * implements com.alibaba.android.arouter.facade.template.ISyringe&#123;*;&#125;</span><br><span class="line"></span><br><span class="line"># 如果使用了 byType 的方式获取 Service，需添加下面规则，保护接口</span><br><span class="line">-keep interface * implements com.alibaba.android.arouter.facade.template.IProvider</span><br><span class="line"></span><br><span class="line"># 如果使用了 单类注入，即不定义接口实现 IProvider，需添加下面规则，保护实现</span><br><span class="line"># -keep class * implements com.alibaba.android.arouter.facade.template.IProvider</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Gradle 插件实现路由表的自动加载 (可选)</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.alibaba.arouter'</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">"com.alibaba:arouter-register:?"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可选使用，通过 ARouter 提供的注册插件进行路由表的自动加载， 默认通过扫描 dex 的方式 进行加载通过 gradle 插件进行自动注册可以缩短初始化时间解决应用加固导致无法直接访问 dex 文件，初始化失败的问题，需要注意的是，该插件必须搭配 api 1.3.0 以上版本使用！</p>
</li>
<li><p>使用 IDE 插件导航到目标类 (可选)</p>
<p>在 Android Studio 插件市场中搜索 <code>ARouter Helper</code>, 或者直接下载文档上方 <code>最新版本</code> 中列出的 <code>arouter-idea-plugin</code> zip 安装包手动安装，安装后 插件无任何设置，可以在跳转代码的行首找到一个图标, 点击该图标，即可跳转到标识了代码中路径的目标类</p>
</li>
</ol>
<h4 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h4><ol>
<li><p>通过URL跳转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个Activity用于监听Scheme事件,之后直接把url传递给ARouter即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SchemeFilterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    Uri uri = getIntent().getData();</span><br><span class="line">    ARouter.getInstance().build(uri).navigation();</span><br><span class="line">    finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AndroidManifest.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".activity.SchemeFilterActivity"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Scheme --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:host</span>=<span class="string">"m.aliyun.com"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scheme</span>=<span class="string">"arouter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解析参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span></span><br><span class="line"><span class="comment">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Activity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过name来映射URL中的不同参数</span></span><br><span class="line">    <span class="meta">@Autowired</span>(name = <span class="string">"girl"</span>) </span><br><span class="line">    <span class="keyword">boolean</span> boy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持解析自定义对象，URL中使用json传递</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TestObj obj;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 withObject 传递 List 和 Map 的实现了</span></span><br><span class="line">    <span class="comment">// Serializable 接口的实现类(ArrayList/HashMap)</span></span><br><span class="line">    <span class="comment">// 的时候，接收该对象的地方不能标注具体的实现类类型</span></span><br><span class="line">    <span class="comment">// 应仅标注为 List 或 Map，否则会影响序列化中类型</span></span><br><span class="line">    <span class="comment">// 的判断, 其他类似情况需要同样处理        </span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;TestObj&gt; list;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Map&lt;String, List&lt;TestObj&gt;&gt; map;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    ARouter.getInstance().inject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ARouter会自动对字段进行赋值，无需主动获取</span></span><br><span class="line">    Log.d(<span class="string">"param"</span>, name + age + boy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/yourservicegroupname/json"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonServiceImpl</span> <span class="keyword">implements</span> <span class="title">SerializationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">json2Object</span><span class="params">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(text, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">object2Json</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>声明拦截器(拦截跳转过程，面向切面编程)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span></span><br><span class="line"><span class="comment">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span></span><br><span class="line"><span class="meta">@Interceptor</span>(priority = <span class="number">8</span>, name = <span class="string">"测试用拦截器"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterceptor</span> <span class="keyword">implements</span> <span class="title">IInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    callback.onContinue(postcard);  <span class="comment">// 处理完成，交还控制权</span></span><br><span class="line">    <span class="comment">// callback.onInterrupt(new RuntimeException("我觉得有点异常"));      // 觉得有问题，中断路由流程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上两种至少需要调用其中一种，否则不会继续路由</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理跳转结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用两个参数的navigation方法，可以获取单次跳转的结果</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/test/1"</span>).navigation(<span class="keyword">this</span>, <span class="keyword">new</span> NavigationCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFound</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义全局降级策略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/xxx/xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DegradeServiceImpl</span> <span class="keyword">implements</span> <span class="title">DegradeService</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Context context, Postcard postcard)</span> </span>&#123;    <span class="comment">// do something.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为目标页面声明更多信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们经常需要在目标页面中配置一些属性，比方说"是否需要登陆"之类的</span></span><br><span class="line"><span class="comment">// 可以通过 Route 注解中的 extras 属性进行扩展，这个属性是一个 int值，换句话说，单个int有4字节，也就是32位，可以配置32个开关</span></span><br><span class="line"><span class="comment">// 剩下的可以自行发挥，通过字节操作可以标识32个开关，通过开关标记目标页面的一些属性，在拦截器中可以拿到这个标记进行业务逻辑判断</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/activity"</span>, extras = Consts.XXXX)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过依赖注入解耦:服务管理(一) 暴露服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明接口,其他组件通过接口来调用服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/yourservicegroupname/hello"</span>, name = <span class="string">"测试服务"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过依赖注入解耦:服务管理(二) 发现服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>(name = <span class="string">"/yourservicegroupname/hello"</span>)</span><br><span class="line">    HelloService helloService2;</span><br><span class="line"></span><br><span class="line">    HelloService helloService3;</span><br><span class="line"></span><br><span class="line">    HelloService helloService4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ARouter.getInstance().inject(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</span></span><br><span class="line">    <span class="comment">// Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</span></span><br><span class="line">    helloService.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">    helloService2.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</span></span><br><span class="line">    helloService3 = ARouter.getInstance().navigation(HelloService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    helloService4 = (HelloService) ARouter.getInstance().build(<span class="string">"/yourservicegroupname/hello"</span>).navigation();</span><br><span class="line">    helloService3.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">    helloService4.sayHello(<span class="string">"Vergil"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>预处理服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 PretreatmentService 接口，并加上一个Path内容任意的注解即可</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/xxx/xxx"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PretreatmentServiceImpl</span> <span class="keyword">implements</span> <span class="title">PretreatmentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPretreatment</span><span class="params">(Context context, Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跳转前预处理，如果需要自行处理跳转，该方法返回 false 即可</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h4><ol>
<li><p>初始化中的其他设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ARouter.openLog(); <span class="comment">// 开启日志</span></span><br><span class="line">ARouter.openDebug(); <span class="comment">// 使用InstantRun的时候，需要打开该开关，上线之后关闭，否则有安全风险</span></span><br><span class="line">ARouter.printStackTrace(); <span class="comment">// 打印日志的时候打印线程堆栈</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>详细的API说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建标准的路由请求</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，并指定分组</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>, <span class="string">"ap"</span>).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，通过Uri直接解析</span></span><br><span class="line">Uri uri;</span><br><span class="line">ARouter.getInstance().build(uri).navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建标准的路由请求，startActivityForResult</span></span><br><span class="line"><span class="comment">// navigation的第一个参数必须是Activity，第二个参数则是RequestCode</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>, <span class="string">"ap"</span>).navigation(<span class="keyword">this</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接传递Bundle</span></span><br><span class="line">Bundle params = <span class="keyword">new</span> Bundle();</span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/home/main"</span>)</span><br><span class="line">    .with(params)</span><br><span class="line">    .navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定Flag</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/home/main"</span>)</span><br><span class="line">    .withFlags();</span><br><span class="line">    .navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Fragment</span></span><br><span class="line">Fragment fragment = (Fragment) ARouter.getInstance().build(<span class="string">"/test/fragment"</span>).navigation();</span><br><span class="line">                    </span><br><span class="line"><span class="comment">// 对象传递</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .withObject(<span class="string">"key"</span>, <span class="keyword">new</span> TestObj(<span class="string">"Jack"</span>, <span class="string">"Rose"</span>))</span><br><span class="line">    .navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 觉得接口不够多，可以直接拿出Bundle赋值</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">        .build(<span class="string">"/home/main"</span>)</span><br><span class="line">        .getExtra();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转场动画(常规方式)</span></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)</span><br><span class="line">    .navigation(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转场动画(API16+)</span></span><br><span class="line">ActivityOptionsCompat compat = ActivityOptionsCompat.</span><br><span class="line">    makeScaleUpAnimation(v, v.getWidth() / <span class="number">2</span>, v.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前Activity</span></span><br><span class="line"></span><br><span class="line">ARouter.getInstance()</span><br><span class="line">    .build(<span class="string">"/test/activity2"</span>)</span><br><span class="line">    .withOptionsCompat(compat)</span><br><span class="line">    .navigation();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 使用绿色通道(跳过所有的拦截器)</span></span><br><span class="line">ARouter.getInstance().build(<span class="string">"/home/main"</span>).greenChannel().navigation();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自己的日志工具打印日志</span></span><br><span class="line">ARouter.setLogger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自己提供的线程池</span></span><br><span class="line">ARouter.setExecutor();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取原始的URI</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String uriStr = getIntent().getStringExtra(ARouter.RAW_URI);</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写跳转URL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现PathReplaceService接口，并加上一个Path内容任意的注解即可</span></span><br><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/xxx/xxx"</span>) <span class="comment">// 必须标明注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathReplaceServiceImpl</span> <span class="keyword">implements</span> <span class="title">PathReplaceService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * For normal path.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> path raw path</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">String <span class="title">forString</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path;    <span class="comment">// 按照一定的规则处理之后返回处理后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * For uri type.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uri raw uri</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function">Uri <span class="title">forUri</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url;    <span class="comment">// 按照一定的规则处理之后返回处理后的结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成路由文档</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新 build.gradle, 添加参数 AROUTER_GENERATE_DOC = enable</span></span><br><span class="line"><span class="comment">// 生成的文档路径 : build/generated/source/apt/(debug or release)/com/alibaba/android/arouter/docs/arouter-map-of-$&#123;moduleName&#125;.json</span></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        javaCompileOptions &#123;</span><br><span class="line">            annotationProcessorOptions &#123;</span><br><span class="line">                arguments = [<span class="string">AROUTER_MODULE_NAME:</span> project.getName(), <span class="string">AROUTER_GENERATE_DOC:</span> <span class="string">"enable"</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li><p>路由中的分组概念</p>
<ul>
<li>SDK中针对所有的路径(/test/1 /test/2)进行分组，分组只有在分组中的某一个路径第一次被访问的时候，该分组才会被初始化</li>
<li>可以通过 @Route 注解主动指定分组，否则使用路径中第一段字符串(/*/)作为分组</li>
<li>注意：一旦主动指定分组之后，应用内路由需要使用 ARouter.getInstance().build(path, group) 进行跳转，手动指定分组，否则无法找到</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/test/1"</span>, group = <span class="string">"app"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>拦截器和服务的异同</p>
<ul>
<li>拦截器和服务所需要实现的接口不同，但是结构类似，都存在 init(Context context) 方法，但是两者的调用时机不同</li>
<li>拦截器因为其特殊性，会被任何一次路由所触发，拦截器会在ARouter初始化的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。</li>
<li>服务没有该限制，某一服务可能在App整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作</li>
</ul>
</li>
<li><p>旧版本gradle插件的配置方式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.neenbedankt.android-apt'</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">    classpath <span class="string">'com.neenbedankt.gradle.plugins:android-apt:1.4'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">    AROUTER_MODULE_NAME project.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'com.alibaba:arouter-api:x.x.x'</span></span><br><span class="line">    apt <span class="string">'com.alibaba:arouter-compiler:x.x.x'</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Kotlin项目中的配置方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以参考 module-kotlin 模块中的写法</span><br><span class="line">apply plugin: &#39;kotlin-kapt&#39;</span><br><span class="line"></span><br><span class="line">kapt &#123;</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &#39;com.alibaba:arouter-api:x.x.x&#39;</span><br><span class="line">    kapt &#39;com.alibaba:arouter-compiler:x.x.x&#39;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ARouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android RxAndroid</title>
    <url>/2020/04/10/androidrxandroid/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Rxjava已经问世有几年的时间，如今的版本迭代也已经到了3.0，这样的任务调度框架其实还有很多， 但是Rxjava的上手可能让然刚开始看的时候， 有点雾水，但是使用使用之后， 你会发现爽的一批，今天来讲解一下RxAndroid的简单实用。</p>
<a id="more"></a>

<h4 id="Github地址："><a href="#Github地址：" class="headerlink" title="Github地址："></a>Github地址：</h4><p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">https://github.com/ReactiveX/RxAndroid</a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RxJava 在 GitHub 主页上的自我介绍是</p>
<blockquote>
<p>RxJava is a Java VM implementation of <a href="http://reactivex.io/" target="_blank" rel="noopener">Reactive Extensions</a>: a library for composing asynchronous and event-based programs by using observable sequences.</p>
</blockquote>
<p>一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库</p>
<p>说的直白一些就是一个异步任务框架，自动处理任务调度。</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>方便！</p>
<p>不在需要自己手动切换线程来执行任务， 框架一个方法就可指定执行线程。</p>
<p>简洁！</p>
<p>链式调用的方式，减少了代码的层级嵌套， 让你对于任务的执行流程一目了然。</p>
<h4 id="简单解析"><a href="#简单解析" class="headerlink" title="简单解析"></a>简单解析</h4><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。对于事件序列，做出相应的处理，类似我们给view指定点击事件。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>框架的使用思想就是创建事件源，创建观察者， 把观察者绑定到事件源上， 就可以处理事件源进行的事件回调。</p>
<h5 id="观察者类-Observer-Subscriber"><a href="#观察者类-Observer-Subscriber" class="headerlink" title="观察者类  Observer  Subscriber"></a>观察者类  Observer  Subscriber</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"Error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber &#x3D; new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(tag, &quot;Item: &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        Log.d(tag, &quot;Completed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(tag, &quot;Error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ol>
<li><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code> 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 <code>doOnSubscribe()</code> 方法，具体可以在后面的文中看到。</li>
<li><code>unsubscribe()</code>: 这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code> 的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code> 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 <code>Subscriber</code> 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code> <code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</li>
</ol>
<h5 id="事件源类-Observable"><a href="#事件源类-Observable" class="headerlink" title="事件源类 Observable"></a>事件源类 Observable</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Observable.create</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Hi"</span>);</span><br><span class="line">        subscriber.onNext(<span class="string">"Aloha"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Observable.just</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("Aloha");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Observable.from</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"Aloha"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("Aloha");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br></pre></td></tr></table></figure>

<h5 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h5><p>就是将Observable 和 Observer/Subscriber联系起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>

<p>Observable 回调 Observer/Subscriber 的顺序<br><img src="/2020/04/10/androidrxandroid/e0cd17178w.jpg" alt></p>
<p>不完整回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="comment">// onNext()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    <span class="comment">// onError()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Error handling</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123;</span><br><span class="line">    <span class="comment">// onCompleted()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(tag, <span class="string">"completed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure>

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>字符串打印</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observable.from(names)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>图片加载展示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h5><p>就是指定事件流和订阅者分别在什么线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>到这里RxAndroid的简单使用基本已经完成， 简单总结一下， 就是创建事件源，创建观察者， 指定两者的执行线程，事件源里发送事件，观察者处理事件。</p>
<h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p><strong>map方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="string">"images/logo.png"</span>) <span class="comment">// 输入类型 String</span></span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/10/androidrxandroid/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidrxandroid%5C84bA.jpg" alt></p>
<p>说白了就是事件先经过一次处理之后在回调给订阅者</p>
<p><strong>flatmap方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/10/androidrxandroid/91c7af3r.jpg" alt></p>
<p>这个需求是打印学生的课程名称， 每个学生会上不同课程，通过一次flatmap可以将学生的课程信息回调，避免自己手动写for循环</p>
<p><strong>left方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">""</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="/2020/04/10/androidrxandroid/81befe54.jpg" alt></p>
<p>提供了只用责任链方式的事件处理</p>
<p><strong>compose方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>

<p>这个方法添加多个left， 并且可以left复用</p>
<p><strong>线程切换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxAndroid</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 插件化开发</title>
    <url>/2020/04/09/androidplugin/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>组件化开发，最终会编译成一个整体，插件化开发，会在运行时动态的加载dex等文件。</p>
<p>通俗点说就是:两个apk， 一个宿主apk，一个或多个插件apk，运行的时候宿主apk可以加载插件apk运行，继承了组件化开发优点的同时，减小了主程的大小以及解决了方法数上线的问题。</p>
<a id="more"></a>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="Android类加载机制"><a href="#Android类加载机制" class="headerlink" title="Android类加载机制"></a>Android类加载机制</h5><p><strong>类生命周期</strong></p>
<p><img src="/2020/04/09/androidplugin/2020040109054358.png" alt></p>
<p>可以看到一个类的生命周期需要经历几个过程：加载、连接、初始化。</p>
<p>其中连接分为三个步骤：验证、准备、解析</p>
<p><strong>加载</strong></p>
<p>在加载过程，虚拟机主要完成三件事</p>
<p>1、通过一个类的全限定名来获取定义此类的二进制字节流<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构<br>3、在java内存堆中生成一个代表这个类的java.lang.Class对象，作为这个类的各种数据的访问入口。</p>
<p><strong>第一步</strong>主要是获取一个类的二进制字节流，意思就是把类以流的形式加载进内存，类的来源没有说，可以是jar包，也可以是class文件或者是apk文件。这个特性是能够实现插件化技术的理论基础。</p>
<p><strong>第二步</strong>就是在获取到这个字节流以后，虚拟机就会把类中的静态存储结果保存到方法区中，保存的过程会转化对应方法区中的数据结构，所以说静态的结构都保存在内存中的方法区中。</p>
<p><strong>第三步</strong>是当类加载进内存以后，每个类都会生成一个对应的Class对象，当我们使用这个类的时候，都是通过此Class对象为入口来使用的，比如我们写程序的时候通过 new 关键字创建一个类的对象的时候，也是通过这个类的Class对象来创建的。</p>
<p><strong>连接</strong></p>
<p>连接阶段主要分验证、准备和解析。</p>
<p><strong>验证：</strong> 主要是对类中的语法结构是否合法进行验证，确认类型符合Java语言的语义。<br><strong>准备：</strong> 这个阶段是给类中的类变量分配内存，设置默认初始值，比如一个静态的int变量初始值是0，布尔变量初始值是false。<br><strong>解析：</strong> 在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。</p>
<p>解析的过程可能不好理解，关于符号引用和直接引用是什么意思可以暂时忽略，这个过程可以理解为一开始虚拟机对加载到内存中的各种类、字段等并没有一一编号，只是通过一个符号去表示，在解析阶段，虚拟机把内存中的类、方法等进行统一管理起来。</p>
<p><strong>初始化</strong></p>
<p>初始化阶段才真正到了类中定义的java代码的阶段，在这个阶段会对类中的变量和一些代码块进行初始化，比如对类变量进行初始化，在准备阶段对类变量进行的默认初始化，到这个阶段就对变量进行显式的赋值，其中静态代码块就是在这个阶段来执行的。</p>
<p>初始化不会马上执行，当一个类被主动使用的时候才会去初始化，主要有下面这几种情况：</p>
<p>1、当创建某个类的新实例时（如通过new或者反射等）<br>2、当调用某个类的静态方法时<br>3、当使用某个类或接口的静态字段时<br>4、当初始化某个子类时</p>
<p><strong>类加载机制</strong></p>
<p>Java中的ClassLoader是加载class文件，而Android中的虚拟机无论是dvm还是art都只能识别dex文件。因此Java中的ClassLoader在Android中不适用。Android中的java.lang.ClassLoader这个类也不同于Java中的java.lang.ClassLoader。</p>
<p>Dalvik虚拟机识别的是dex文件，而不是class文件，因此，我们加载的是dex文件，或者包含dex文件的apk文件或jar文件。</p>
<p>先来看下Android类加载器的结构图</p>
<p><img src="/2020/04/09/androidplugin/20200401092736975.png" alt></p>
<p>可以看出，PathClassLoader和DexClassLoader都是继承BaseDexClassLoader，那这两种加载器有什么区别呢？答案是：没有任何区别，严格的说，是在API26(含)以后，这两种类加载器就没有任何区别了，而在API26以前，还是有一定的区别的，主要区别就是跟网上说的，PathClassLoader主要是加载系统已经安装的apk,而DexClassLoader主要是加载未安装的apk/jar/zip/dex。我们来看下源码就知道了</p>
<p><strong>PathClassLoader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>DexClassLoader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dalvik.system;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个类的构造函数只有String optimizedDirectory不同，这个参数的意思是生成的odex(优化的dex)文件存放的路路径，决定了两种类加载器的不同，而在API26以后，这个参数已经废弃，没有使用了，那唯一区别的参数都没有用了，那两者不就是一模一样了吗。所以，自从API26(含26)以后，PathClassLoader和DexClassLoader两种类加载器是同一个，那为什么会有两个相同的类加载器呢？其实这是谷歌工程师一开始就预留扩展的，一般PathClassLoader是给谷歌工程师用的，而DexClassLoader是给开发者用的，这样也比较好维护，但是兜兜转转，两者还是回到了一样。</p>
<p><strong>父子关系</strong></p>
<p><strong>DexClassLoader</strong>的父加载器(parent)是<strong>PathClassLoader</strong></p>
<p><strong>PathClassLoader</strong>的父加载器(parent)是<strong>BootClassLoader</strong></p>
<p>parent和继承是两回事</p>
<p><strong>区别</strong></p>
<p>BootClassLoader主要用来<strong>加载SDK中定义的类</strong></p>
<p>PathClassLoader主要用来<strong>加载应用中类(包含自己写的类)如加载插件中的类</strong></p>
<p><strong>BaseDexClassloader</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory, </span></span></span><br><span class="line"><span class="function"><span class="params">        String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(parect);</span><br><span class="line">            <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, librarySearchPath, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(reporter ！= <span class="keyword">null</span>) &#123;</span><br><span class="line">                reporter.report(<span class="keyword">this</span>.pathList.getDexPaths())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>三个参数</p>
<p><strong>dexPath:</strong> dex文件的路劲或者是包含dex文件的apk路径，zip路径(必须是绝对路径)，可以是一个路径，也可以是多个路径，多个路径之间用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得。</p>
<p><strong>libraryPath：</strong> 指目标类中所使用的C/C++库存放的路径，也可以有多个路径，之间需要添加分隔符。</p>
<p><strong>parent：</strong> 是指当前类加载器的父加载器。</p>
<p>我们可以看到BaseDexClassLoader构造方法中，直接创建了一个DexPathList对象，并将参数传进去，那这个类的主要作用又是什么呢，来看一下它的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dalvik.system.DexPathList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Element[] dexElements;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">        String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definingContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"definingContext == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"dexPath == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!optimizedDirectory.exists())  &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory doesn't exist: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果文件不是可读可写的也会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!(optimizedDirectory.canRead()</span><br><span class="line">                        &amp;&amp; optimizedDirectory.canWrite())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"optimizedDirectory not readable/writable: "</span></span><br><span class="line">                    + optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.definingContext = definingContext;</span><br><span class="line">    ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">    <span class="comment">// 通过makeDexElements方法来获取Element数组</span></span><br><span class="line">    <span class="comment">// splitDexPath(dexPath)方法是用来把我们之前按照“：”分隔的路径转为File集合。</span></span><br><span class="line">    <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dexElementsSuppressedExceptions =</span><br><span class="line">            suppressedExceptions.toArray(<span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dexElementsSuppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.nativeLibraryDirectories = splitLibraryPath(libraryPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们重点来关注下它的成员变量dexElements,它是一个Element[]数组,里面主要用来存放dex的文件集合，Element是DexPathList的一个静态内部类。DexPathList的构造方法有4个参数。从其构造方法中也可以看到传递过来的classLoade对象和dexPath不能为null，否则就抛出空指针异常。</p>
<p>里面有一个方法<strong>makeDexElements</strong>的作用是获取一个包含dex文件的元素集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dalvik.system.DexPathList</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历打开所有的文件并且加载直接或者间接包含dex的文件。</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        File zip = <span class="keyword">null</span>;</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String name = file.getName();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// We support directories for looking up resources.</span></span><br><span class="line">            <span class="comment">// This is only useful for running libcore tests.</span></span><br><span class="line">            <span class="comment">// 可以发现它是支持传递目录的，但是说只测试libCore的时候有用</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">            <span class="comment">// 如果文件名后缀是.dex，说明是原始dex文件</span></span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="comment">// Raw dex file (not inside a zip/jar).</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//调用loadDexFile()方法，加载dex文件，获得DexFile对象</span></span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// dex文件包含在其它文件中</span></span><br><span class="line">                zip = file;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 同样调用loadDexFile()方法</span></span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                    <span class="comment">// 和加载纯dex文件不同的是，会把异常添加到异常集合中</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * IOException might get thrown "legitimately" by the DexFile constructor if</span></span><br><span class="line"><span class="comment">                     * the zip file turns out to be resource-only (that is, no classes.dex file</span></span><br><span class="line"><span class="comment">                     * in it).</span></span><br><span class="line"><span class="comment">                     * Let dex == null and hang on to the exception to add to the tea-leaves for</span></span><br><span class="line"><span class="comment">                     * when findClass returns null.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果zip或者dex二者一直不为null，就把元素添加进来</span></span><br><span class="line">        <span class="comment">// 注意，现在添加进来的zip存在不为null也不包含dex文件的可能。</span></span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(file, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从源码中可以看出，dexPath既可以直接传dex文件的路径，也可以传包含dex文件的.apk或者.zip类型的文件。通过上面的代码也可以看到，加载一个dex文件调用的是loadDexFile()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># dalvik.system.DexPathList</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果缓存存放目录为null就直接创建一个DexFile对象返回</span></span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 根据缓存存放目录和文件名得到一个优化后的缓存文件路径</span></span><br><span class="line">        String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="comment">// 调用DexFile的loadDex()方法来获取DexFile对象。</span></span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再来看下DexFile中的loadDex()方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># dalvik.system.DexFile </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> we may want to cache previously-opened DexFile objects.</span></span><br><span class="line"><span class="comment">     * The cache would be synchronized with close().  This would help</span></span><br><span class="line"><span class="comment">     * us avoid mapping the same DEX more than once when an app</span></span><br><span class="line"><span class="comment">     * decided to open it multiple times.  In practice this may not</span></span><br><span class="line"><span class="comment">     * be a real issue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//loadDex方法内部就是调用了DexFile的一个构造方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (outputName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String parent = <span class="keyword">new</span> File(outputName).getParent();</span><br><span class="line">            <span class="keyword">if</span> (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Optimized data directory "</span> + parent</span><br><span class="line">                        + <span class="string">" is not owned by the current user. Shared storage cannot protect"</span></span><br><span class="line">                        + <span class="string">" your application from code injection attacks."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ignored) &#123;</span><br><span class="line">            <span class="comment">// assume we'll fail with a more contextual error later</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">    mFileName = sourceName;</span><br><span class="line">    guard.open(<span class="string">"close"</span>);</span><br><span class="line">    <span class="comment">//System.out.println("DEX FILE cookie is " + mCookie + " sourceName=" + sourceName + " outputName=" + outputName);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Use absolute paths to enable the use of relative paths when testing on host.</span></span><br><span class="line">    <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> File(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == <span class="keyword">null</span>) ? <span class="keyword">null</span> : <span class="keyword">new</span> File(outputName).getAbsolutePath(),</span><br><span class="line">                             flags);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">openDexFileNative</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看出在loadDex()方法中，它的作用就是加载DexFile文件，而且会把优化后的dex文件缓存到对应目录。</p>
<p>所以，现在来回答下DexPathList这个类它的主要作用就是存放指明包含dex文件、native库和优化目录，封装了dex路径。</p>
<p><strong>总结下</strong></p>
<p>在BaseDexClassLoader对象构造方法内，创建了DexPathList对象。而在DexPathList构造方法内部，通过调用一系列方法，把直接包含或者间接包含dex的文件解压缩并缓存优化后的dex文件，通过DexPathList的成员变量 Element[] dexElements来指向这个文件。到此，dex文件就保存在了dexElements数组中。</p>
<h5 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h5><p>类加载是按需加载，也就是说当明确需要使用class文件的时候才会加载。</p>
<p>Android中类的加载采用了双亲委托机制的加载方式，我们先来了解下什么叫做双亲委托机制</p>
<p>当一个ClassLoader去加载一个类的时候，它会去判断当前类，记载其是否已经加载过这个类，如果已经加载过，则直接获取并返回，如果还没有加载过，它不会马上使用自己的类加载器去加载，而是委托给父加载器进行查找，这样递归一直找到最上层的parent父加载类(BootClassLoader)，如果从缓存中找到了，就直接返回这个类所对应的Class对象，如果都没有加载过，就从顶层的parent加载类去开始依次向下加载，直到加载到目标类。</p>
<p>简单说，就是第一次加载的时候，是从下到上依次从缓存中查找之前有没有加载过，如果有就返回，如果都没有，就从上到下从自己制定的位置去加载这个类，最后在交给发起者去加载该类。</p>
<p>可能这样用文字描述，听起来还是一塌糊涂，怎么查找的。没关系，下面就从源码上去分析具体是怎么实现的双亲委派机制。因为加载一个类的时候，是调用loadClass()方法，所以来看看这个方法的源码，下面这个是PathClassLoader和DexClassLoader的loadClass()源码，两者的该方法是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>下面是BootClassLoader的loadClass()方法源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve)</span><br><span class="line">           <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>来解读下源码</p>
<p>上面说过父加载器的关系是 DexClassLoader—-&gt;PathClassLoader—&gt;BootClassLoader，所以会依次去调用这三个类中的loadClass()方法。</p>
<p>一开始的时候，会先调用DexClassLoader类中loadClass()方法里面的findLoadedClass()方法来查询该类是否已经被DexClassLoader加载器加载过，如果已经加载过，就直接返回该类对应的Class对象，如果还没有被加载过，再判断其parent父加载器(PathClassLoader)如果不为null,则直接调用parent.loadClass(className, false)方法，向上从父加载器中查询，进入了PathClassLoader类的loadClass()方法，父加载器同样会先调用findLoadedClass()方法判断是否已经加载过，如果加载过，则直接返回该类的Class对象，如果同样还没有被加载过，又调用parent.loadClass(className, false)方法，此时进入的是BootClassLoader类中的loadClass()方法，同样还是先判断BootClassLoader类加载器是否已经加载过该类，如果已经加载过，直接获取并返回，如果还没有加载过该类，则直接调用BootClassLoader的findClass()方法去第一次加载该类(因为BootClassLoader已经没有父加载器了，所以不会再调用parent.loadClass()方法)，不管有没有加载到，都会返回，然后由PathClassLoader类loadClass()方法里面接收的父加载器是否加载到类，父加载器返回的Class对象不为空时，说明父加载器已经加载成功，否则说明加载失败，那只能由PathClassLoader类加载器自己去加载该类，同样将结果返回给DexClassLoader，向下交给子加载器调用findClass(className)方法(因为子加载器中的parent.loadClass(className, false)方法是返回null,所以会进入子加载器的findClass(className)方法)，这样依次向下加载。</p>
<p>接着来看下BaseDexClassLoader中的findClass()方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># dalvik.system.BaseDexClassLoader</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    <span class="comment">// 调用DexPathList对象的findClass()方法</span></span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException cnfe = <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Didn't find class \""</span> + name + <span class="string">"\" on path: "</span> + pathList);</span><br><span class="line">        <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">            cnfe.addSuppressed(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> cnfe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显可以看到BaseDexClassLoader的findClass()方法中是直接调用DexPathList类中的findClass()方法。</p>
<p>再来看DexPathList中的findClass()方法的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># dalvik.system.DexPathList</span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历Element</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        <span class="comment">// 获取DexFile，然后调用DexFile对象的loadClassBinaryName()方法来加载Class文件。</span></span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># dalvik.system.DexFile</span><br><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie, suppressed);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">long</span> cookie,List&lt;Throwable&gt; suppressed)</span> </span>&#123;</span><br><span class="line">    Class result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = defineClassNative(name, loader, cookie);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suppressed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            suppressed.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们也可以看到，实际上DexPathList最终还是遍历其自身的Element[]数组，获取DexFile对象来加载Class文件。我们之前讲DexPathList构造方法内是调用其makeDexElements()方法来创建Element[]数组的，而且也提到了如果zip文件或者dex文件二者之一不为null，就把元素添加进来，而添加进来的zip存在不为null也不包含dex文件的可能。从上面的代码中也可以看到，获取Class的时候跟这个zip文件没什么关系，调用的是dex文件对应的DexFile的方法来获取Class。</p>
<p>从上面源码中也可以看出，当从某一个dex文件中加载到类时，就会结束循环，也就是说后面的dex文件就不会执行到。这样的话，如果同时有一个类名叫A.class分别在两个不同的dex文件中时，系统到底是加载哪一个dex文件中的A.class类呢，很明显，取决于哪一个dex文件是在dexElements数组中比较靠前的，就加载那一个dex文件中的类。</p>
<p>从上面也可以总结出一点</p>
<p>Android加载一个Class是调用DexFile的defineClass()方法。而不是调用ClassLoader的defineClass()方法。这一点与Java不同，毕竟Android虚拟机加载的dex文件，而不是class文件。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>我们知道插件apk里面也是包含dex文件的，根据Android类加载器，我们可以知道DexClassLoader可以直接加载dex文件或者包含dex文件的apk文件/zip文件/jar文件，所以我们就可以在宿主apk中去动态加载插件apk，加载完插件apk之后，同样会在dexElement数组中保存插件apk中的所有dex文件，那我们只要将宿主apk的dexElement数组中的dex文件和插件apk的dexElement数组中的dex文件进行合并成一个新的dexElement数组，然后重新赋值给原来宿主apk的dexElement即可。所以最关键的就是要分别获取宿主apk中的dexElement数组对象和插件apk中的dexElement数组对象，而通过源码我们可以看到dexElement对象在DexPathList中是private私有的，如果用正常手段，我们是没办法在其他地方访问这个对象的，所以我们只能采用非常规的手段(反射的技术)去获取并操作这个对象。</p>
<p>总结下插件化实现的整体流程</p>
<p>1、创建插件的DexClassLader类加载器，传入插件apk的绝对路径(插件apk由服务器下发，然后客户端保存在指定的路径)，然后通过反射获取插件的dexElement值。</p>
<p>2、获取宿主apk的PathClassLoader类加载器(当前类的加载器)，然后通过反射获取宿主的dexElement值。</p>
<p>3、通过反射创建一个新的数组，用来存放插件的dexElement与宿主dexElement的值。</p>
<p>4、通过反射将新创建的dexElement数组赋值给宿主apk的dexElements。</p>
<h4 id="如何加载插件类"><a href="#如何加载插件类" class="headerlink" title="如何加载插件类"></a>如何加载插件类</h4><p>因为我们通过反射最终的目的是要获取dexElements成员变量的值，根据反射中获取成员变量并使用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; dexPathClass = Class.forName(<span class="string">"dalvik.system.DexPathList"</span>);</span><br><span class="line">Field dexElementsField = dexPathClass.getField(<span class="string">"dexElements"</span>)</span><br><span class="line">Element[] dexElements = (Element[]) dexElementsField.get(<span class="string">"DexPathLis对象"</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以看出，要获取dexElements数组的值，前提是要先获取dexElementsField对象，然后还要获取DexPathList对象，因为dexElements是DexPathList类中非static的成员变量，所以外界要访问该成员变量，需要依赖DexPathList对象。接着就来获取DexPathList类的对象，我们通过源码可以发现DexPathList在BaseDexClassLoader构造函数中被创建了，也就是说DexPathList对象已经在BaseDexClassLoader的成员变量中pathList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br></pre></td></tr></table></figure>



<p>那我们现在就要获取BaseDexClassLoader中的成员变量pathList的值，通过获取方法，此处获取DexPathList对象不能直接通过调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object pathList = getDeclaredConstructor(<span class="keyword">null</span>).newInstance(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p> 因为，此处相当于是重新new了一个新的DexPathList对象，而DexPathList已经在BaseDexClassLoader构造函数中创建了，所以只能   从BaseDexClassLoader类中去获取这个对象值，也就是调用以下的方法获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; baseDexClass = Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>);</span><br><span class="line">Field pathListField = baseDexClass.getField(<span class="string">"pathList"</span>);</span><br><span class="line">Object dexPathList = pathListField.get(<span class="string">"BaseDexClassLoader对象"</span>);</span><br></pre></td></tr></table></figure>

<p>可以看出，要获取DexPathList对象，前提是要获取pathListField对象，然后还要获取BaseDexClassLoader对象，因为pathList是BaseDexClassLoader类中的非static的成员变量，所以要访问该变量，就需要依赖BaseDexClassLoader对象，所以现在问题就在于如何获取BaseDexClassLoader对象即可。等同于获取DexClassLoader对象。</p>
<p>宿主apk中获取DexClassLoader方法</p>
<p>因为宿主apk中的类已经被加载了，所以可以直接获取加载当前这个类的加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader hostDexClassLoader = mContext.getClassLoader();</span><br></pre></td></tr></table></figure>

<p>其中hostDexClassLoader就是宿主apk中BaseDexClassLoader对象。</p>
<p><strong>插件apk中获取DexClassLoader方法</strong></p>
<p>因为插件apk中的类还没有在宿主apk中被加载过，所以只能通过创建一个类加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DexClassLoader pluginDexClassLoader &#x3D; new DexClassLoader(&quot;dexPath&quot;, mContext.getCacheDir().getAbsolutePath(), null, hostDexClassLoader);</span><br></pre></td></tr></table></figure>

<p>这样我们就分别获取到了宿主apk和插件apk中的BaseDexClassLoader对象，进而就可通过上面的流程获取两者的dexElements数组的值。</p>
<p>以下是完整的获取代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态加载apk，并合并插件apk的dexElement和宿主apk的dexElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadApk</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取dexElementsField对象，公共的</span></span><br><span class="line">            Class&lt;?&gt; dexPathClass = Class.forName(<span class="string">"dalvik.system.DexPathList"</span>);</span><br><span class="line">            Field dexElementsField = dexPathClass.getField(<span class="string">"dexElements"</span>);</span><br><span class="line">            <span class="comment">//获取pathListField对象，公共的</span></span><br><span class="line">            Class&lt;?&gt; baseDexClass = Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>);</span><br><span class="line">            Field pathListField = baseDexClass.getField(<span class="string">"pathList"</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 宿主apk</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//获取宿主apk加载当前类的加载器</span></span><br><span class="line">            ClassLoader hostDexClassLoader = mContext.getClassLoader();</span><br><span class="line">            <span class="comment">//获取宿主apk中DexPathList对象</span></span><br><span class="line">            Object hostDexPathList = pathListField.get(hostDexClassLoader);</span><br><span class="line">            <span class="comment">//获取宿主apk中的dexElements数组的值</span></span><br><span class="line">            Element[] hostDexElements = (Element[]) </span><br><span class="line">            dexElementsField.get(hostDexPathList);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 插件apk</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//创建插件apk的类加载器</span></span><br><span class="line">            DexClassLoader pluginDexClassLoader = <span class="keyword">new</span> DexClassLoader(dexPath, </span><br><span class="line">            mContext.getCacheDir().getAbsolutePath(), <span class="keyword">null</span>, hostDexClassLoader);</span><br><span class="line">            <span class="comment">//获取插件apk中DexPathList对象</span></span><br><span class="line">            Object pluginDexPathList = pathListField.get(pluginDexClassLoader);</span><br><span class="line">            <span class="comment">//获取插件apk中的dexElements数组的值</span></span><br><span class="line">            Element[] pluginDexElements = (Element[]) </span><br><span class="line">            dexElementsField.get(pluginDexPathList);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//合并两个dexElements数组，反射中使用数组</span></span><br><span class="line">            <span class="comment">//创建一个新的数组</span></span><br><span class="line">            Object[] newDexElements = (Object[]) </span><br><span class="line">            Array.newInstance(hostDexElements.getClass().getComponentType(), </span><br><span class="line">            hostDexElements.length + pluginDexElements.length);</span><br><span class="line">            <span class="comment">//将两个dexElements数组的内容拷贝到新创建的数组中</span></span><br><span class="line">            <span class="comment">//先拷贝宿主apk中的dexElements数组</span></span><br><span class="line">            System.arraycopy(hostDexElements,<span class="number">0</span>,newDexElements,<span class="number">0</span>,hostDexElements.length);</span><br><span class="line">            <span class="comment">//再拷贝插件apk中的dexElements数组</span></span><br><span class="line">            System.arraycopy(pluginDexElements,<span class="number">0</span>,newDexElements,</span><br><span class="line">            hostDexElements.length,pluginDexElements.length);</span><br><span class="line">            <span class="comment">//合并完成之后，将这个新的dexElements数组赋值给宿主apk中的dexElements</span></span><br><span class="line">            dexElementsField.set(hostDexPathList,newDexElements);</span><br><span class="line">            <span class="comment">//到此结束</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的代码，我们已经完成了在宿主apk中动态加载插件apk的功能，那接下来就要考虑以下几个问题：</p>
<p>1、如何在宿主apk中加载插件apk中的类</p>
<p>2、如何在宿主apk中启动插件apk中的四大组件</p>
<p>3、如何在宿主apk中加载插件apk中的资源</p>
<p>本文我们主要来讲解第一点如何加载插件中的类</p>
<p>其实这个相对比较简单，我们知道要获取某一个类的话，就要通过创建构造函数获取该类的对象，但是因为宿主apk和插件apk是完全独立的，没有任何依赖，那很显然在宿主apk中是没有办法直接获取插件apk中的某一个类对象的，那怎么办呢，这时候反射技术又派上用场了，我们可以通过反射的技术去获取插件中某一个类的Class对象，进行对这个类进行操作。代码走起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调用插件apk中PluginClass类中的function方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class&lt;?&gt; pluginClass = Class.forName(<span class="string">"com.example.pluginapp.PluginClass"</span>);</span><br><span class="line">    Method functionMethod = pluginClass.getDeclaredMethod(<span class="string">"function"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Object pluginObject = pluginClass.getDeclaredConstructor(<span class="keyword">null</span>).newInstance(<span class="keyword">null</span>);</span><br><span class="line">    functionMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">int</span> result = (<span class="keyword">int</span>) functionMethod.invoke(pluginObject, <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    tv_show.setText(<span class="string">""</span> + result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以正常的在宿主apk中去调用插件apk中某一个类了。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>插件化</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 组件化开发</title>
    <url>/2020/04/08/androidzujianhua/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>目前项目结构的优化方案组件化和插件化非常常见，本篇博客主要介绍一下组件化实现思路.</p>
<a id="more"></a>

<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>比较早的时候，大部分的项目结构都是通过模块话实现的，要聊组件化，惯例是要谈谈模块化的，毕竟它与组件化确实有一些相同点，在组件化的项目中它也会与组件化发生关联。</p>
<h5 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h5><p>模块化开发，是每个开发者都熟悉的。就是将常用的UI、网络请求、数据库操作、第三方库的使用等公共部分抽离封装成基础模块，或者将大的业务上拆分为多个小的业务模块，这些业务模块又依赖于公共基础模块的开发方式。 更宏观上，又会将这些不同的模块组合为一个整体，打包成一个完成的项目。</p>
<h5 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h5><p><strong>复用</strong><br>首先，基础模块，可为业务模块所复用；<br>其次，子业务模块，可为父业务模块，甚至不同的项目所复用。</p>
<p><strong>解耦</strong><br>降低模块间的耦合，避免出现一处代码修改，牵一发而动全身的尴尬局面。</p>
<p><strong>协同开发</strong><br>项目越来越大，团队人数越来越多，模块化开发可在尽量解耦的情况下，使不同的开发人员专注于自己负责的业务，同步开发，显著提供开发效率。<br>……</p>
<h5 id="模块化的弊端"><a href="#模块化的弊端" class="headerlink" title="模块化的弊端"></a>模块化的弊端</h5><p>任凭模块化做得多么好，还是跳不出组合在单一项目下的范围，项目规模越来越大，业务模块越来越多，团队人数越来越多，模块化开发渐渐出现了以下的问题：</p>
<p>1.项目代码量越来越大，每次的编译速度越来越慢，哪怕几句代码的修改，都需要等待若干分钟等待编译运行查看执行结果，极大的降低了开发效率；</p>
<p>2.业务模块越来越多，不可避免地产生越来越多且复杂的耦合，哪怕一次小的功能更新，也需要对修改代码耦合的模块进行充分测试；</p>
<p>3.团队人数越来越多，却要求开发人员了解与之业务相关的每一个业务模块，防止出现此开发人员修改代码导致其他模块出现bug的情况，这个要求对于开发人员显然是不友好的；<br>……</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>组件化可以说是Android中级开发工程师必备技能了，能有效解决许多单一项目下开发出现的问题。并且我要强调的是，组件化真的不难，还没搞过的小伙伴不要怂。</p>
<h5 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h5><p> 组件，顾名思义，组装的零件，术语上叫做软件单元，可用于组装在应用程序中。 从这个角度上看，组件化，要更关注可复用性、更注重关注点分离、功能单一、高内聚、粒度更小、是业务上能划分的最小单元，毕竟是“组装的零件”嘛！</p>
<h5 id="组件化的好处"><a href="#组件化的好处" class="headerlink" title="组件化的好处"></a>组件化的好处</h5><p>模块化的优点， 组件化也都具备，并且组件化也避免了模块化的弊端，具体如下：</p>
<p>1.组件，既可以作为library，又可以单独作为application，便于单独编译单独测试，大大的提高了编译和开发效率；</p>
<p>2.（业务）组件，可有自己独立的版本，业务线互不干扰，可单独编译、测试、打包、部署<br>各业务线共有的公共模块开发为组件，作为依赖库供各业务线调用，减少重复代码编写，减少冗余，便于维护</p>
<p>3.通过gradle配置文件，可对第三方库的引入进行统一管理，避免版本冲突，减少冗余库</p>
<p>4.通过gradle配置文件，可对各组件实现library与application间便捷切换，实现项目的按需加载</p>
<p>直白点说，每个组件都是高内聚低耦合，单一职责，可单独运行也可统一管理。提高了代码的复用 维护和开发效率。 后续详细讲解架构方式，以及配置方式，资源冲突的的问题。</p>
<h4 id="组件化实践"><a href="#组件化实践" class="headerlink" title="组件化实践"></a>组件化实践</h4><p>先来一张架构图</p>
<p><img src="/2020/04/08/androidzujianhua/47195.png" alt></p>
<p>其中的“业务组件”，既可以单独打包为apk，又可以作为library按需组合为综合一些的应用程序。</p>
<h5 id="统一配置"><a href="#统一配置" class="headerlink" title="统一配置"></a>统一配置</h5><p>项目结构</p>
<blockquote>
<p>app                                    //app壳<br>ModuleA                             //业务模块A<br>ModuleB                            //业务模块B</p>
<p>ModuleFunction               //功能模块<br>ModuleCommon              //公用模块 第三方库</p>
</blockquote>
<p><strong>版本统一</strong></p>
<p>Project下创建config.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * module开关统一声明在此处</span></span><br><span class="line"><span class="comment">     * true：module作为application，可单独打包为apk</span></span><br><span class="line"><span class="comment">     * false：module作为library，可作为宿主application的组件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isModuleA = <span class="literal">false</span></span><br><span class="line">    isModuleB = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本统一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    versions = [</span><br><span class="line">            <span class="string">applicationId           :</span> <span class="string">"com.xxx.xxx"</span>,        <span class="comment">//应用ID</span></span><br><span class="line">            <span class="string">versionCode             :</span> <span class="number">1</span>,                    <span class="comment">//版本号</span></span><br><span class="line">            <span class="string">versionName             :</span> <span class="string">"1.0"</span>,                <span class="comment">//版本名称</span></span><br><span class="line"></span><br><span class="line">            <span class="string">compileSdkVersion       :</span> <span class="number">28</span>,</span><br><span class="line">            <span class="string">minSdkVersion           :</span> <span class="number">21</span>,</span><br><span class="line">            <span class="string">targetSdkVersion        :</span> <span class="number">28</span>,</span><br><span class="line"></span><br><span class="line"><span class="symbol">            androidSupportSdkVersion:</span> <span class="string">"28.0.0"</span>,</span><br><span class="line">            <span class="string">constraintlayoutVersion :</span> <span class="string">"1.1.3"</span>,</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 依赖统一</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">    <span class="string">"appcompat"</span> : <span class="string">"androidx.appcompat:appcompat:$&#123;versions["</span>appcompatVersion<span class="string">"]&#125;"</span>,</span><br><span class="line">    <span class="string">"constraintlayout"</span> : <span class="string">"androidx.constraintlayout:constraintlayout:$&#123;versions["</span>constraintlayoutVersion<span class="string">"]&#125;"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Project的build.gradle中引入config.gradle文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">from:</span> <span class="string">"config.gradle"</span></span><br></pre></td></tr></table></figure>

<p>这样在主工程环境中就统一好我们的版本以及三方依赖了，还需在Model中引用主工程配置</p>
<p><strong>ModuleCommon</strong></p>
<p>Module 的build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// 在项目中的libs中的所有的.jar结尾的文件，都是依赖</span></span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把implementation 用api代替,它是对外部公开的, 所有其他的module就不需要添加该依赖</span></span><br><span class="line">    api rootProject.ext.dependencies[<span class="string">"appcompat"</span>]</span><br><span class="line">    api rootProject.ext.dependencies[<span class="string">"constraintlayout"</span>]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>ModuleA/ModuleB</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Boolean.valueOf(rootProject.ext.isModule_North)) &#123;</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line">&#125;</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.jakewharton.butterknife'</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">//公用依赖库</span></span><br><span class="line">    implementation project(<span class="string">':ModuleCommon'</span>)</span><br><span class="line">    <span class="comment">//公用功能</span></span><br><span class="line">    implementation project(<span class="string">':ModuleFunction'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就搭建好了一个组件化开发的项目结构</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>Application</strong></p>
<p>CommonFunction中创建一个BaseApplication, 上层业务组件在组件化模式下，均需继承于BaseAppliaction</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全局唯一的context</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BaseApplication application;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">        application = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseApplication <span class="title">getApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>applicationId</strong></p>
<p>可为不同组件设置不同的applicationId，也可缺省，在Android Studio中，默认的applicationId与包名一致。组件的applicationId在其build.gradle文件的defaultConfig中进行配置：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Boolean.valueOf(rootProject.ext.isModule_North)) &#123;</span><br><span class="line">    <span class="comment">//组件模式下设置applicationId</span></span><br><span class="line">    applicationId <span class="string">"com.xxx.modulea"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Manifest</strong></p>
<p>组件在集成模式和组件化模式下，需要配置不同的manifest文件，因为在组件化模式下，程序入口Activity和自定义的Application是不可或缺的。</p>
<p>在组件的build.gradle文件的android中进行manifest的管理：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * java插件引入了一个概念叫做SourceSets，通过修改SourceSets中的属性，</span></span><br><span class="line"><span class="comment"> * 可以指定哪些源文件（或文件夹下的源文件）要被编译，</span></span><br><span class="line"><span class="comment"> * 哪些源文件要被排除。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"> sourceSets &#123;</span><br><span class="line">     main &#123;</span><br><span class="line">         <span class="keyword">if</span> (Boolean.valueOf(rootProject.ext.isModuleA)) &#123;<span class="comment">//apk</span></span><br><span class="line">             manifest.srcFile <span class="string">'src/main/manifest/AndroidManifest.xml'</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">             java &#123;</span><br><span class="line">                 <span class="comment">//library模式下，排除java/debug文件夹下的所有文件</span></span><br><span class="line">                 exclude <span class="string">'*module'</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>资源冲突</strong></p>
<p>资源名冲突问题，相信大家多多少少都遇到过，以前最常见的就是第三方SDK导致的资源名冲突了。这个问题没有特别好的解决办法，只能通过设置资源名前缀 resourcePrefix 以及约束自己开发习惯进行解决。</p>
<p>资源名前缀 resourcePrefix ，是在project的build.gradle中进行设置的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 限定所有子类xml中的资源文件的前缀</span></span><br><span class="line"><span class="comment"> * 注意：图片资源，限定失效，需要手动添加前缀</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    afterEvaluate &#123;</span><br><span class="line">        android &#123;</span><br><span class="line">            resourcePrefix <span class="string">"$&#123;project.name&#125;_"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设置完之后，string、style、color、dimens等中资源名，必须以设置的字符串为前缀，而layout、drawable文件夹下的shape他们的xml文件的命名，必须以设置的字符串为前缀，否则会报错提示。</p>
<p>另外，资源前缀的设置对图片的命名无法限定，建议大家约束自己的开发习惯，自觉加上前缀。</p>
<p>建议：<br>将color、shape、style这些放在基础库组件中去，这些资源不会太多，且复用性极高，所有业务组件又都会依赖基础库组件。</p>
<p><strong>组件通讯</strong></p>
<p>业务组件间不存在依赖关系，不可以通过Intent进行显式跳转，是要借助于路由的，详细了解ARouter。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件化开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 反射</title>
    <url>/2020/04/07/javareflect/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>Java反射机制定义</strong></p>
<p>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<a id="more"></a>

<p><strong>Java 反射机制的功能</strong></p>
<p>1.在运行时判断任意一个对象所属的类。</p>
<p>2.在运行时构造任意一个类的对象。</p>
<p>3.在运行时判断任意一个类所具有的成员变量和方法。</p>
<p>4.在运行时调用任意一个对象的方法。</p>
<p>5.生成动态代理。</p>
<p><strong>Java 反射机制的应用场景</strong></p>
<p>1.逆向代码 ，例如反编译</p>
<p>2.与注解相结合的框架 例如Retrofit</p>
<p>3.单纯的反射机制应用框架 例如EventBus</p>
<p>4.动态生成类框架 例如Gson</p>
<h3 id="通过Java反射查看类信息"><a href="#通过Java反射查看类信息" class="headerlink" title="通过Java反射查看类信息"></a>通过Java反射查看类信息</h3><p><strong>获得Class对象</strong><br>每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。</p>
<p>在Java程序中获得Class对象通常有如下三种方式：</p>
<p>1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</p>
<p>2.调用某个类的class属性来获取该类对应的Class对象。</p>
<p>3.调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 通过Class类的静态方法——forName()来实现</span></span><br><span class="line">class1 = Class.forName(<span class="string">"com.xxx.Person"</span>);</span><br><span class="line"><span class="comment">//第二种方式 通过类的class属性</span></span><br><span class="line">class1 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//第三种方式 通过对象getClass方法</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Class&lt;?&gt; class1 = person.getClass();</span><br></pre></td></tr></table></figure>

<p><strong>获取class对象的属性、方法、构造函数等</strong></p>
<p>1.获取class对象的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] allFields = class1.getDeclaredFields();<span class="comment">//获取class对象的所有属性</span></span><br><span class="line">Field[] publicFields = class1.getFields();<span class="comment">//获取class对象的public属性</span></span><br><span class="line">Field ageField = class1.getDeclaredField(<span class="string">"age"</span>);<span class="comment">//获取class指定属性</span></span><br><span class="line">Field desField = class1.getField(<span class="string">"des"</span>);<span class="comment">//获取class指定的public属性</span></span><br></pre></td></tr></table></figure>

<p>2.获取class对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] methods = class1.getDeclaredMethods();<span class="comment">//获取class对象的所有声明方法</span></span><br><span class="line">Method[] allMethods = class1.getMethods();<span class="comment">//获取class对象的所有public方法 包括父类的方法</span></span><br><span class="line">Method method = class1.getMethod(<span class="string">"info"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//返回次Class对象对应类的、带指定形参列表的public方法</span></span><br><span class="line">Method declaredMethod = class1.getDeclaredMethod(<span class="string">"info"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//返回次Class对象对应类的、带指定形参列表的方法</span></span><br></pre></td></tr></table></figure>

<p>3.获取class对象的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();<span class="comment">//获取class对象的所有声明构造函数</span></span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();<span class="comment">//获取class对象public构造函数</span></span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//获取指定声明构造函数</span></span><br><span class="line">Constructor publicConstructor = class1.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//获取指定声明的public构造函数</span></span><br></pre></td></tr></table></figure>

<p>4.其他方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();<span class="comment">//获取class对象的所有注解</span></span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//获取class对象指定注解</span></span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();<span class="comment">//获取class对象的直接超类的 Type</span></span><br><span class="line">Type[] interfaceTypes = class1.getGenericInterfaces();<span class="comment">//获取class对象的所有接口的type集合</span></span><br></pre></td></tr></table></figure>

<p><strong>获取class对象的信息</strong></p>
<p>比较多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isPrimitive = class1.isPrimitive();<span class="comment">//判断是否是基础类型</span></span><br><span class="line"><span class="keyword">boolean</span> isArray = class1.isArray();<span class="comment">//判断是否是集合类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotation = class1.isAnnotation();<span class="comment">//判断是否是注解类</span></span><br><span class="line"><span class="keyword">boolean</span> isInterface = class1.isInterface();<span class="comment">//判断是否是接口类</span></span><br><span class="line"><span class="keyword">boolean</span> isEnum = class1.isEnum();<span class="comment">//判断是否是枚举类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnonymousClass = class1.isAnonymousClass();<span class="comment">//判断是否是匿名内部类</span></span><br><span class="line"><span class="keyword">boolean</span> isAnnotationPresent = class1.isAnnotationPresent(Deprecated<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//判断是否被某个注解类修饰</span></span><br><span class="line">String className = class1.getName();<span class="comment">//获取class名字 包含包名路径</span></span><br><span class="line">Package aPackage = class1.getPackage();<span class="comment">//获取class的包信息</span></span><br><span class="line">String simpleName = class1.getSimpleName();<span class="comment">//获取class类名</span></span><br><span class="line"><span class="keyword">int</span> modifiers = class1.getModifiers();<span class="comment">//获取class访问权限</span></span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();<span class="comment">//内部类</span></span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();<span class="comment">//外部类</span></span><br></pre></td></tr></table></figure>

<h3 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h3><p><strong>生成类的实例对象</strong></p>
<p>1.使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p>
<p>2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方式 Class对象调用newInstance()方法生成</span></span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line"><span class="comment">//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成</span></span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//获取指定声明构造函数</span></span><br><span class="line">obj = constructor.newInstance(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>调用类的方法</strong></p>
<p>1.通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。</p>
<p>2.调用Method对象中的<code>Object invoke(Object obj, Object... args)</code>方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 生成新的对象：用newInstance()方法</span></span><br><span class="line"> Object obj = class1.newInstance();</span><br><span class="line"><span class="comment">//首先需要获得与该方法对应的Method对象</span></span><br><span class="line">Method method = class1.getDeclaredMethod(<span class="string">"setAge"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//调用指定的函数并传递参数</span></span><br><span class="line">method.invoke(obj, <span class="number">28</span>);</span><br></pre></td></tr></table></figure>

<p><strong>当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。</strong><br><strong>setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。</strong></p>
<p><strong>访问成员变量值</strong></p>
<p>1.通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。</p>
<p>2.Field提供了两组方法来读取或设置成员变量的值：<br>getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。<br>setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成新的对象：用newInstance()方法 </span></span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line"><span class="comment">//获取age成员变量</span></span><br><span class="line">Field field = class1.getField(<span class="string">"age"</span>);</span><br><span class="line"><span class="comment">//将obj对象的age的值设置为10</span></span><br><span class="line">field.setInt(obj, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取obj对象的age的值</span></span><br><span class="line">field.getInt(obj);</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>定义：</strong>给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p>
<h4 id="1、代理模式的理解"><a href="#1、代理模式的理解" class="headerlink" title="1、代理模式的理解"></a>1、代理模式的理解</h4><p>代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。<br>在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</p>
<h4 id="2、代理模式的参与者"><a href="#2、代理模式的参与者" class="headerlink" title="2、代理模式的参与者"></a>2、代理模式的参与者</h4><p>代理模式的角色分四种：</p>
<p><img src="/2020/04/07/javareflect/43696d61.png" alt></p>
<p><strong>主题接口：</strong> Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。<br><strong>目标对象：</strong> ReaSubject 是原对象，也就是被代理的对象。<br><strong>代理对象：</strong> Proxy 是代理对象，用来封装真是主题类的代理类。<br><strong>客户端 ：</strong> 代理类和主题接口完成一些工作。</p>
<h4 id="3、代理模式的分类"><a href="#3、代理模式的分类" class="headerlink" title="3、代理模式的分类"></a>3、代理模式的分类</h4><p>代理的实现分为：</p>
<p><strong>静态代理：</strong> 代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。<br><strong>动态代理：</strong> 代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p>
<h4 id="4、代理模式的实现思路"><a href="#4、代理模式的实现思路" class="headerlink" title="4、代理模式的实现思路"></a>4、代理模式的实现思路</h4><p>1.代理对象和目标对象均实现同一个行为接口。</p>
<p>2.代理类和目标类分别具体实现接口逻辑。</p>
<p>3.在代理类的构造函数中实例化一个目标对象。</p>
<p>4.在代理类中调用目标对象的行为接口。</p>
<p>5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。</p>
<h4 id="5、静态代理模式的简单实现"><a href="#5、静态代理模式的简单实现" class="headerlink" title="5、静态代理模式的简单实现"></a>5、静态代理模式的简单实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        RealSubject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        Proxy p = <span class="keyword">new</span> Proxy(subject);</span><br><span class="line">        p.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"PreProcess"</span>);</span><br><span class="line">        subject.request();</span><br><span class="line">        System.out.println(<span class="string">"PostProcess"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。</p>
<p><strong>代理模式的好处：</strong></p>
<p>假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。</p>
<p>这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。</p>
<p>静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。</p>
<h3 id="Java反射机制与动态代理"><a href="#Java反射机制与动态代理" class="headerlink" title="Java反射机制与动态代理"></a>Java反射机制与动态代理</h3><p>动态代理的思路和上述思路一致，下面主要讲解如何实现。</p>
<h4 id="1、动态代理介绍"><a href="#1、动态代理介绍" class="headerlink" title="1、动态代理介绍"></a>1、动态代理介绍</h4><p>动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。</p>
<p>①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护；</p>
<p>②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
<h4 id="2、动态代理涉及的主要类"><a href="#2、动态代理涉及的主要类" class="headerlink" title="2、动态代理涉及的主要类"></a>2、动态代理涉及的主要类</h4><p>主要涉及两个类，这两个类都是java.lang.reflect包下的类，内部主要通过反射来实现的。</p>
<p><strong>java.lang.reflect.Proxy:</strong> 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br>Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。</p>
<p><strong>java.lang.reflect.InvocationHandler:</strong> 这里称他为”调用处理器”，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。</p>
<p>Proxy提供了如下两个方法来创建动态代理类和动态代理实例。</p>
<blockquote>
<p>static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。</p>
</blockquote>
<blockquote>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。</p>
</blockquote>
<p>对应上述两种方法创建动态代理对象的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个InvocationHandler对象</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(.args..);</span><br><span class="line"><span class="comment">//使用Proxy生成一个动态代理类</span></span><br><span class="line">Class proxyClass = Proxy.getProxyClass(RealSubject<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">RealSubject</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;</span><br><span class="line"><span class="comment">//获取proxyClass类中一个带InvocationHandler参数的构造器</span></span><br><span class="line">Constructor constructor = proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//调用constructor的newInstance方法来创建动态实例</span></span><br><span class="line">RealSubject real = (RealSubject)constructor.newInstance(handler);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个InvocationHandler对象</span></span><br><span class="line">      InvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(.args..);</span><br><span class="line">      <span class="comment">//使用Proxy直接生成一个动态代理对象</span></span><br><span class="line">      RealSubject real =Proxy.newProxyInstance(RealSubject<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">RealSubject</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。</strong></p>
<p>Proxy 类还有一些静态方法，比如：</p>
<p><code>InvocationHandler getInvocationHandler(Object proxy):</code></p>
<p>获得代理对象对应的调用处理器对象。</p>
<p><code>Class getProxyClass(ClassLoader loader, Class[] interfaces):</code></p>
<p>根据类加载器和实现的接口获得代理类。</p>
<p>InvocationHandler 接口中有方法：</p>
<p><code>invoke(Object proxy, Method method, Object[] args)</code><br>这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p>
<h4 id="3、动态代理模式的简单实现"><a href="#3、动态代理模式的简单实现" class="headerlink" title="3、动态代理模式的简单实现"></a>3、动态代理模式的简单实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建目标对象</span></span><br><span class="line">        RealSubject realSubject = <span class="keyword">new</span> RealSubject();    </span><br><span class="line">        <span class="comment">//2.创建调用处理器对象</span></span><br><span class="line">        ProxyHandler handler = <span class="keyword">new</span> ProxyHandler(realSubject);    </span><br><span class="line">       <span class="comment">//3.动态生成代理对象</span></span><br><span class="line">        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line"><span class="class">                                                        <span class="title">RealSubject</span>.<span class="title">class</span>.<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;   </span><br><span class="line">        <span class="comment">//4.通过代理对象调用方法   </span></span><br><span class="line">        proxySubject.request();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"====RealSubject Request===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类的调用处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Subject subject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</span></span><br><span class="line">        System.out.println(<span class="string">"====before===="</span>);</span><br><span class="line">       <span class="comment">//调用RealSubject中的方法</span></span><br><span class="line">        Object result = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">"====after===="</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。</p>
<h3 id="泛型和Class类"><a href="#泛型和Class类" class="headerlink" title="泛型和Class类"></a>泛型和Class类</h3><p>从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class<String>。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。</String></p>
<p>泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建指定类对应的Class对象</span></span><br><span class="line">            Class cls = Class.forName(name);</span><br><span class="line">            <span class="comment">//返回使用该Class对象创建的实例</span></span><br><span class="line">            <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。<br>如下例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = (Date) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure>

<p>或者如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = (String) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。</p>
<p>但是泛型的出现后，就可以避免这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 返回使用该Class对象创建的实例</span></span><br><span class="line">            <span class="keyword">return</span> cls.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的getInstance()方法中传入一个Class<T>参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String instance = ObjectFactory.getInstance(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>通过传入<code>String.class</code>便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。</p>
<p>当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。</p>
<h3 id="使用反射来获取泛型信息"><a href="#使用反射来获取泛型信息" class="headerlink" title="使用反射来获取泛型信息"></a>使用反射来获取泛型信息</h3><p>通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 Field 对象 f 的类型</span></span><br><span class="line">Class&lt;?&gt; a = f.getType();</span><br></pre></td></tr></table></figure>

<p>但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。</p>
<p>为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得 Field 实例的泛型类型</span></span><br><span class="line">Type type = f.getGenericType();</span><br></pre></td></tr></table></figure>

<p>然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。</p>
<p><strong>getRawType()：</strong> 返回没有泛型信息的原始类型。</p>
<p><strong>getActualTypeArguments()：</strong> 返回泛型参数的类型。</p>
<p>下面是一个获取泛型类型的完整程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String , Integer&gt; score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;GenericTest&gt; clazz = GenericTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Field f = clazz.getDeclaredField(<span class="string">"score"</span>);</span><br><span class="line">        <span class="comment">// 直接使用getType()取出Field类型只对普通类型的Field有效</span></span><br><span class="line">        Class&lt;?&gt; a = f.getType();</span><br><span class="line">        <span class="comment">// 下面将看到仅输出java.util.Map</span></span><br><span class="line">        System.out.println(<span class="string">"score的类型是:"</span> + a);</span><br><span class="line">        <span class="comment">// 获得Field实例f的泛型类型</span></span><br><span class="line">        Type gType = f.getGenericType();</span><br><span class="line">        <span class="comment">// 如果gType类型是ParameterizedType对象</span></span><br><span class="line">        <span class="keyword">if</span>(gType <span class="keyword">instanceof</span> ParameterizedType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 强制类型转换</span></span><br><span class="line">            ParameterizedType pType = (ParameterizedType)gType;</span><br><span class="line">            <span class="comment">// 获取原始类型</span></span><br><span class="line">            Type rType = pType.getRawType();</span><br><span class="line">            System.out.println(<span class="string">"原始类型是："</span> + rType);</span><br><span class="line">            <span class="comment">// 取得泛型类型的泛型参数</span></span><br><span class="line">            Type[] tArgs = pType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"泛型类型是:"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tArgs.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"个泛型类型是："</span> + tArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"获取泛型类型出错！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>score 的类型是: interface java.util.Map<br>原始类型是: interface java.util.Map<br>泛型类型是:<br>第 0 个泛型类型是: class java.lang.String<br>第 1 个泛型类型是：class java.lang.Integer</p>
</blockquote>
<p>从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。</p>
<p>Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的ClassLoader</title>
    <url>/2020/04/06/androidclassloader/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>很多同学会把Java和Android的ClassLoader搞混，甚至会认为Android中的ClassLoader和Java中的ClassLoader是一样的，这显然是不对的。这一篇文章我们来看看它和Java中的ClassLoader有何不同。</p>
<a id="more"></a>

<h4 id="1-ClassLoader的类型"><a href="#1-ClassLoader的类型" class="headerlink" title="1.ClassLoader的类型"></a><strong>1.ClassLoader的类型</strong></h4><p>我们知道Java中的ClassLoader可以加载jar文件和Class文件（本质是加载Class文件），这一点在Android中并不适用，因为无论是DVM还是ART它们加载的不再是Class文件，而是dex文件，这就需要重新设计ClassLoader相关类，我们先来学习ClassLoader的类型。<br>Android中的ClassLoader类型和Java中的ClassLoader类型类似，也分为两种类型，分别是系统ClassLoader和自定义ClassLoader。其中系统ClassLoader主要有3种分别是BootClassLoader、PathClassLoader和DexClassLoader。</p>
<h5 id="1-1-BootClassLoader"><a href="#1-1-BootClassLoader" class="headerlink" title="1.1 BootClassLoader"></a>1.1 BootClassLoader</h5><p>Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的，BootClassLoade的代码如下所示。<br><strong>libcore/ojluni/src/main/java/java/lang/ClassLoader.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BootClassLoader instance;</span><br><span class="line">    <span class="meta">@FindBugsSuppressWarnings</span>(<span class="string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BootClassLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> BootClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BootClassLoader是ClassLoader的内部类，并继承自ClassLoader。BootClassLoader是一个单例类，需要注意的是BootClassLoader的访问修饰符是默认的，只有在同一个包中才可以访问，因此我们在应用程序中是无法直接调用的。</p>
<h5 id="1-2-DexClassLoader"><a href="#1-2-DexClassLoader" class="headerlink" title="1.2 DexClassLoader"></a>1.2 DexClassLoader</h5><p>DexClassLoader可以加载dex文件以及包含dex的压缩文件（apk和jar文件），不管是加载哪种文件，最终都是要加载dex文件，为了方便理解和叙述，将dex文件以及包含dex的压缩文件统称为dex相关文件。<br>来查看DexClassLoader的代码，如下所示。<br><strong>libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">    String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DexClassLoader的构造方法有四个参数：</p>
<ul>
<li>dexPath：dex相关文件路径集合，多个路径用文件分隔符分隔，默认文件分隔符为‘：’</li>
<li>optimizedDirectory：解压的dex文件存储路径，这个路径必须是一个内部存储路径，一般情况下使用当前应用程序的私有路径：<code>/data/data/&lt;Package Name&gt;/...</code>。</li>
<li>librarySearchPath：包含 C/C++ 库的路径集合，多个路径用文件分隔符分隔分割，可以为null。</li>
<li>parent：父加载器。</li>
</ul>
<p>DexClassLoader 继承自BaseDexClassLoader ，方法实现都在BaseDexClassLoader中。</p>
<h5 id="1-3-PathClassLoader"><a href="#1-3-PathClassLoader" class="headerlink" title="1.3 PathClassLoader"></a>1.3 PathClassLoader</h5><p>Android系统使用PathClassLoader来加载系统类和应用程序的类，来查看它的代码:<br><strong>libcore/dalvik/src/main/java/dalvik/system/PathClassLoader.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PathClassLoader继承自BaseDexClassLoader，实现也都在BaseDexClassLoader中。</p>
<p>PathClassLoader的构造方法中没有参数optimizedDirectory，这是因为PathClassLoader已经默认了参数optimizedDirectory的值为：/data/dalvik-cache，很显然PathClassLoader无法定义解压的dex文件存储路径，因此PathClassLoader通常用来加载已经安装的apk的dex文件(安装的apk的dex文件会存储在/data/dalvik-cache中)。</p>
<h4 id="2-ClassLoader的继承关系"><a href="#2-ClassLoader的继承关系" class="headerlink" title="2.ClassLoader的继承关系"></a>2.ClassLoader的继承关系</h4><p>运行一个Android程序需要用到几种类型的类加载器呢？如下所示。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ClassLoader loader = MainActivity<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(<span class="string">"xxx"</span>,loader.toString());<span class="comment">//1</span></span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们得到MainActivity的类加载器，并在注释1处通过Log打印出来，接着打印出当前类的类加载器的父加载器，直到没有父加载器终止循环。打印结果如下所示。</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span><span class="number">-07</span> <span class="number">07</span>:<span class="number">23</span>:<span class="number">02.835</span> <span class="number">8272</span><span class="number">-8272</span>/? <span class="symbol">D</span>/xxx: dalvik.system.<span class="symbol">PathClassLoader</span>[<span class="symbol">DexPathList</span>[[zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/base.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_dependencies_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_0_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_1_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_2_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_3_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_4_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_5_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_6_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_7_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_8_apk.apk”, zip file “/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/split_lib_slice_9_apk.apk”],nativeLibraryDirectories=[/data/app/com.example.xxx.moonclassloader<span class="number">-2</span>/lib/x86, /vendor/lib, /system/lib]]]</span><br><span class="line"> <span class="number">10</span><span class="number">-07</span> <span class="number">07</span>:<span class="number">23</span>:<span class="number">02.835</span> <span class="number">8272</span><span class="number">-8272</span>/? <span class="symbol">D</span>/xxx: java.lang.<span class="symbol">BootClassLoader</span>@e175998</span><br></pre></td></tr></table></figure>

<p>可以看到有两种类加载器，一种是PathClassLoader，另一种则是BootClassLoader。DexPathList中包含了很多apk的路径，其中/data/app/com.example.xxx.moonclassloader-2/base.apk就是示例应用安装在手机上的位置。关于DexPathList后续文章会进行介绍。</p>
<p>和Java中的ClassLoader一样，虽然系统所提供的类加载器主要有3种类型，但是系统提供的ClassLoader相关类却不只3个。ClassLoader的继承关系如下图所示。 </p>
<p><img src="/2020/04/06/androidclassloader/vndmwl.png" alt></p>
<p>可以看到上面一共有8个ClassLoader相关类，其中有一些和Java中的ClassLoader相关类十分类似，下面简单对它们进行介绍：</p>
<ul>
<li><p>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。BootClassLoader是它的内部类。</p>
</li>
<li><p>SecureClassLoader类和JDK8中的SecureClassLoader类的代码是一样的，它继承了抽象类ClassLoader。SecureClassLoader并不是ClassLoader的实现类，而是拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性。</p>
</li>
<li><p>URLClassLoader类和JDK8中的URLClassLoader类的代码是一样的，它继承自SecureClassLoader，用来通过URl路径从jar文件和文件夹中加载类和资源。</p>
</li>
<li><p>InMemoryDexClassLoader是Android8.0新增的类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件。</p>
</li>
<li><p>BaseDexClassLoader继承自ClassLoader，是抽象类ClassLoader的具体实现类，PathClassLoader和DexClassLoader都继承它。</p>
</li>
</ul>
<h4 id="3-BootClassLoader的创建"><a href="#3-BootClassLoader的创建" class="headerlink" title="3.BootClassLoader的创建"></a>3.BootClassLoader的创建</h4><p>  BootClassLoader是在何时被创建的呢？这得先从Zygote进程开始说起，<br>  ZygoteInit的main方法如下所示。  <strong>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> ...</span><br><span class="line"> preload(bootTimingsTraceLog);</span><br><span class="line"> ... </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>main方法是ZygoteInit入口方法，其中调用了ZygoteInit的preload方法，preload方法中又调用了ZygoteInit的preloadClasses方法，如下所示。<br><strong>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preloadClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> VMRuntime runtime = VMRuntime.getRuntime();</span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> FileInputStream(PRELOADED_CLASSES);<span class="comment">//1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Couldn't find "</span> + PRELOADED_CLASSES + <span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is), <span class="number">256</span>);<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;<span class="comment">//3</span></span><br><span class="line">        line = line.trim();</span><br><span class="line">        <span class="keyword">if</span> (line.startsWith(<span class="string">"#"</span>) || line.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Preloading "</span> + line + <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Class.forName(line, <span class="keyword">true</span>, <span class="keyword">null</span>);<span class="comment">//4</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Class not found for preloading: "</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error reading "</span> + PRELOADED_CLASSES + <span class="string">"."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preloadClasses方法用于Zygote进程初始化时预加载常用类。注释1处将/system/etc/preloaded-classes文件封装成FileInputStream，preloaded-classes文件中存有预加载类的目录，这个文件在系统源码中的路径为frameworks/base/preloaded-classes，这里列举一些preloaded-classes文件中的预加载类名称，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android.app.ApplicationLoaders</span><br><span class="line">android.app.ApplicationPackageManager</span><br><span class="line">android.app.ApplicationPackageManager$OnPermissionsChangeListenerDelegate</span><br><span class="line">android.app.ApplicationPackageManager$ResourceName</span><br><span class="line">android.app.ContentProviderHolder</span><br><span class="line">android.app.ContentProviderHolder$<span class="number">1</span></span><br><span class="line">android.app.ContextImpl</span><br><span class="line">android.app.ContextImpl$ApplicationContentResolver</span><br><span class="line">android.app.DexLoadReporter</span><br><span class="line">android.app.Dialog</span><br><span class="line">android.app.Dialog$ListenersHandler</span><br><span class="line">android.app.DownloadManager</span><br><span class="line">android.app.Fragment</span><br></pre></td></tr></table></figure>

<p>可以看到preloaded-classes文件中的预加载类的名称有很多都是我们非常熟知的。预加载属于拿空间换时间的策略，Zygote环境配置的越健全越通用，应用程序进程需要单独做的事情也就越少，预加载除了预加载类，还有预加载资源和预加载共享库，因为不是本文重点，这里就不在延伸讲下去了。<br>回到preloadClasses方法的注释2处，将FileInputStream封装为BufferedReader，并注释3处遍历BufferedReader，读出所有预加载类的名称，每读出一个预加载类的名称就调用注释4处的代码加载该类，Class的forName方法如下所示。<br><strong>libcore/ojluni/src/main/java/java/lang/Class.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">    ClassLoader loader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        loader = BootClassLoader.getInstance();<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = classForName(name, initialize, loader);<span class="comment">//2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        Throwable cause = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> LinkageError) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (LinkageError) cause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处创建了BootClassLoader，并将BootClassLoader实例传入到了注释2处的classForName方法中，classForName方法是Native方法，它的实现由c/c++代码来完成，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; classForName(String className, <span class="keyword">boolean</span> shouldInitialize,</span><br><span class="line">        ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure>

<h4 id="4-PathClassLoader的创建"><a href="#4-PathClassLoader的创建" class="headerlink" title="4.PathClassLoader的创建"></a>4.PathClassLoader的创建</h4><p>PathClassLoader的创建也得从Zygote进程开始说起，Zygote进程启动SyetemServer进程时会调用ZygoteInit的startSystemServer方法，如下所示。<br><strong>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">int</span> pid;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);<span class="comment">//2</span></span><br><span class="line">         ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">         ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line">         <span class="comment">/*1*/</span></span><br><span class="line">         pid = Zygote.forkSystemServer(</span><br><span class="line">         parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">         parsedArgs.gids,</span><br><span class="line">         parsedArgs.debugFlags,</span><br><span class="line">         <span class="keyword">null</span>,</span><br><span class="line">         parsedArgs.permittedCapabilities,</span><br><span class="line">         parsedArgs.effectiveCapabilities);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">//2</span></span><br><span class="line">         <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">             waitForSecondaryZygote(socketName);</span><br><span class="line">         &#125;</span><br><span class="line">         handleSystemServerProcess(parsedArgs);<span class="comment">//3</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注释1处，Zygote进程通过forkSystemServer方法fork自身创建子进程（SystemServer进程）。注释2处如果forkSystemServer方法返回的pid等于0，说明当前代码是在新创建的SystemServer进程中执行的，接着就会执行注释3处的handleSystemServerProcess方法：<br><strong>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ZygoteConnection.Arguments parsedArgs)</span> <span class="keyword">throws</span> Zygote.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);<span class="comment">//1</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">        ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释1处调用了createPathClassLoader方法，如下所示。<br><strong>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PathClassLoader <span class="title">createPathClassLoader</span><span class="params">(String classPath, <span class="keyword">int</span> targetSdkVersion)</span> </span>&#123;</span><br><span class="line">    String libraryPath = System.getProperty(<span class="string">"java.library.path"</span>);</span><br><span class="line">    <span class="keyword">return</span> PathClassLoaderFactory.createClassLoader(classPath,</span><br><span class="line">            libraryPath,</span><br><span class="line">            libraryPath,</span><br><span class="line">            ClassLoader.getSystemClassLoader(),</span><br><span class="line">            targetSdkVersion,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* isNamespaceShared */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createPathClassLoader方法中又会调用PathClassLoaderFactory的createClassLoader方法，看来PathClassLoader是用工厂来进行创建的。<br><strong>frameworks/base/core/java/com/android/internal/os/PathClassLoaderFactory.java</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PathClassLoader <span class="title">createClassLoader</span><span class="params">(String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    String librarySearchPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    String libraryPermittedPath,</span></span></span><br><span class="line"><span class="function"><span class="params">    ClassLoader parent,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> isNamespaceShared)</span> </span>&#123;</span><br><span class="line">    PathClassLoader pathClassloader = <span class="keyword">new</span> PathClassLoader(dexPath, librarySearchPath, parent);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> pathClassloader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PathClassLoaderFactory的createClassLoader方法中会创建PathClassLoader。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 内存区域</title>
    <url>/2020/04/05/javaneicun/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>很多人将Java的内存分为堆内存（heap）和栈内存（Stack），这种分发不够准确，Java的内存区域划分实际上远比这复杂</p>
<a id="more"></a>

<p><strong>方法区（公有）：</strong> 用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError</p>
<p>其中包含常量池：用户存放编译器生成的各种字面量和符号引用。</p>
<p><strong>堆（公有）：</strong> 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError</p>
<p><strong>虚拟机栈（线程私有）：</strong> 描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError</p>
<p><strong>本地方法栈（线程私有）:</strong> 与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。</p>
<p><strong>程序计数器（线程私有）：</strong> 一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p><img src="/2020/04/05/javaneicun/696d61.png" alt></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类加载机制</title>
    <url>/2020/04/05/javaclassloader/</url>
    <content><![CDATA[<h3 id="一、类加载机制"><a href="#一、类加载机制" class="headerlink" title="一、类加载机制"></a>一、类加载机制</h3><h4 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h4><p>把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。</p>
<a id="more"></a>

<h4 id="2-类的生命周期："><a href="#2-类的生命周期：" class="headerlink" title="2.类的生命周期："></a>2.类的生命周期：</h4><p>加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。</p>
<p>这7个阶段发生顺序如下图：</p>
<p><img src="/2020/04/05/javaclassloader/43696d61.png" alt></p>
<p>加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。</p>
<p><strong>其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。</strong></p>
<h4 id="3-触发类加载的条件："><a href="#3-触发类加载的条件：" class="headerlink" title="3.触发类加载的条件："></a>3.触发类加载的条件：</h4><p>①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。</p>
<p>②.使用java.lang.reflect包的方法对类进行反射调用的时候。</p>
<p>③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p>
<p>④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>⑤.当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic,REF_putStatic,REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。</p>
<h4 id="4-类加载的具体过程："><a href="#4-类加载的具体过程：" class="headerlink" title="4.类加载的具体过程："></a>4.类加载的具体过程：</h4><p><strong>加载:</strong></p>
<p>①.通过一个类的全限定名来获取定义此类的二进制字节流</p>
<p>②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构</p>
<p>③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p><strong>验证：</strong></p>
<p>是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>包含四个阶段的校验动作</p>
<p>a.文件格式验证</p>
<p>验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>b.元数据验证</p>
<p>对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息</p>
<p>c.字节码验证</p>
<p>最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p>
<p>d.符号引用验证</p>
<p>最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。</p>
<p>符号验证的目的是确保解析动作能正常进行。</p>
<p><strong>准备：</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。</p>
<p>“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。</p>
<p><strong>解析：</strong></p>
<p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<p>“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。</p>
<p><strong>初始化：</strong></p>
<p>类加载过程中的最后一步。</p>
<p>初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作和静态语句块中的语句合并产生的</strong>。</p>
<p><code>&lt;clinit&gt;()</code>与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</p>
<p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p>
<h3 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h3><p>通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p>
<h4 id="1-类加载器分类："><a href="#1-类加载器分类：" class="headerlink" title="1.类加载器分类："></a>1.类加载器分类：</h4><p>不同的类加载器负责加载不同的类。主要分为两类。</p>
<p><strong>启动类加载器（Bootstrap ClassLoader）：</strong> 由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。</JAVA_HOME></p>
<p><strong>其他类加载器：</strong> 由Java语言实现，继承自抽象类ClassLoader。如：</p>
<ul>
<li><p>扩展类加载器（Extension ClassLoader）： 负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。</JAVA_HOME></p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>
</li>
</ul>
<p>以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。</p>
<h4 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2.双亲委派模型"></a>2.双亲委派模型</h4><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><img src="/2020/04/05/javaclassloader/743696d61.png" alt></p>
<p>这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。</p>
<h4 id="3-双亲委派模型的代码实现"><a href="#3-双亲委派模型的代码实现" class="headerlink" title="3.双亲委派模型的代码实现"></a>3.双亲委派模型的代码实现</h4><p>ClassLoader中loadClass方法实现了双亲委派模型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">//检查该类是否已经加载过</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该类没有加载，则进入该分支</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name); <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="整个流程大致如下："><a href="#整个流程大致如下：" class="headerlink" title="整个流程大致如下："></a>整个流程大致如下：</h4><p>a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</p>
<p>b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</p>
<p>c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型</title>
    <url>/2020/03/30/javagenercity/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>泛型是Java5版本开始的新特性，泛型是通过语法糖形式实现的，通过泛型使得在<strong>编译阶段</strong>完成一些类型转换的工作，避免在运行时强制类型转换而出现<code>ClassCastException</code>，即类型转换异常。</p>
<a id="more"></a>

<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(T t)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;  <span class="comment">//可以为任意类型</span></span><br></pre></td></tr></table></figure>

<p>上限通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends xxx&gt;</span><br></pre></td></tr></table></figure>

<p>下线通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> xxx&gt;</span><br></pre></td></tr></table></figure>

<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">Class c2 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">System.out.println(c1==c2);</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<blockquote>
<p>true。</p>
</blockquote>
<p>这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦除，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p><strong>在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 基础绘制</title>
    <url>/2020/03/23/androidviewpro2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>绘制最主要的两个点就是Canvas和Paint了,  画布和画笔. 画是画在画布上的，所以画什么内容的方法封装在了canvas中，颜色空心实心等属性是属于笔的，所以封装在了Paint中.</p>
<a id="more"></a>

<h4 id="Canvas的常用操作速查表"><a href="#Canvas的常用操作速查表" class="headerlink" title="Canvas的常用操作速查表"></a>Canvas的常用操作速查表</h4><table>
<thead>
<tr>
<th>操作类型</th>
<th>相关API</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>绘制颜色</td>
<td>drawColor, drawRGB, drawARGB</td>
<td>使用单一颜色填充整个画布</td>
</tr>
<tr>
<td>绘制基本形状</td>
<td>drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>
<td>依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td>
</tr>
<tr>
<td>绘制图片</td>
<td>drawBitmap, drawPicture</td>
<td>绘制位图和图片</td>
</tr>
<tr>
<td>绘制文本</td>
<td>drawText, drawPosText, drawTextOnPath</td>
<td>依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td>
</tr>
<tr>
<td>绘制路径</td>
<td>drawPath</td>
<td>绘制路径，绘制贝塞尔曲线时也需要用到该函数</td>
</tr>
<tr>
<td>顶点操作</td>
<td>drawVertices, drawBitmapMesh</td>
<td>通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td>
</tr>
<tr>
<td>画布剪裁</td>
<td>clipPath, clipRect</td>
<td>设置画布的显示区域</td>
</tr>
<tr>
<td>画布快照</td>
<td>save, restore, saveLayerXxx, restoreToCount, getSaveCount</td>
<td>依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数</td>
</tr>
<tr>
<td>画布变换</td>
<td>translate, scale, rotate, skew</td>
<td>依次为 位移、缩放、 旋转、错切</td>
</tr>
<tr>
<td>Matrix(矩阵)</td>
<td>getMatrix, setMatrix, concat</td>
<td>实际画布的位移，缩放等操作的都是图像矩阵Matrix，只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td>
</tr>
</tbody></table>
<h4 id="绘制基本形"><a href="#绘制基本形" class="headerlink" title="绘制基本形"></a>绘制基本形</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.drawxxx <span class="comment">//即可在画布上画上你想要的内容</span></span><br></pre></td></tr></table></figure>

<h4 id="画布变换"><a href="#画布变换" class="headerlink" title="画布变换"></a>画布变换</h4><h5 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.translate(<span class="number">200</span>,<span class="number">200</span>); <span class="comment">//向x轴 y轴方向 移动200</span></span><br></pre></td></tr></table></figure>

<p>多次调用效果叠加</p>
<h5 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h5><p>两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scale</span> <span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scale</span> <span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy, <span class="keyword">float</span> px, <span class="keyword">float</span> py)</span></span></span><br></pre></td></tr></table></figure>

<p>这两个方法中前两个参数是相同的分别为x轴和y轴的缩放比例。而第二种方法比前一种多了两个参数，用来控制缩放中心位置的。</p>
<p>缩放比例(sx,sy)取值范围详解：</p>
<table>
<thead>
<tr>
<th>取值范围(n)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(-∞, -1)</td>
<td>先根据缩放中心放大n倍，再根据中心轴进行翻转</td>
</tr>
<tr>
<td>-1</td>
<td>根据缩放中心轴进行翻转</td>
</tr>
<tr>
<td>(-1, 0)</td>
<td>先根据缩放中心缩小到n，再根据中心轴进行翻转</td>
</tr>
<tr>
<td>0</td>
<td>不会显示，若sx为0，则宽度为0，不会显示，sy同理</td>
</tr>
<tr>
<td>(0, 1)</td>
<td>根据缩放中心缩小到n</td>
</tr>
<tr>
<td>1</td>
<td>没有变化</td>
</tr>
<tr>
<td>(1, +∞)</td>
<td>根据缩放中心放大n倍</td>
</tr>
</tbody></table>
<p><strong>缩放的中心默认为坐标原点,而缩放中心轴就是坐标轴</strong></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.scale(<span class="number">0.5f</span>,<span class="number">0.5f</span>);   <span class="comment">// 以坐标原点进行画布缩放</span></span><br><span class="line">canvas.scale(<span class="number">0.5f</span>,<span class="number">0.5f</span>,<span class="number">200</span>,<span class="number">0</span>); <span class="comment">// 画布缩放  &lt;-- 缩放中心向右偏移了200个单位</span></span><br></pre></td></tr></table></figure>

<p>多次调用效果叠加</p>
<h5 id="rotate"><a href="#rotate" class="headerlink" title="rotate"></a>rotate</h5><p>两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">float</span> degrees)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rotate</span> <span class="params">(<span class="keyword">float</span> degrees, <span class="keyword">float</span> px, <span class="keyword">float</span> py)</span></span></span><br></pre></td></tr></table></figure>

<p>和缩放一样，第二种方法多出来的两个参数依旧是控制旋转中心点的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.rotate(<span class="number">180</span>);              <span class="comment">// 旋转180度 &lt;-- 默认旋转中心为原点</span></span><br><span class="line"></span><br><span class="line">canvas.rotate(<span class="number">180</span>,<span class="number">200</span>,<span class="number">0</span>);        <span class="comment">// 旋转180度 &lt;-- 旋转中心向右偏移200个单位</span></span><br></pre></td></tr></table></figure>

<p>多次调用效果叠加</p>
<h5 id="skew"><a href="#skew" class="headerlink" title="skew"></a>skew</h5><p>skew这里翻译为错切，错切是特殊类型的线性变换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">skew</span> <span class="params">(<span class="keyword">float</span> sx, <span class="keyword">float</span> sy)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>参数含义：</strong><br>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值<br>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">canvas.skew(<span class="number">1</span>,<span class="number">0</span>);                       <span class="comment">// 水平错切 45</span></span><br><span class="line">canvas.skew(<span class="number">0</span>,<span class="number">1</span>);                       <span class="comment">// 垂直错切 45</span></span><br></pre></td></tr></table></figure>

<p><strong>错切也是可叠加的，不过请注意，调用次序不同绘制结果也会不同</strong></p>
<h5 id="快照-save-和回滚-restore"><a href="#快照-save-和回滚-restore" class="headerlink" title="快照(save)和回滚(restore)"></a>快照(save)和回滚(restore)</h5><p>画布的操作是不可逆的，而且很多画布操作会影响后续的步骤，例如第一个例子，两个圆形都是在坐标原点绘制的，而因为坐标系的移动绘制出来的实际位置不同。所以会对画布的一些状态进行保存和回滚</p>
<table>
<thead>
<tr>
<th>相关API</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>save</td>
<td>把当前的画布的状态进行保存，然后放入特定的栈中</td>
</tr>
<tr>
<td>saveLayerXxx</td>
<td>新建一个图层，并放入特定的栈中</td>
</tr>
<tr>
<td>restore</td>
<td>把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布</td>
</tr>
<tr>
<td>restoreToCount</td>
<td>弹出指定位置及其以上所有的状态，并按照指定位置的状态进行恢复</td>
</tr>
<tr>
<td>getSaveCount</td>
<td>获取栈中内容的数量(即保存次数)</td>
</tr>
</tbody></table>
<p>状态压栈：</p>
<p>save就是把画布状态保存起来，放入栈中</p>
<p><img src="/2020/03/23/androidviewpro2/a7067.jpg" alt></p>
<p>这个栈可以存储画布状态和图层状态，如果会ps的同学相信对于图层这个概念很熟悉</p>
<p><img src="/2020/03/23/androidviewpro2/722e6a7067.jpg" alt></p>
<p>我们之前讲解的绘制操作和画布操作都是在默认图层上进行的，在通常情况下，使用默认图层就可满足需求，但是如果需要绘制比较复杂的内容，如地图(地图可以有多个地图层叠加而成，比如：政区层，道路层，兴趣点层)等，则分图层绘制比较好一些。<br>你可以把这些图层看做是一层一层的玻璃板，你在每层的玻璃板上绘制内容，然后把这些玻璃板叠在一起看就是最终效果。</p>
<h6 id="save"><a href="#save" class="headerlink" title="save"></a>save</h6><p>save 有两种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存全部状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span> <span class="params">()</span>    <span class="comment">// 根据saveFlags参数保存一部分状态</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span> <span class="params">(<span class="keyword">int</span> saveFlags)</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到第二种方法比第一种多了一个saveFlags参数，使用这个参数可以只保存一部分状态，更加灵活，这个saveFlags参数具体可参考上面表格中的内容。</p>
<p>每调用一次save方法，都会在栈顶添加一条状态信息，以上面状态栈图片为例，再调用一次save则会在第5次上面载添加一条状态。</p>
<h6 id="saveLayerXxx"><a href="#saveLayerXxx" class="headerlink" title="saveLayerXxx"></a>saveLayerXxx</h6><p>saveLayerXxx有比较多的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无图层alpha(不透明度)通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayer</span> <span class="params">(RectF bounds, Paint paint)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayer</span> <span class="params">(RectF bounds, Paint paint, <span class="keyword">int</span> saveFlags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayer</span> <span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Paint paint)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayer</span> <span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Paint paint, <span class="keyword">int</span> saveFlags)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 有图层alpha(不透明度)通道</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayerAlpha</span> <span class="params">(RectF bounds, <span class="keyword">int</span> alpha)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayerAlpha</span> <span class="params">(RectF bounds, <span class="keyword">int</span> alpha, <span class="keyword">int</span> saveFlags)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayerAlpha</span> <span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">int</span> alpha)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveLayerAlpha</span> <span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">int</span> alpha, <span class="keyword">int</span> saveFlags)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> saveLayerXxx方法会让你花费更多的时间去渲染图像(图层多了相互之间叠加会导致计算量成倍增长)，使用前请谨慎，如果可能，尽量避免使用。</p>
<p>使用saveLayerXxx方法，也会将图层状态也放入状态栈中，同样使用restore方法进行恢复。</p>
<h6 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h6><p>状态回滚，就是从栈顶取出一个状态然后根据内容进行恢复。</p>
<p>同样以上面状态栈图片为例，调用一次restore方法则将状态栈中第5次取出，根据里面保存的状态进行状态恢复。</p>
<h6 id="restoreToCount"><a href="#restoreToCount" class="headerlink" title="restoreToCount"></a>restoreToCount</h6><p>弹出指定位置以及以上所有状态，并根据指定位置状态进行恢复。</p>
<p>以上面状态栈图片为例，如果调用restoreToCount(2) 则会弹出 2 3 4 5 的状态，并根据第2次保存的状态进行恢复。</p>
<h6 id="getSaveCount"><a href="#getSaveCount" class="headerlink" title="getSaveCount"></a>getSaveCount</h6><p>获取保存的次数，即状态栈中保存状态的数量，以上面状态栈图片为例，使用该函数的返回值为5。</p>
<p>不过请注意，该函数的最小返回值为1，即使弹出了所有的状态，返回值依旧为1，代表默认状态。</p>
<h6 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h6><p>虽然关于状态的保存和回滚啰嗦了不少，不过大多数情况下只需要记住下面的步骤就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save();      <span class="comment">//保存状态</span></span><br><span class="line">...          <span class="comment">//具体操作</span></span><br><span class="line">restore();   <span class="comment">//回滚到之前的状态</span></span><br></pre></td></tr></table></figure>

<p>这种方式也是最简单和最容易理解的使用方法。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>绘制</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 自定义View</title>
    <url>/2020/03/23/androidviewpro1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在实际的开发过程中，总有系统自带的控件无法满足的情况，这个时候就需要我们自己定义view，我们可以更灵活的定义view的排版方式，绘制方式，回调等等.. </p>
<a id="more"></a>

<h4 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h4><p>我们的界面，都是通过viewgroup层层嵌套viewgroup或者view的方式来实现的，那这个view树的绘制流程是如何的呢？总共分三步：</p>
<blockquote>
<p>Measure(测量) -&gt; Layout(布局) -&gt; Draw(绘制)</p>
</blockquote>
<p>上面的三个方法递归调用所有的子view，确定好大小，位置之后，开始绘制</p>
<h5 id="Measure-测量"><a href="#Measure-测量" class="headerlink" title="Measure(测量)"></a>Measure(测量)</h5><p>View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量自己的宽高，然后告诉父控件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> widthsize = MeasureSpec.getSize(widthMeasureSpec); <span class="comment">//取出宽度的确切数值</span></span><br><span class="line">     <span class="keyword">int</span> widthmode = MeasureSpec.getMode(widthMeasureSpec); <span class="comment">//取出宽度的测量模式</span></span><br><span class="line">     <span class="keyword">int</span> heightsize = MeasureSpec.getSize(heightMeasureSpec); <span class="comment">//取出高度的确切数值</span></span><br><span class="line">     <span class="keyword">int</span> heightmode = MeasureSpec.getMode(heightMeasureSpec); <span class="comment">//取出高度的测量模式</span></span><br><span class="line">     setMeasuredDimension(widthsize, heightsize);  <span class="comment">//告诉父view自己的宽高</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出 onMeasure 函数中有 widthMeasureSpec 和 heightMeasureSpec 这两个 int 类型的参数， 毫无疑问他们是和宽高相关的， 但它们其实不是宽和高， 而是由<strong>宽、高和各自方向上对应的测量模式</strong>来合成的一个值：</p>
<p><strong>测量模式一共有三种：</strong></p>
<table>
<thead>
<tr>
<th>模式</th>
<th align="center">二进制数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UNSPECIFIED</td>
<td align="center">00</td>
<td>默认值，父控件没有给子view任何限制，子View可以设置为任意大小。</td>
</tr>
<tr>
<td>EXACTLY</td>
<td align="center">01</td>
<td>表示父控件已经确切的指定了子View的大小。</td>
</tr>
<tr>
<td>AT_MOST</td>
<td align="center">10</td>
<td>表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。</td>
</tr>
</tbody></table>
<p>在int类型的32位二进制位中，31-30这两位表示测量模式,29~0这三十位表示宽和高的实际值</p>
<h5 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout(布局)"></a>Layout(布局)</h5><p>确定布局的函数是onLayout，它用于确定子View的位置，在自定义ViewGroup中会用到，他调用的是子View的layout函数。</p>
<p>在自定义ViewGroup中，onLayout一般是循环取出子View，然后经过计算得出各个子View位置的坐标值，然后用以下函数设置子View位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">child.layout(l, t, r, b);</span><br></pre></td></tr></table></figure>

<p>四个参数分别为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>对应的函数</th>
</tr>
</thead>
<tbody><tr>
<td>l</td>
<td>View左侧距父View左侧的距离</td>
<td>getLeft();</td>
</tr>
<tr>
<td>t</td>
<td>View顶部距父View顶部的距离</td>
<td>getTop();</td>
</tr>
<tr>
<td>r</td>
<td>View右侧距父View左侧的距离</td>
<td>getRight();</td>
</tr>
<tr>
<td>b</td>
<td>View底部距父View顶部的距离</td>
<td>getBottom();</td>
</tr>
</tbody></table>
<p><img src="/2020/03/23/androidviewpro1/C:%5CUsers%5Ctao%5CDesktop%5Cgithubpage%5Cblog%5Csource_posts%5Candroidviewpro1%5C392e6a7067.jpg" alt></p>
<h5 id="Draw-绘制"><a href="#Draw-绘制" class="headerlink" title="Draw(绘制)"></a>Draw(绘制)</h5><p>onDraw是实际绘制的部分，也就是我们真正关心的部分，使用的是Canvas绘图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">    <span class="comment">//我们可以通过canvas.drawxxx 的方法在画布上绘制你想要的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义View-ViewGroup"><a href="#自定义View-ViewGroup" class="headerlink" title="自定义View,ViewGroup"></a>自定义View,ViewGroup</h4><p>我们在实现自定义view的时候，大部分都是extends View，或者ViewGroup</p>
<h5 id="1-自定义ViewGroup"><a href="#1-自定义ViewGroup" class="headerlink" title="1.自定义ViewGroup"></a>1.自定义ViewGroup</h5><p>自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或各种Layout，包含有子View。</p>
<blockquote>
<p>例如：应用底部导航条中的条目，一般都是上面图标(ImageView)，下面文字(TextView)，那么这两个就可以用自定义ViewGroup组合成为一个Veiw，提供两个属性分别用来设置文字和图片，使用起来会更加方便。</p>
</blockquote>
<h5 id="2-自定义View"><a href="#2-自定义View" class="headerlink" title="2.自定义View"></a>2.自定义View</h5><p>在没有现成的View，需要自己实现的时候，就使用自定义View，一般继承自View，SurfaceView或其他的View，不包含子View。</p>
<blockquote>
<p>例如：制作一个支持自动加载网络图片的ImageView，制作图表等。</p>
</blockquote>
<p>自定义View在大多数情况下都有替代方案，利用图片或者组合动画来实现，但是使用后者可能会面临内存耗费过大，制作麻烦等诸多问题。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SloopView</span><span class="params">(Context context)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SloopView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SloopView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SloopView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>代码创建实例会用第一个构造</p>
<p>xml创建会调用二个构造</p>
<p>后两个构造函数可以接受默认的属性/样式</p>
<h5 id="onSizeChanged"><a href="#onSizeChanged" class="headerlink" title="onSizeChanged"></a>onSizeChanged</h5><p>View的大小不仅由View本身控制，而且受父控件的影响，所以我们在确定View大小的时候最好使用系统提供的onSizeChanged回调函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;                </span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，它又四个参数，分别为 宽度，高度，上一次宽度，上一次高度。</p>
<p>这个函数比较简单，<strong>我们只需关注 宽度(w), 高度(h) 即可，这两个参数就是View最终的大小。</strong></p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><table>
<thead>
<tr>
<th align="center">步骤</th>
<th>关键字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>构造函数</td>
<td>初始化(初始化画笔Paint)</td>
</tr>
<tr>
<td align="center">2</td>
<td>onMeasure</td>
<td>测量View的大小(暂时不用关心)</td>
</tr>
<tr>
<td align="center">3</td>
<td>onSizeChanged</td>
<td>确定View大小(记录当前View的宽高)</td>
</tr>
<tr>
<td align="center">4</td>
<td>onLayout</td>
<td>确定子View布局(无子View，不关心)</td>
</tr>
<tr>
<td align="center">5</td>
<td>onDraw</td>
<td>实际绘制内容(绘制饼状图)</td>
</tr>
<tr>
<td align="center">6</td>
<td>提供接口</td>
<td>提供接口(提供设置数据的接口)</td>
</tr>
</tbody></table>
<p><strong>Tips：</strong></p>
<p>1.View 控件不被ViewGroup包裹的话 它是没有大小的</p>
<p>2.dispatchDraw() 会通知每一个子view 进行绘制 调用draw 方法</p>
<p>3.requestLayout(); 会进行重新的布局</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 颜色</title>
    <url>/2020/03/23/androidviewbase3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>简要介绍安卓中的颜色相关内容，包括颜色的定义，创建颜色的几种方式，以及颜色的混合模式等</p>
<a id="more"></a>

<h4 id="颜色模式"><a href="#颜色模式" class="headerlink" title="颜色模式"></a>颜色模式</h4><table>
<thead>
<tr>
<th align="left">颜色模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ARGB8888</td>
<td>四通道高精度(32位)</td>
</tr>
<tr>
<td align="left">ARGB4444</td>
<td>四通道低精度(16位)</td>
</tr>
<tr>
<td align="left">RGB565</td>
<td><strong>屏幕默认模式</strong>(16位)</td>
</tr>
<tr>
<td align="left">Alpha8</td>
<td>仅有透明通道(8位)</td>
</tr>
</tbody></table>
<h4 id="颜色定义"><a href="#颜色定义" class="headerlink" title="颜色定义"></a>颜色定义</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">解释</th>
<th align="left">0(0x00)</th>
<th align="left">255(0xff)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A(Alpha)</td>
<td align="left">透明度</td>
<td align="left">透明</td>
<td align="left">不透明</td>
</tr>
<tr>
<td align="left">R(Red)</td>
<td align="left">红色</td>
<td align="left">无色</td>
<td align="left">红色</td>
</tr>
<tr>
<td align="left">G(Green)</td>
<td align="left">绿色</td>
<td align="left">无色</td>
<td align="left">绿色</td>
</tr>
<tr>
<td align="left">B(Blue)</td>
<td align="left">蓝色</td>
<td align="left">无色</td>
<td align="left">蓝色</td>
</tr>
</tbody></table>
<h4 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h4><p>A从0x00到0xff表示从透明到不透明。</p>
<p>RGB 从0x00到0xff表示颜色从浅到深。</p>
<p><strong>当RGB全取最小值(0或0x000000)时颜色为黑色，全取最大值(255或0xffffff)时颜色为白色</strong></p>
<h4 id="创建及使用"><a href="#创建及使用" class="headerlink" title="创建及使用"></a>创建及使用</h4><p><strong>1.java中定义颜色</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> color = Color.GRAY;     <span class="comment">//灰色</span></span><br></pre></td></tr></table></figure>

<p>由于Color类提供的颜色仅为有限的几个，通常还是用ARGB值进行表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> color = Color.argb(<span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">//半透明红色</span></span><br><span class="line"><span class="keyword">int</span> color = <span class="number">0xaaff0000</span>;                   <span class="comment">//带有透明度的红色</span></span><br></pre></td></tr></table></figure>

<p><strong>2.在xml文件中定义颜色</strong></p>
<p>在/res/values/color.xml 文件中如下定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"red"</span>&gt;</span>#ff0000<span class="tag">&lt;/<span class="name">color</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">"green"</span>&gt;</span>#00ff00<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>详解：</strong> 在以上xml文件中定义了两个颜色，红色和蓝色，是没有alpha（透明）通道的。</p>
<p>定义颜色以‘#’开头，后面跟十六进制的值，有如下几种定义方式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#f00            //低精度 - 不带透明通道红色</span><br><span class="line">#af00           //低精度 - 带透明通道红色</span><br><span class="line">#ff0000         //高精度 - 不带透明通道红色</span><br><span class="line">#aaff0000       //高精度 - 带透明通道红色</span><br></pre></td></tr></table></figure>

<p><strong>3.在java文件中引用xml中定义的颜色：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> color = getResources().getColor(R.color.mycolor);    </span><br><span class="line"><span class="keyword">int</span> color = getColor(R.color.myColor);    <span class="comment">//API 23 及以上支持该方法</span></span><br></pre></td></tr></table></figure>

<p><strong>4.在xml文件(layout或style)中引用或者创建颜色</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在style文件中引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"colorPrimary"</span>&gt;</span>@color/red<span class="tag">&lt;/<span class="name">item</span>&gt;</span>    </span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">android:background=<span class="string">"@color/red"</span>   <span class="comment">//引用在/res/values/color.xml 中定义的颜色</span></span><br><span class="line">android:background=<span class="string">"#ff0000"</span>      <span class="comment">//创建并使用颜色</span></span><br></pre></td></tr></table></figure>

<h4 id="颜色混合模式"><a href="#颜色混合模式" class="headerlink" title="颜色混合模式"></a>颜色混合模式</h4><p>因为我们的显示屏是没法透明的，因此最终显示在屏幕上的颜色里可以认为没有Alpha通道。Alpha通道主要在两个图像混合的时候生效。</p>
<p>默认情况下，当一个颜色绘制到Canvas上时的混合模式是这样计算的：</p>
<blockquote>
<p><strong>(RGB通道) 最终颜色 = 绘制的颜色 + (1 - 绘制颜色的透明度) × Canvas上的原有颜色。</strong></p>
</blockquote>
<p><strong>注意：</strong></p>
<p>1.这里我们一般把每个通道的取值从0(0x00)到255(0xff)映射到0到1的浮点数表示。</p>
<p>2.这里等式右边的“绘制的颜色”、“Canvas上的原有颜色”都是经过预乘了自己的Alpha通道的值。如绘制颜色：0x88ffffff，那么参与运算时的每个颜色通道的值不是1.0，而是(1.0 * 0.5333 = 0.5333)。 (其中0.5333 = 0x88/0xff)</p>
<p>使用这种方式的混合，就会造成后绘制的内容以半透明的方式叠在上面的视觉效果。</p>
<p>还有不同的混合模式供我们选择，用Paint.setXfermode，指定不同的PorterDuff.Mode。</p>
<p>下表是各个PorterDuff模式的混合计算公式:</p>
<p>(D指原本在Canvas上的内容dst, S指绘制输入的内容src, a指alpha通道, c指RGB各个通道)</p>
<table>
<thead>
<tr>
<th>混合模式</th>
<th>计算公式</th>
</tr>
</thead>
<tbody><tr>
<td>ADD</td>
<td>Saturate(S + D)</td>
</tr>
<tr>
<td>CLEAR</td>
<td>[0, 0]</td>
</tr>
<tr>
<td>DARKEN</td>
<td>[Sa + Da - Sa<em>Da, Sc</em>(1 - Da) + Dc*(1 - Sa) + min(Sc, Dc)]</td>
</tr>
<tr>
<td>DST</td>
<td>[Da, Dc]</td>
</tr>
<tr>
<td>DST_ATOP</td>
<td>[Sa, Sa * Dc + Sc * (1 - Da)]</td>
</tr>
<tr>
<td>DST_IN</td>
<td>[Sa * Da, Sa * Dc]</td>
</tr>
<tr>
<td>DST_OUT</td>
<td>[Da * (1 - Sa), Dc * (1 - Sa)]</td>
</tr>
<tr>
<td>DST_OVER</td>
<td>[Sa + (1 - Sa)<em>Da, Rc = Dc + (1 - Da)</em>Sc]</td>
</tr>
<tr>
<td>LIGHTEN</td>
<td>[Sa + Da - Sa<em>Da, Sc</em>(1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]</td>
</tr>
<tr>
<td>MULTIPLY</td>
<td>[Sa * Da, Sc * Dc]</td>
</tr>
<tr>
<td>SCREEN</td>
<td>[Sa + Da - Sa * Da, Sc + Dc - Sc * Dc]</td>
</tr>
<tr>
<td>SRC</td>
<td>[Sa, Sc]</td>
</tr>
<tr>
<td>SRC_ATOP</td>
<td>[Da, Sc * Da + (1 - Sa) * Dc]</td>
</tr>
<tr>
<td>SRC_IN</td>
<td>[Sa * Da, Sc * Da]</td>
</tr>
<tr>
<td>SRC_OUT</td>
<td>[Sa * (1 - Da), Sc * (1 - Da)]</td>
</tr>
<tr>
<td>SRC_OVER</td>
<td>[Sa + (1 - Sa)<em>Da, Rc = Sc + (1 - Sa)</em>Dc]</td>
</tr>
<tr>
<td>XOR</td>
<td>[Sa + Da - 2 * Sa * Da, Sc * (1 - Da) + (1 - Sa) * Dc]</td>
</tr>
</tbody></table>
<p>用示例图来查看使用不同模式时的混合效果如下</p>
<p>(src表示输入的图，dst表示原Canvas上的内容):</p>
<p><img src="/2020/03/23/androidviewbase3/7342e6a7067.jpg" alt></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>color</tag>
        <tag>颜色</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 角度/弧度</title>
    <url>/2020/03/23/androidviewbase2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>估计很多人早把角度与弧度的知识还给了初中老师. 不过在android中实现一些效果的时候，在进行一些计算的时候需要用到, 在这帮大家复习一下.</p>
<a id="more"></a>

<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><table>
<thead>
<tr>
<th align="center">名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">角度</td>
<td>两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。<strong>当这段弧长正好等于圆周长的360分之一时，两条射线的夹角的大小为1度.</strong></td>
</tr>
<tr>
<td align="center">弧度</td>
<td>两条射线从圆心向圆周射出，形成一个夹角和夹角正对的一段弧。<strong>当这段弧长正好等于圆的半径时，两条射线的夹角大小为1弧度.</strong></td>
</tr>
</tbody></table>
<h4 id="角度和弧度的换算关系"><a href="#角度和弧度的换算关系" class="headerlink" title="角度和弧度的换算关系"></a>角度和弧度的换算关系</h4><p>圆一周对应的角度为360度(角度)，对应的弧度为2π弧度</p>
<p>360(角度) = 2π(弧度) ==&gt; 180(角度) = π(弧度)</p>
<p><strong>rad 是弧度</strong><br><strong>deg 是角度</strong></p>
<table>
<thead>
<tr>
<th>公式</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><strong>rad = deg x π / 180</strong></td>
<td>2π ＝ 360 x π / 180</td>
</tr>
<tr>
<td><strong>deg = rad x 180 / π</strong></td>
<td>360 ＝ 2π x 180 / π</td>
</tr>
</tbody></table>
<h4 id="Android-角度"><a href="#Android-角度" class="headerlink" title="Android 角度"></a>Android 角度</h4><p><strong>在常见的数学坐标系中角度增大方向为逆时针</strong></p>
<p><strong>在默认的屏幕坐标系中角度增大方向为顺时针</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>角度</tag>
        <tag>弧度</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 坐标系</title>
    <url>/2020/03/23/androidviewbase1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>坐标系的应用主要在二维平面确定一个点的位置，android中的坐标系与传统数学中的坐标系有所不同，Y轴方向相反，如果所示，坐标（1，1）的区别.</p>
<a id="more"></a>

<p><img src="/2020/03/23/androidviewbase1/20200323144951.png" alt></p>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p><strong>绝对定位：</strong> 相对于屏幕的位置</p>
<p><strong>相对定位：</strong> 相对于控件的位置</p>
<p><strong>涉及方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MotionEvent</span></span><br><span class="line"></span><br><span class="line"> event.getRawX();    <span class="comment">//触摸点相对于屏幕默认坐标系的坐标</span></span><br><span class="line"> event.getRawY();</span><br><span class="line"></span><br><span class="line"> event.getX();       <span class="comment">//触摸点相对于其所在组件坐标系的坐标</span></span><br><span class="line"> event.getY();</span><br></pre></td></tr></table></figure>

<p><img src="/2020/03/23/androidviewbase1/vies3r.png" alt></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>坐标系</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Launcher 简析</title>
    <url>/2020/03/22/androidlauncher/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Launcher 是 Android桌面项目, 市面上第三方的桌面App也比较常见. 做过一段时间的开发, 上手时感觉涉及的代码量和逻辑都比较多, 上手的时候确实有点吃力, 趁着这短时间疫情放假， 给有需要的同学简单梳理一下.  都是通过伪代码讲解,  主要理清逻辑，</p>
<a id="more"></a>

<h4 id="一-数据初始化流程"><a href="#一-数据初始化流程" class="headerlink" title="一 数据初始化流程"></a>一 数据初始化流程</h4><p>数据的初始化是在LauncherProvider中初始化的，Provider组件和清单中的Broadcast组件都会在程序安装完成之后自动被系统创建，无论app是否运行，所以通过Provider进行数据的初始化，代码查看流程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LauncherProvider.onCreate()</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">DatabaseHelper.onCreate();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatabaseHelper-&gt;onCreate() <span class="comment">//数据库的创建以及数据的初始化</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatabaseHelper-&gt; onCreate()-&gt;LoadDefaultData() <span class="comment">//加载默认的数据</span></span><br><span class="line"></span><br><span class="line">-&gt;addFavorite()</span><br><span class="line"><span class="comment">//初始化桌面需要展示的应用/文件夹/插件数据存到数据库(xml文件夹中的default_workspace.xml中配置)</span></span><br><span class="line">-&gt;addRecommendApp()</span><br><span class="line"><span class="comment">//初始化应用抽屉需要展示的数据到数据库(带launch标签的activity)</span></span><br></pre></td></tr></table></figure>

<h4 id="二-数据加载流程"><a href="#二-数据加载流程" class="headerlink" title="二 数据加载流程"></a>二 数据加载流程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LauncherActivity.onCreate()</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">LauncherMode.startLoader() -&gt;  <span class="comment">//加载数据库数据</span></span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line">bindApps();    <span class="comment">//回调launcher展示数据</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LauncherModel extends BroadcastReceiver <span class="comment">//用来监听系统程序安装/卸载变化</span></span><br></pre></td></tr></table></figure>

<h4 id="三-UI-和-拖拽"><a href="#三-UI-和-拖拽" class="headerlink" title="三 UI 和 拖拽"></a>三 UI 和 拖拽</h4><p>Launcher中基本都是自定义控件，并且对于触摸事件的处理也是比较复杂的，主要的View</p>
<p>1.DragLayer  根布局，拦截拖拽事件</p>
<p>2.Workspace   桌面工作空间</p>
<p>3.BottomWidgetView  长按桌面弹出的添加插件的界面</p>
<p>4.Hotseat  用来放置常用软件</p>
<p>5.Indicator 页面指示器</p>
<p>拖拽需要了解两个类， DragLayer 和 DragController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launcher.setUpViews() &#x2F;&#x2F;初始化view的方法</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    draglayer.init(this, dragcontroller);</span><br><span class="line">    &#x2F;&#x2F;把dragcontroller传递给draglayer</span><br><span class="line">    &#x2F;&#x2F;dragcontroller中的interceptevent&#x2F;ontouchevent </span><br><span class="line">    &#x2F;&#x2F;都是调用dragcontroller方法</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launcher.onLongClick() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mWorkspace.startDrag()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;会走到</span><br><span class="line">mDragController.startDrag(xx);</span><br><span class="line">&#x2F;&#x2F;draglayer.oninterceptEvent(return mDragController.oninterceptEvent)</span><br><span class="line">&#x2F;&#x2F;dragLayer开始拦截事件交由Dragcontroller处理</span><br><span class="line">&#x2F;&#x2F;dragcontroller回调实现了DragListener的view,进行拖拽事件的分发</span><br></pre></td></tr></table></figure>



<p>只做了一些大体的讲解，如需深层次的挖掘，还需在之以上的模块中仔细研读，以上！</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>launcher</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 模拟器运行Automotive系统</title>
    <url>/2020/03/20/androidautomotiverun/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Google官方目前支持的平台，phone，pad，wear，car…等</p>
<p>这篇博客主要讲解如何通过avd运行汽车模拟器, 测试你开发的车载应用</p>
<a id="more"></a>

<h4 id="官方教程地址："><a href="#官方教程地址：" class="headerlink" title="官方教程地址："></a>官方教程地址：</h4><p><a href="https://developer.android.com/training/cars" target="_blank" rel="noopener">https://developer.android.com/training/cars</a></p>
<h4 id="添加系统映像："><a href="#添加系统映像：" class="headerlink" title="添加系统映像："></a>添加系统映像：</h4><p>1.在 Android Studio 中，依次选择 Tools &gt; SDK Manager。<br>2.点击 SDK Update Sites 标签。<br>3.点击 Add Add 图标。<br>4.输入以下 Name 和 URL，再点击 OK。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name：Polestar 2 System Image</span><br><span class="line">URL：https:&#x2F;&#x2F;developer.polestar.com&#x2F;sdk&#x2F;polestar2-sys-img.xml</span><br></pre></td></tr></table></figure>

<p>5.点击 Apply，然后点击 OK。</p>
<h4 id="创建汽车-AVD-并运行模拟器"><a href="#创建汽车-AVD-并运行模拟器" class="headerlink" title="创建汽车 AVD 并运行模拟器"></a>创建汽车 AVD 并运行模拟器</h4><p>1.在 Android Studio 中，依次选择 Tools &gt; AVD Manager。<br>2.点击 Create Virtual Device。<br>3.在 Select Hardware 对话框中，选择 Automotive，然后选择一个设备并点击 Next。<br>4.选择以 Automotive 为目标的系统映像，如 Android 9.0 (Automotive)，然后点击 Next。<br>5.为您的 AVD 命名，再设置其他要自定义的选项，然后点击 Finish。<br>6.在工具窗口栏中，选择您的 Android Automotive OS AVD 作为部署目标。<br>7.点击 Run</p>
<p><img src="/2020/03/20/androidautomotiverun/20200320185204.png" alt></p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h5 id="1-没有automotive"><a href="#1-没有automotive" class="headerlink" title="1.没有automotive"></a>1.没有automotive</h5><p>升级android studio到3.5以上</p>
<h5 id="2-加载不出system-image"><a href="#2-加载不出system-image" class="headerlink" title="2.加载不出system image"></a>2.加载不出system image</h5><p>创建avd的时候 ，select system image的时候可能加载不出系统镜像</p>
<p>Android Studio &gt;&gt; Preferences &gt;&gt; Appearance &amp; Behavior &gt;&gt; System Settings &gt;&gt; Updates</p>
<p>更改检查更新的方式为：</p>
<p>‘Stable Channel’ -&gt; ‘Canary Channel’.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>automotive</tag>
      </tags>
  </entry>
  <entry>
    <title>AS Gradle常用配置</title>
    <url>/2020/03/19/androidgradleconfig/</url>
    <content><![CDATA[<p>整理一些常用的Android Studio中gradle的配置</p>
<a id="more"></a>

<h4 id="多个Model统一编译环境"><a href="#多个Model统一编译环境" class="headerlink" title="多个Model统一编译环境"></a>多个Model统一编译环境</h4><p>原理很简单,将配置放在一个所有model都可以引用的地方, 在Project的build.gradle添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    &#x2F;&#x2F; global variables definition</span><br><span class="line">    compileSdkVersion &#x3D; 23</span><br><span class="line">    buildToolsVersion &#x3D; &quot;23.0.1&quot;</span><br><span class="line">    minSdkVersion &#x3D; 17</span><br><span class="line">    targetSdkVersion &#x3D; 19</span><br><span class="line">    supportLibVersion &#x3D; &#39;25.0.1&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">        flatDir &#123;</span><br><span class="line">            dirs &#39;libs&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasks.withType(JavaCompile) &#123;</span><br><span class="line">        options.encoding &#x3D; &quot;UTF-8&quot;  &#x2F;&#x2F;统一编码格式</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasks.withType(JavaCompile) &#123;</span><br><span class="line">        sourceCompatibility &#x3D; JavaVersion.VERSION_1_7  &#x2F;&#x2F;统一sdk版本</span><br><span class="line">        targetCompatibility &#x3D; JavaVersion.VERSION_1_7</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Model中引用"><a href="#Model中引用" class="headerlink" title="Model中引用"></a>Model中引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compileSdkVersion rootProject.ext.compileSdkVersion</span><br><span class="line">buildToolsVersion rootProject.ext.buildToolsVersion</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">minSdkVersion rootProject.ext.minSdkVersion </span><br><span class="line">targetSdkVersion rootProject.ext.targetSdkVersion</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</span><br><span class="line">    compile &quot;com.android.support:support-annotations:$&#123;rootProject.ext.supportLibVersion&#125;&quot;</span><br><span class="line">    compile &quot;com.android.support:support-v4:$&#123;rootProject.ext.supportLibVersion&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件制定model的versionName-versionCode"><a href="#文件制定model的versionName-versionCode" class="headerlink" title="文件制定model的versionName/versionCode"></a>文件制定model的versionName/versionCode</h4><p>model的build.gradle同文件夹下创建文件, 命名为version.properties, 内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">versionName &#x3D; 1.0</span><br><span class="line">versionCode &#x3D; 1</span><br><span class="line">model的build.gradle中解析version.properties</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    ext.versionFile &#x3D; file(&#39;version.properties&#39;)</span><br><span class="line">    &#x2F;&#x2F;动态加载配置文件version.properties里面的属性值</span><br><span class="line">    if (!versionFile.exists()) &#123;</span><br><span class="line">        throw new GradleException(&quot;Required version file does not exist:versionFile.canonicalPath&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    Properties versionProps &#x3D; new Properties()</span><br><span class="line">    versionFile.withInputStream &#123;</span><br><span class="line">        stream -&gt; versionProps.load(stream)</span><br><span class="line">    &#125;</span><br><span class="line">    def code &#x3D; versionProps.versionCode.toInteger()</span><br><span class="line">    def name &#x3D; versionProps.versionName</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        versionCode code</span><br><span class="line">        versionName name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改编译后的项目名称-编译后的名称添加versionName-versionCode-以及渠道名称"><a href="#修改编译后的项目名称-编译后的名称添加versionName-versionCode-以及渠道名称" class="headerlink" title="修改编译后的项目名称, 编译后的名称添加versionName,versionCode, 以及渠道名称"></a>修改编译后的项目名称, 编译后的名称添加versionName,versionCode, 以及渠道名称</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Android&#123;</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            def outputFile &#x3D; output.outputFile</span><br><span class="line">            if (outputFile !&#x3D; null &amp;&amp; outputFile.name.endsWith(&#39;.apk&#39;)) &#123;</span><br><span class="line">                if (variant.buildType.name &#x3D;&#x3D; &quot;release&quot;) &#123;</span><br><span class="line">                    fileName &#x3D; &quot;Demo_v$&#123;name&#125;_$&#123;code&#125;_$&#123;variant.productFlavors[0].name&#125;_release_unsign.apk&quot;</span><br><span class="line">                &#125; else if (variant.buildType.name &#x3D;&#x3D; &quot;debug&quot;) &#123;</span><br><span class="line">                    fileName &#x3D; &quot;Demo_v$&#123;name&#125;_$&#123;code&#125;_debug_unsign.apk&quot;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fileName &#x3D; &quot;Demo_v$&#123;name&#125;_$&#123;code&#125;_$&#123;variant.productFlavors[0].name&#125;_test_unsign.apk&quot;</span><br><span class="line">                &#125;</span><br><span class="line">                output.outputFile &#x3D; new File(outputFile.parent, fileName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gradle中配置项目中的debug开关"><a href="#gradle中配置项目中的debug开关" class="headerlink" title="gradle中配置项目中的debug开关"></a>gradle中配置项目中的debug开关</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            &#x2F;&#x2F; hidden Log</span><br><span class="line">            buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot;   &#x2F;&#x2F;项目中可通过BuildConfig.LOG_DEBUG来调用</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自动签名"><a href="#自动签名" class="headerlink" title="自动签名"></a>自动签名</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            storeFile file(&quot;signature&#x2F;system.jks&quot;)  &#x2F;&#x2F;model通文件夹下创建文件夹signature, 放置签名文件</span><br><span class="line">            storePassword &quot;****&quot;</span><br><span class="line">            keyAlias &quot;****&quot;</span><br><span class="line">            keyPassword &quot;*****&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">    debug &#123;</span><br><span class="line">        ...</span><br><span class="line">        signingConfig signingConfigs.release  &#x2F;&#x2F;应用签名的配置</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>流程 : 配置一个签名的配置—&gt; 在buildTypes中使用签名配置, 签名文件可以在签名打包的时候创建, 如果你的签名文件不是jks, 百度一下转换方法即可</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层级划分</title>
    <url>/2020/03/13/wangluocengji/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大多数网络都采用分层的体系结构，每一层都建立在它的下层之上，同时向它的上一层提供一定的服务，而把如何实现这一服务的细节对上一层加以屏蔽。一台设备上的第 n层与另一台设备上的第 n 层进行通信的规则就是第 n 层协议。</p>
<a id="more"></a>

<p><img src="/2020/03/13/wangluocengji/123.png" alt></p>
<h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI:"></a>OSI:</h3><p>Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议:"></a>协议:</h3><p>网络协议是网络上所有设备（网络服务器、计算机及交换机、路由器、防火墙等）之间通信规则的集合，它规定了通信时信息必须采用的格式和这些格式的意义。通过网络协议，网络上各种设备才能够相互交换信息。</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP :"></a>TCP :</h3><p>传输控制协议（Transmission Control Protocol，TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP :"></a>UDP :</h3><p>用户数据报协议（UDP）是 TCP/IP 模型中一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。UDP 协议基本上是 IP 协议与上层协议的接口。UDP 协议适用于端口分别运行在同一台设备上的多个应用程序中。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket:"></a>Socket:</h3><p>TCP 和 UDP 的协议报文里面除了数据本身，还包含了包的目的地址和端口、包的源地址和端口以及其他各种附加的校验信息。这些包的长度是有限的，传输的时候需要将其分解为多个包，在到达传输的目的地址后再组合还原。如包有丢失或者破坏需要重传时，则乱序发送的包在达到时需要重新排序。处理这些过程是一项繁杂的工作，需要大量可靠的代码来完成。为了使程序员不必费心于上述这些底层具体细节，人们通过 Socket 对网络纠错、包大小、包重传等进行了封装。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络层级</tag>
      </tags>
  </entry>
  <entry>
    <title>Request &amp; Response header</title>
    <url>/2020/03/13/requestresponseheader/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>记录头部关键字信息,  方便查询</p>
<a id="more"></a>

<h3 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h3><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text/plain, text/html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes</td>
<td></td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接(HTTP 1.1默认进行持久连接)</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td>
<td>Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: <a href="mailto:user@email.com">user@email.com</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: <a href="http://www.zcmhi.com" target="_blank" rel="noopener">www.zcmhi.com</a></td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes=500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q=0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换(如果支持)</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla/5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<h3 id="Response-Headers"><a href="#Response-Headers" class="headerlink" title="Response Headers"></a>Response Headers</h3><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间(以秒计，非负)</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: /index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021/47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text/html; charset=utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向(由网景提出，被大部分浏览器支持)</td>
<td>Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>request header</tag>
        <tag>response header</tag>
      </tags>
  </entry>
  <entry>
    <title>http/https 协议</title>
    <url>/2020/03/13/httphttpsxieyi/</url>
    <content><![CDATA[<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手:"></a>三次握手:</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；<br>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包<br>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</p>
<a id="more"></a>

<p><img src="httphttpsxieyi/11111111111.png" alt></p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="httphttpsxieyi/22222222222.png" alt></p>
<h4 id="Http请求方法"><a href="#Http请求方法" class="headerlink" title="Http请求方法"></a>Http请求方法</h4><p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式</p>
<ol>
<li><p>OPTIONS<br>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
</li>
<li><p>HEAD<br>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>
</li>
<li><p>GET<br>向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url</p>
</li>
<li><p>POST<br>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p>
</li>
<li><p>PUT<br>向指定资源位置上传其最新内容</p>
</li>
<li><p>DELETE<br>请求服务器删除Request-URL所标识的资源</p>
</li>
<li><p>TRACE<br>回显服务器收到的请求，主要用于测试或诊断</p>
</li>
<li><p>CONNECT<br>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
</li>
</ol>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="httphttpsxieyi/333333333333.png" alt></p>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><p><img src="httphttpsxieyi/4.png" alt></p>
<p><img src="httphttpsxieyi/5.png" alt></p>
<h3 id="https协议"><a href="#https协议" class="headerlink" title="https协议"></a>https协议</h3><p>常基于TCP的连接方式 是HTTP的安全版, HTTPS是与SSL一起使用的, SSL逐渐演变到TLS</p>
<h4 id="与http差异"><a href="#与http差异" class="headerlink" title="与http差异"></a>与http差异</h4><p>1、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>2、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h4 id="五次握手"><a href="#五次握手" class="headerlink" title="五次握手:"></a>五次握手:</h4><p>1 客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端<br>2 服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法<br>以证书的形式返回给客户端 证书中还包含了 公钥 颁证机构 网址 失效日期等等。<br>3 客户端收到服务端响应后会做以下几件事<br>3.1 验证证书的合法性<br>颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等<br>证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)<br>3.2 生成随机密码<br>如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。<br>3.3 HASH握手信息<br>用最开始约定好的HASH方式，把握手消息取HASH值， 然后用 随机数加密 “握手消息+握手消息HASH值(签名)” 并一起发送给服务端<br>在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。</p>
<p>4 服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。<br>然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端</p>
<p>5 客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密<br>因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/03/13/paixusuanfa/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>排序法</th>
<th>最差时间分析</th>
<th>平均时间复杂度</th>
<th>稳定度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n2)</td>
<td>O(n*log2n)</td>
<td>不稳定</td>
<td>O(log2n)~O(n)</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>二叉树排序</td>
<td>O(n2)</td>
<td>O(n*log2n)</td>
<td>不一顶</td>
<td>O(n)</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n2)</td>
<td>O(n2)</td>
<td>稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n*log2n)</td>
<td>O(n*log2n)</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O</td>
<td>O</td>
<td>不稳定</td>
<td>O(1)</td>
</tr>
</tbody></table>
<a id="more"></a>

<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序:"></a>冒泡排序:</h4><p>循环嵌套, 对比相邻两个数, 大的向后移.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp;<span class="comment">//定义一个临时变量</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;<span class="comment">//冒泡趟数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[j+<span class="number">1</span>]&lt;arr[j])&#123;</span><br><span class="line">                   temp = arr[j];</span><br><span class="line">                   arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                   arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序:"></a>选择排序:</h4><p>循环嵌套, 便利出最大的数, 放置后最后.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; list.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[index] &gt; list[j]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = list[index];</span><br><span class="line">        list[index] = list[i];</span><br><span class="line">        list[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序:"></a>插入排序:</h4><p>把一边的数据看成有序, 将数据不断的移动到应该停止的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span>[] unsorted)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; unsorted.Length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unsorted[i - <span class="number">1</span>] &gt; unsorted[i]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = unsorted[i];</span><br><span class="line">                    <span class="keyword">int</span> j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; unsorted[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                        unsorted[j] = unsorted[j - <span class="number">1</span>];</span><br><span class="line">                        j--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    unsorted[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序:"></a>快速排序:</h4><p>选择一个中间值, 移动角标的方式,大的右移小的左移, 递归进行排序.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key=array[lo];</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">            <span class="keyword">while</span>(array[hi] &gt;= key &amp;&amp; hi &gt; lo) &#123;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[lo]=array[hi];</span><br><span class="line">            <span class="keyword">while</span>(array[lo] &lt;= key &amp;&amp; hi &gt; lo) &#123;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125;</span><br><span class="line">            array[hi]=array[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        array[hi]=key;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树排序"><a href="#二叉树排序" class="headerlink" title="二叉树排序:"></a>二叉树排序:</h4><p><a href="http://blog.csdn.net/u010853261/article/details/54174609" target="_blank" rel="noopener">http://blog.csdn.net/u010853261/article/details/54174609</a></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序:"></a>堆排序:</h4><p><a href="http://blog.csdn.net/kimylrong/article/details/17150475" target="_blank" rel="noopener">http://blog.csdn.net/kimylrong/article/details/17150475</a></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序:"></a>希尔排序:</h4><p><a href="http://blog.csdn.net/jianyuerensheng/article/details/51258460" target="_blank" rel="noopener">http://blog.csdn.net/jianyuerensheng/article/details/51258460</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2020/03/13/shijianfuzadu/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算法很重要，但是一般情况下做移动开发并不经常用到，所以很多同学早就将算法打了个大礼包送还给了老师了，况且很多同学并没有学习过算法。这个系列就让对算法头疼的同学能快速的掌握基本的算法。过年放假阶段玩了会游戏NBA2K17的生涯模式，没有比赛的日子也都是训练，而且这些训练都是自发的，没有人逼你，从早上练到晚上，属性也不涨，但是如果日积月累，不训练和训练的人的属性值就会产生较大差距。这个突然让我意识到了现实世界，要想成为一个球星（技术大牛）那就需要日积月累的刻意训练，索性放下游戏，接着写文章吧。</p>
<a id="more"></a>

<h3 id="1-算法的效率"><a href="#1-算法的效率" class="headerlink" title="1.算法的效率"></a>1.算法的效率</h3><p>虽然计算机能快速的完成运算处理，但实际上，它也需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。<br>算法的效率主要由以下两个复杂度来评估：</p>
<p><strong>时间复杂度</strong>：评估执行程序所需的时间。可以估算出程序对处理器的使用程度<br><strong>空间复杂度</strong>：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度</p>
<p>设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，复杂度就是指时间复杂度。</p>
<h3 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h3><h4 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h4><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>前面提到的时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。</p>
<h3 id="3-大O表示法"><a href="#3-大O表示法" class="headerlink" title="3.大O表示法"></a>3.大O表示法</h3><p>像前面用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。<br>算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度，而大O表示法O(f(n)就是指出了算法最坏情况下的运行时间。<br>大O表示法O(f(n)中的f(n)的值可以为1、n、logn、n²等，因此我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。</p>
<h4 id="推导大O阶"><a href="#推导大O阶" class="headerlink" title="推导大O阶"></a>推导大O阶</h4><p>推导大O阶，我们可以按照如下的规则来进行推导，得到的结果就是大O表示法：<br>1.用常数1来取代运行时间中所有加法常数。<br>2.修改后的运行次数函数中，只保留最高阶项<br>3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。</p>
<p>在前面大O表示法的语言描述可能有些晦涩难懂，这里用通俗的语言来说，</p>
<h4 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h4><p>先举了例子，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>,n = <span class="number">100</span>; <span class="comment">//执行一次</span></span><br><span class="line">sum = (<span class="number">1</span>+n)*n/<span class="number">2</span>; <span class="comment">//执行一次</span></span><br><span class="line">System.out.println (sum); <span class="comment">//执行一次</span></span><br></pre></td></tr></table></figure>

<p>上面算法的运行的次数的函数为f(n)=3，根据推导大O阶的规则1，我们需要将常数3改为1，则这个算法的时间复杂度为O(1)。如果sum = （1+n）*n/2这条语句再执行10遍，因为这与问题大小n的值并没有关系，所以这个算法的时间复杂度仍旧是O(1)，我们可以称之为常数阶。</p>
<h4 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h4><p>线性阶主要要分析循环结构的运行情况，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//时间复杂度为O(1)的算法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面算法循环体中的代码执行了n次，因此时间复杂度为O(n)。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><p>接着看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(number&lt;n)&#123;</span><br><span class="line">number=number*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//时间复杂度为O(1)的算法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。</p>
<h4 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h4><p>下面的代码是循环嵌套：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;i++)&#123;</span><br><span class="line">       <span class="comment">//复杂度为O(1)的算法</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内层循环的时间复杂度在讲到线性阶时就已经得知是O(n)，现在经过外层循环n次，那么这段算法的时间复杂度则为O(n²)。<br>接下来我们来算一下下面算法的时间复杂度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;i++)&#123;</span><br><span class="line">       <span class="comment">//复杂度为O(1)的算法</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是内循环中int j=i，而不是int j=0。当i=0时，内循环执行了n次；i=1时内循环执行了n-1次，当i=n-1时执行了1次，我们可以推算出总的执行次数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n+(n-<span class="number">1</span>)+(n-<span class="number">2</span>)+(n-<span class="number">3</span>)+……+<span class="number">1</span></span><br><span class="line">=(n+<span class="number">1</span>)+[(n-<span class="number">1</span>)+<span class="number">2</span>]+[(n-<span class="number">2</span>)+<span class="number">3</span>]+[(n-<span class="number">3</span>)+<span class="number">4</span>]+……</span><br><span class="line">=(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+(n+<span class="number">1</span>)+……</span><br><span class="line">=(n+<span class="number">1</span>)n/<span class="number">2</span></span><br><span class="line">=n(n+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">=n²/<span class="number">2</span>+n/<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>根据此前讲过的推导大O阶的规则的第二条：只保留最高阶，因此保留n²/2。根据第三条去掉和这个项的常数，则去掉1/2,最终这段代码的时间复杂度为O(n²)。</p>
<h4 id="其他常见复杂度"><a href="#其他常见复杂度" class="headerlink" title="其他常见复杂度"></a>其他常见复杂度</h4><p>除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度：<br>f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。<br>f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。<br>f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。<br>f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。<br>f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。</p>
<h3 id="4-复杂度的比较"><a href="#4-复杂度的比较" class="headerlink" title="4.复杂度的比较"></a>4.复杂度的比较</h3><p>下面将算法中常见的f(n)值根据几种典型的数量级来列成一张表，根据这种表，我们来看看各种算法复杂度的差异。</p>
<table>
<thead>
<tr>
<th>n</th>
<th>logn</th>
<th>√n</th>
<th>nlogn</th>
<th>n²</th>
<th>2ⁿ</th>
<th>n!</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>2</td>
<td>2</td>
<td>10</td>
<td>25</td>
<td>32</td>
<td>120</td>
</tr>
<tr>
<td>10</td>
<td>3</td>
<td>3</td>
<td>30</td>
<td>100</td>
<td>1024</td>
<td>3628800</td>
</tr>
<tr>
<td>50</td>
<td>5</td>
<td>7</td>
<td>250</td>
<td>2500</td>
<td>约10^15</td>
<td>约3.0*10^64</td>
</tr>
<tr>
<td>100</td>
<td>6</td>
<td>10</td>
<td>600</td>
<td>10000</td>
<td>约10^30</td>
<td>约9.3*10^157</td>
</tr>
<tr>
<td>1000</td>
<td>9</td>
<td>31</td>
<td>9000</td>
<td>1000 000</td>
<td>约10^300</td>
<td>约4.0*10^2567</td>
</tr>
</tbody></table>
<p>从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。</p>
<h4 id="下面给出一个更加直观的图："><a href="#下面给出一个更加直观的图：" class="headerlink" title="下面给出一个更加直观的图："></a>下面给出一个更加直观的图：</h4><p><img src="/2020/03/13/shijianfuzadu/vmzzfo.png" alt></p>
<p>其中x轴代表n值，y轴代表T(n)值（时间复杂度）。T(n)值随着n的值的变化而变化，其中可以看出O(n!)和O(2ⁿ)随着n值的增大，它们的T(n)值上升幅度非常大，而O(logn)、O(n)、O(nlogn)随着n值的增大，T(n)值上升幅度则很小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">O(<span class="number">1</span>)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(<span class="number">2</span>ⁿ)&lt;O(n!)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构简述</title>
    <url>/2020/03/13/datastructureintr/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>数据在存储设备中的组织形式。<br>在开发过程中针对不同的业务逻辑以及数据特典选择更高效的数据结构<br>本文只是进行概念性简述, 未避免篇幅过长没有进行更深层的表述.</p>
<a id="more"></a>

<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>内存空间中连续的内存地址, 查找快, 增删慢(需要内存移动).</p>
<p><img src="/2020/03/13/datastructureintr/CEMWmOQpNIzTFfj.png" alt></p>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>以头Node开始, 每个Node指向下一个Node. 查询慢, 增删快(只需要修改指针)</p>
<p><img src="/2020/03/13/datastructureintr/RFrdMIfwiDvCNEl.png" alt></p>
<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>与单向链表不同, 两个元素键互相持有对方内存地址的指针. 查询慢, 增删快(只需要修改指针)</p>
<p><img src="/2020/03/13/datastructureintr/DGgdeBF8fqPNC3t.png" alt></p>
<h4 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h4><p>与双向列表不同, 头尾之间也会相互持有指针. 查询慢, 增删快(只需要修改指针)</p>
<p><img src="/2020/03/13/datastructureintr/YiNIwfGPcxdlnue.png" alt></p>
<h4 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈 stack"></a>栈 stack</h4><p>(01) 栈中数据是按照”后进先出（LIFO, Last In First Out）”方式进出栈的。<br>(02) 向栈中添加/删除数据时，只能从栈顶进行操作。</p>
<p><img src="/2020/03/13/datastructureintr/szQLtMwyR7n45gS.png" alt></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>(1) 队列中数据是按照”先进先出（FIFO, First-In-First-Out）”方式进出队列的。<br>(2) 队列只允许在”队首”进行删除操作，而在”队尾”进行插入操作。 队列通常包括的两种操作：入队列 和 出队列。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。</p>
<p><img src="/2020/03/13/datastructureintr/687474703a2f2f696d616765732e636e6974626c6f672e636f6d2f692f3439373633342f3230313430332f3237303932393139343231313631302e6a7067.jpg" alt></p>
<p>把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：<br>(01) 每个节点有零个或多个子节点；<br>(02) 没有父节点的节点称为根节点；<br>(03) 每一个非根节点有且只有一个父节点；<br>(04) 除了根节点外，每个子节点可以分为多个不相交的子树。</p>
<h5 id="术语"><a href="#术语" class="headerlink" title="术语:"></a>术语:</h5><p>结点的度：结点拥有的子树的数目。<br>叶子：度为零的结点。<br>分支结点：度不为零的结点。<br>树的度：树中结点的最大的度。<br>层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。<br>树的高度：树中结点的最大层次。<br>无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。<br>有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。<br>森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。<br>种类: 满二叉树, 完全二叉树, 平衡树, 红黑树, b树, avl树, 哈夫曼树</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。<br>无向图</p>
<p><img src="/2020/03/13/datastructureintr/01.jpg" alt></p>
<h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p><img src="/2020/03/13/datastructureintr/02.jpg" alt></p>
<p>路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。<br>路径长度：路径中”边的数量”。<br>简单路径：若一条路径上顶点不重复出现，则是简单路径。<br>回路：若路径的第一个顶点和最后一个顶点相同，则是回路。<br>简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。</p>
<h4 id="散列数组-hash表"><a href="#散列数组-hash表" class="headerlink" title="散列数组(hash表)"></a>散列数组(hash表)</h4><p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。<br>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p>
<h5 id="使用哈希查找有两个步骤"><a href="#使用哈希查找有两个步骤" class="headerlink" title="使用哈希查找有两个步骤:"></a>使用哈希查找有两个步骤:</h5><p>使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突<br>处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。<br>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 侵入式状态栏</title>
    <url>/2020/03/12/androidtaskbar/</url>
    <content><![CDATA[<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>1) 为Window添加一个flag, 让状态栏变成透明 , 注意4.4之后才支持的</p>
<p>Activity的Theme中添加.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;item name&#x3D;&quot;android:windowTranslucentStatus&quot;&gt;true&lt;&#x2F;item&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>或者代码中添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) 设置支持的Toolbar, Toolbar就会在屏幕最顶端开始显示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">setSupportActionBar(toolbar);</span><br></pre></td></tr></table></figure>

<p>ps: 一个状态栏修改的开源框架 <a href="https://github.com/jgilfelt/SystemBarTint" target="_blank" rel="noopener">https://github.com/jgilfelt/SystemBarTint</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>状态栏</tag>
        <tag>taskbar</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Handler</title>
    <url>/2020/03/12/androidhandler/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Handler 相信开发过程中都用到过，大部分都是用来线程间通讯，异步操作避免UI线程阻塞，但是具体的原理没注意过，查询了一些网络上的资料后，整理一下，也希望看到的人能更好的理解</p>
<a id="more"></a>

<h3 id="首先来看一下主要包含的4个类"><a href="#首先来看一下主要包含的4个类" class="headerlink" title="首先来看一下主要包含的4个类"></a>首先来看一下主要包含的4个类</h3><ul>
<li>Message： 消息，用来封装消息数据，由MessageQueue统一列队，终由Handler处理。 </li>
<li>Handler： 负责Message的发送及处理。需要实现回调方法handleMessage(Message msg)。 </li>
<li>MessageQueue： 消息队列，用来存放Handler发送过来的消息，并按照FIFO规则执行。当然，存放Message并非实际意义的保存，而是将Message以链表的方式串联起来的，等待Looper的抽取。 </li>
<li>Looper： 消息泵，不断地从MessageQueue中抽取Message交由handler执行。因此，一个MessageQueue需要一个Looper。</li>
</ul>
<h3 id="再来看一下官方文档的说明"><a href="#再来看一下官方文档的说明" class="headerlink" title="再来看一下官方文档的说明"></a>再来看一下官方文档的说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* A Handler allows you to send and process &#123;@link Message&#125; and Runnable * objects associated with a thread&#39;s &#123;@link MessageQueue&#125;.  Each Handler * instance is associated with a single thread and that thread&#39;s message * queue.  When you create a new Handler, it is bound to the thread &#x2F; * message queue of the thread that is creating it -- from that point on, * it will deliver messages and runnables to that message queue and execute * them as they come out of the message queue. * * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and * runnables to be executed as some point in the future; and (2) to enqueue * an action to be performed on a different thread than your own.</span><br></pre></td></tr></table></figure>

<h3 id="大致意思"><a href="#大致意思" class="headerlink" title="大致意思:"></a>大致意思:</h3><p>Handler 可以让你发送和处理Message和Runnable对象，关联一个线程的MessageQueue，每一个Handler实例只能关联一个Thread和这个Thread的MessageQueue。Handler会被绑定到创建它的Thread/Messagueue上，然后Handler就可以发送Messages和Runnable对象到这个线程的MessageQueue，并且处理从MessageQueue处理它们。</p>
<h3 id="Handler有两个主要的用处"><a href="#Handler有两个主要的用处" class="headerlink" title="Handler有两个主要的用处:"></a>Handler有两个主要的用处:</h3><p>(1) 安排Messages 和 runnable 在未来的某一时刻被执行</p>
<p>(2) 将一个任务插入到其他线程的MessageQueue中去，让其它线程去执行。</p>
<p>其实总结起来无非就几句话： Handler可以发送message和runnable到所在的的Thread的MessageQueue，或者其他Thread的Messagequeue，等待未来的某一时刻去执行。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>handler</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多进程</title>
    <url>/2020/03/12/androidmultipprocess/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>正常情况下,一个apk启动后只会运行在一个进程中,其进程名为AndroidManifest.xml文件中指定的应用包名,所有的基本组件都会在这个进程中运行.但是如果需要将某些组件（如Service、Activity等）运行在单独的进程中,就需要用到Android:process属性了.我们可以为android的基础组件指定process属性来指定它们运行在指定进程中.</p>
<a id="more"></a>

<h3 id="用处"><a href="#用处" class="headerlink" title="用处:"></a>用处:</h3><p>一般来说,Android应用多进程有三个好处.<br>1）我们知道Android系统对每个应用进程的内存占用是有限制的,而且占用内存越大的进程,通常被系统杀死的可能性越大.让一个组件运行在单独的进程中,可以减少主进程所占用的内存,降低被系统杀死的概率.<br>2）如果子进程因为某种原因崩溃了,不会直接导致主程序的崩溃,可以降低我们程序的崩溃率.<br>3）即使主进程退出了,我们的子进程仍然可以继续工作,假设子进程是推送服务,在主进程退出的情况下,仍然能够保证用户可以收到推送消息.</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p>对process属性的设置有两种形式：</p>
<p><strong>第一种</strong>形式如 android:process=”:remote”,以冒号开头,冒号后面的字符串原则上是可以随意指定的.如果我们的包名为“com.example.processtest”,则实际的进程名为“com.example.processtest:remote”.这种设置形式表示该进程为当前应用的私有进程,其他应用的组件不可以和它跑在同一个进程中. </p>
<p><strong>第二种</strong>情况如 android:process=”com.example.processtest.remote”,以小写字母开头,表示运行在一个以这个名字命名的全局进程中,其他应用通过设置相同的ShareUID可以和它跑在同一个进程. </p>
<p>下面通过一个例子来进行一下验证.我们定义两个类：ProcessTestActivity和ProcessTestService,然后在AndroidManifest.xml文件中增加这两个类,并为我们的Service指定一个process属性,代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;manifest xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;     package&#x3D;&quot;com.example.processtest&quot; android:versionCode&#x3D;&quot;1&quot; android:versionName&#x3D;&quot;1.0&quot; &gt;</span><br><span class="line">    &lt;uses-sdk android:minSdkVersion&#x3D;&quot;8&quot; android:targetSdkVersion&#x3D;&quot;19&quot; &gt;</span><br><span class="line">    &lt;application</span><br><span class="line">        android:name&#x3D;&quot;com.example.processtest.MyApplication&quot;</span><br><span class="line">        android:icon&#x3D;&quot;@drawable&#x2F;ic_launcher&quot;</span><br><span class="line">        android:label&#x3D;&quot;@string&#x2F;app_name&quot;&gt;</span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name&#x3D;&quot;.ProcessTestActivity&quot;</span><br><span class="line">            android:label&#x3D;&quot;@string&#x2F;app_name&quot; &gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &gt;</span><br><span class="line">                &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot;&gt;</span><br><span class="line">            &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;&#x2F;activity&gt;</span><br><span class="line">        &lt;service</span><br><span class="line">            android:name&#x3D;&quot;.ProcessTestService&quot;</span><br><span class="line">            android:process&#x3D;&quot;:remote&quot;&gt;</span><br><span class="line">        &lt;&#x2F;service&gt;</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure>

<p>运行代码,通过DDMS进行观察 </p>
<p><img src="/2020/03/12/androidmultipprocess/1111.png" alt></p>
<p>我们可以看到两个进程,名字分别是“com.example.processtest”和“com.example.processtest:remote”,进程ID分别为2722和2739.</p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑:"></a>坑:</h3><p>我们已经开启了应用内多进程,那么,开启多进程是不是只是我们看到的这么简单呢？其实这里面会有一些陷阱,稍微不注意就会陷入其中.我们首先要明确的一点是进程间的内存空间时不可见的.从而,开启多进程后,我们需要面临这样几个问题：<br>1）Application的多次重建.<br>2）静态成员的失效.<br>3）文件共享问题.<br>4）断点调试问题.<br>我们先通过一个简单的例子来看一下第一种情况.<br>Manifest文件如上面提到的,定义了两个类：ProcessTestActivity和ProcessTestService,我们只是在Activity的onCreate方法中直接启动了该Service,同时,我们自定义了自己的Application类.代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">int</span> pid = android.os.Process.myPid();</span><br><span class="line">        Log.d(TAG, <span class="string">"MyApplication onCreate"</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"MyApplication pid is "</span> + pid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_process_test);</span><br><span class="line">        Log.i(TAG, <span class="string">"ProcessTestActivity onCreate"</span>);</span><br><span class="line">        <span class="keyword">this</span>.startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, ProcessTestService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"ProcessTestService onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面这段代码,查看打印信息： </p>
<p><img src="/2020/03/12/androidmultipprocess/22222.png" alt><br>我们发现MyApplication的onCreate方法调用了两次,分别是在启动ProcessTestActivity和ProcessTestService的时候,而且我们发现打印出来的pid也不相同.由于通常会在Application的onCreate方法中做一些全局的初始化操作,它被初始化多次是完全没有必要的.出现这种情况,是由于即使是通过指定process属性启动新进程的情况下,系统也会新建一个独立的虚拟机,自然需要重新初始化一遍Application.那么怎么来解决这个问题呢？<br>我们可以通过在自定义的Application中通过进程名来区分当前是哪个进程,然后单独进行相应的逻辑处理.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">int</span> pid = android.os.Process.myPid();</span><br><span class="line">        Log.d(TAG, <span class="string">"MyApplication onCreate"</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"MyApplication pid is "</span> + pid);</span><br><span class="line">        ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.RunningAppProcessInfo&gt;  runningApps = am.getRunningAppProcesses();</span><br><span class="line">        <span class="keyword">if</span> (runningApps != <span class="keyword">null</span> &amp; !runningApps.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo procInfo : runningApps) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procInfo.pid == pid) &#123;</span><br><span class="line">                     <span class="keyword">if</span> (procInfo.processName.equals(<span class="string">"com.example.processtest"</span>)) &#123;</span><br><span class="line">                         Log.d(TAG, <span class="string">"process name is "</span> + procInfo.processName);</span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (procInfo.processName.equals(<span class="string">"com.example.processtest:remote"</span>)) &#123;</span><br><span class="line">                         Log.d(TAG, <span class="string">"process name is "</span> + procInfo.processName);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后,查看Log信息, </p>
<p><img src="/2020/03/12/androidmultipprocess/33333.png" alt><br>图中可以看出,不同的进程执行了不同的代码逻辑,可以通过这种方式来区分不同的进程需要完成的初始化工作.</p>
<p>下面我们来看第二个问题,将之前定义的Activity和Service的代码进行简单的修改,代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> processFlag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_process_test);</span><br><span class="line">        processFlag = <span class="keyword">true</span>;</span><br><span class="line">        Log.i(TAG, <span class="string">"ProcessTestActivity onCreate"</span>);</span><br><span class="line">        <span class="keyword">this</span>.startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, ProcessTestService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessTestService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"viclee"</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"ProcessTestService onCreate"</span>);</span><br><span class="line">        Log.i(TAG, <span class="string">"ProcessTestActivity.processFlag is "</span> + ProcessTestActivity.processFlag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新执行代码,打印Log  </p>
<p><img src="/2020/03/12/androidmultipprocess/444444444.png" alt><br>从上面的代码和执行结果看,我们在Activity中定义了一个标志processFlag并在onCreate中修改了它的值为true,然后启动Service,但是在Service中读到这个值却为false.按照正常的逻辑,静态变量是可以在应用的所有地方共享的,但是设置了process属性后,产生了两个隔离的内存空间,一个内存空间里值的修改并不会影响到另外一个内存空间.</p>
<p>第三个问题是文件共享问题.多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况.这就可能造成资源的竞争访问,导致诸如数据库损坏、数据丢失等.在多线程的情况下我们有锁机制控制资源的共享,但是在多进程中比较难,虽然有文件锁、排队等机制,但是在Android里很难实现.解决办法就是多进程的时候不并发访问同一个文件,比如子进程涉及到操作数据库,就可以考虑调用主进程进行数据库的操作.</p>
<p>最后是断点调试的问题.调试就是跟踪程序运行过程中的堆栈信息,由于每个进程都有自己独立的内存空间和各自的堆栈,无法实现在不同的进程间调试.不过可以通过下面的方式实现：调试时去掉AndroidManifest.xml中android:process标签,这样保证调试状态下是在同一进程中,堆栈信息是连贯的.待调试完成后,再将标签复原.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>从上面的例子中我们可以看到,android实现应用内多进程并不是简单的设置属性process就可以了,而是会产生很多特殊的问题.像前面提到的,android启动多进程模式后,不仅静态变量会失效,而且类似的如同步锁机制、单例模式也会存在同样的问题.这就需要我们在使用的时候多加注意.而且设置多进程之后,各个进程间就无法直接相互访问数据,只能通过AIDL等进程间通信方式来交换数据.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>设计架构 mvc/mvp/mvvm</title>
    <url>/2020/03/12/mvcmvpmvvmdesign/</url>
    <content><![CDATA[<h3 id="设计架构目的"><a href="#设计架构目的" class="headerlink" title="设计架构目的"></a>设计架构目的</h3><p>通过设计使程序模块化，做到模块内部的高聚合和模块之间的低耦合。这样做的好处是使得程序在开发的过程中，开发人员只需要专注于一点，提高程序开发的效率，并且更容易进行后续的测试以及定位问题。但设计不能违背目的，对于不同量级的工程，具体架构的实现方式必然是不同的，切忌犯为了设计而设计，为了架构而架构的毛病。</p>
<a id="more"></a>

<p><strong>例子：</strong></p>
<p>一个Android App如果只有3个Java文件，那只需要做点模块和层次的划分就可以，引入框架或者架构反而提高了工作量，降低了生产力；</p>
<p>但如果当前开发的App最终代码量在10W行以上，本地需要进行复杂操作，同时也需要考虑到与其余的Android开发者以及后台开发人员之间的同步配合，那就需要在架构上进行一些思考！</p>
<h3 id="MVC设计架构"><a href="#MVC设计架构" class="headerlink" title="MVC设计架构"></a>MVC设计架构</h3><p><img src="/2020/03/12/mvcmvpmvvmdesign/mvc.png" alt></p>
<h4 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h4><p>MVC全名是Model View Controller，如图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>
<p>其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。</p>
<h4 id="Android中的MVC"><a href="#Android中的MVC" class="headerlink" title="Android中的MVC"></a>Android中的MVC</h4><p>Android中界面部分也采用了当前比较流行的MVC框架，在Android中：</p>
<ul>
<li><p>视图层(View)<br>一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。</p>
</li>
<li><p>控制层(Controller)<br>Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。</p>
</li>
<li><p>模型层(Model)<br>我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的（感谢@Xander的讲解）。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。</p>
</li>
</ul>
<h3 id="MVP设计架构"><a href="#MVP设计架构" class="headerlink" title="MVP设计架构"></a>MVP设计架构</h3><p>在App开发过程中，经常出现的问题就是某一部分的代码量过大，虽然做了模块划分和接口隔离，但也很难完全避免。从实践中看到，这更多的出现在UI部分，也就是Activity里。想象一下，一个2000+行以上基本不带注释的Activity，我的第一反应就是想吐。Activity内容过多的原因其实很好解释，因为Activity本身需要担负与用户之间的操作交互，界面的展示，不是单纯的Controller或View。而且现在大部分的Activity还对整个App起到类似IOS中的【ViewController】的作用，这又带入了大量的逻辑代码，造成Activity的臃肿。为了解决这个问题，让我们引入MVP框架。</p>
<h4 id="MVC的缺点"><a href="#MVC的缺点" class="headerlink" title="MVC的缺点"></a>MVC的缺点</h4><p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户 界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。</p>
<h4 id="什么是MVP"><a href="#什么是MVP" class="headerlink" title="什么是MVP"></a>什么是MVP</h4><p>MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p>
<p><img src="/2020/03/12/mvcmvpmvvmdesign/mvp.png" alt></p>
<h4 id="MVP框架由3部分组成："><a href="#MVP框架由3部分组成：" class="headerlink" title="MVP框架由3部分组成："></a>MVP框架由3部分组成：</h4><p>View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素(加上View interface是4个):</p>
<ul>
<li><p>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) </p>
</li>
<li><p>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) </p>
</li>
<li><p>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑</p>
</li>
<li><p>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试<br>Tips：*View interface的必要性</p>
</li>
</ul>
<p>回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用 户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。</p>
<h3 id="MVC-→-MVP"><a href="#MVC-→-MVP" class="headerlink" title="MVC → MVP"></a>MVC → MVP</h3><p>当我们将Activity复杂的逻辑处理移至另外的一个类（Presenter）中时，Activity其实就是MVP模式中的View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由 Presenter处理）。</p>
<p>MVP的Presenter是框架的控制者，承担了大量的逻辑操作，而MVC的Controller更多时候承担一种转发的作用。因此在App中引入MVP的原因，是为了将此前在Activty中包含的大量逻辑操作放到控制层中，避免Activity的臃肿。</p>
<h4 id="两种模式的主要区别："><a href="#两种模式的主要区别：" class="headerlink" title="两种模式的主要区别："></a>两种模式的主要区别：</h4><p>（最主要区别）View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互<br>通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个View<br>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试。</p>
<p><img src="/2020/03/12/mvcmvpmvvmdesign/mvcp.jpg" alt></p>
<p>因此我们可以发现MVP的优点如下：</p>
<ul>
<li><p>模型与视图完全分离，我们可以修改视图而不影响模型；</p>
</li>
<li><p>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；</p>
</li>
<li><p>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；</p>
</li>
<li><p>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。</p>
</li>
</ul>
<p>具体到Android App中，一般可以将App根据程序的结构进行纵向划分，根据MVP可以将App分别为模型层(M)，UI层(V)和逻辑层(P)。</p>
<p>UI层一般包括Activity，Fragment，Adapter等直接和UI相关的类，UI层的Activity在启动之后实例化相应的Presenter，App的控制权后移，由UI转移到Presenter，两者之间的通信通过BroadCast、Handler或者接口完成，只传递事件和结果。</p>
<p>举个简单的例子，UI层通知逻辑层（Presenter）用户点击了一个Button，逻辑层（Presenter）自己决定应该用什么行为进行响应，该找哪个模型（Model）去做这件事，最后逻辑层（Presenter）将完成的结果更新到UI层。</p>
<h3 id="MVP的变种：Passive-View"><a href="#MVP的变种：Passive-View" class="headerlink" title="MVP的变种：Passive View"></a>MVP的变种：Passive View</h3><p>MVP的变种有很多，其中使用最广泛的是Passive View模式，即被动视图。在这种模式下，View和Model之间不能直接交互，View通过Presenter与Model打交道。Presenter接受View的UI请求，完成简单的UI处理逻辑，并调用Model进行业务处理，并调用View将相应的结果反映出来。View直接依赖Presenter，但是Presenter间接依赖View，它直接依赖的是View实现的接口。  </p>
<p><img src="/2020/03/12/mvcmvpmvvmdesign/f7002cd0e8951e46fd963bff0a0081d8.jpg" alt></p>
<p>相对于View的被动，那Presenter就是主动的一方。对于Presenter的主动，有如下的理解：</p>
<ul>
<li>Presenter是整个MVP体系的控制中心，而不是单纯的处理View请求的人；</li>
<li>View仅仅是用户交互请求的汇报者，对于响应用户交互相关的逻辑和流程，View不参与决策，真正的决策者是Presenter；</li>
<li>View向Presenter发送用户交互请求应该采用这样的口吻：“我现在将用户交互请求发送给你，你看着办，需要我的时候我会协助你”，不应该是这样：“我现在处理用户交互请求了，我知道该怎么办，但是我需要你的支持，因为实现业务逻辑的Model只信任你”；</li>
<li>对于绑定到View上的数据，不应该是View从Presenter上“拉”回来的，应该是Presenter主动“推”给View的；</li>
<li>View尽可能不维护数据状态，因为其本身仅仅实现单纯的、独立的UI操作；Presenter才是整个体系的协调者，它根据处理用于交互的逻辑给View和Model安排工作。</li>
</ul>
<h3 id="MVP架构存在的问题与解决办法"><a href="#MVP架构存在的问题与解决办法" class="headerlink" title="MVP架构存在的问题与解决办法"></a>MVP架构存在的问题与解决办法</h3><ul>
<li>加入模板方法（Template Method）<br>转移逻辑操作之后可能部分较为复杂的Activity内代码量还是不少，于是需要在分层的基础上再加入模板方法（Template Method）。</li>
</ul>
<p>具体做法是在Activity内部分层。其中最顶层为BaseActivity，不做具体显示，而是提供一些基础样式，Dialog，ActionBar在内的内容，展现给用户的Activity继承BaseActivity，重写BaseActivity预留的方法。如有必要再进行二次继承，App中Activity之间的继承次数最多不超过3次。</p>
<ul>
<li><p>Model内部分层<br>模型层（Model）中的整体代码量是最大的，一般由大量的Package组成，针对这部分需要做的就是在程序设计的过程中，做好模块的划分，进行接口隔离，在内部进行分层。</p>
</li>
<li><p>强化Presenter<br>强化Presenter的作用，将所有逻辑操作都放在Presenter内也容易造成Presenter内的代码量过大，对于这点，有一个方法是在UI层和Presenter之间设置中介者Mediator，将例如数据校验、组装在内的轻量级逻辑操作放在Mediator中；在Presenter和Model之间使用代理Proxy；通过上述两者分担一部分Presenter的逻辑操作，但整体框架的控制权还是在Presenter手中。Mediator和Proxy不是必须的，只在Presenter负担过大时才建议使用。</p>
</li>
</ul>
<p>最终的架构如下图所示：</p>
<p><img src="/2020/03/12/mvcmvpmvvmdesign/ee7b3f65d6ff23453e78193b6a37d79b.jpg" alt></p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。</p>
<p>在比较之前，先从图上看看三者的异同。</p>
<p><img src="/2020/03/12/mvcmvpmvvmdesign/bb8f3106230c33063ab53393dfe1876a.jpg" alt></p>
<p>刚开始理解这些概念的时候认为这几种模式虽然都是要将view和model解耦，但是非此即彼，没有关系，一个应用只会用一种模式。后来慢慢发现世界绝对不是只有黑白两面，中间最大的一块其实是灰色地带，同样，这几种模式的边界并非那么明显，可能你在自己的应用中都会用到。实际上也根本没必要去纠结自己到底用的是MVC、MVP还是MVVP，不管黑猫白猫，捉住老鼠就是好猫。</p>
<h3 id="MVC-gt-MVP-gt-MVVM演进过程"><a href="#MVC-gt-MVP-gt-MVVM演进过程" class="headerlink" title="MVC-&gt;MVP-&gt;MVVM演进过程"></a>MVC-&gt;MVP-&gt;MVVM演进过程</h3><p>MVC -&gt; MVP -&gt; MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。</p>
<h4 id="同"><a href="#同" class="headerlink" title="同"></a>同</h4><p>如果把这三者放在一起比较，先说一下三者的共同点，也就是Model和View：</p>
<p>Model：数据对象，同时，提供本应用外部对应用程序数据的操作的接口，也可能在数据变化时发出变更通知。Model不依赖于View的实现，只要外部程序调用Model的接口就能够实现对数据的增删改查。<br>View：UI层，提供对最终用户的交互操作功能，包括UI展现代码及一些相关的界面逻辑代码。</p>
<h4 id="异"><a href="#异" class="headerlink" title="异"></a>异</h4><p>三者的差异在于如何粘合View和Model，实现用户的交互操作以及变更通知</p>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>Controller接收View的操作事件，根据事件不同，或者调用Model的接口进行数据操作，或者进行View的跳转，从而也意味着一个Controller可以对应多个View。Controller对View的实现不太关心，只会被动地接收，Model的数据变更不通过Controller直接通知View，通常View采用观察者模式监听Model的变化。</p>
<h4 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h4><p>Presenter与Controller一样，接收View的命令，对Model进行操作；与Controller不同的是Presenter会反作用于View，Model的变更通知首先被Presenter获得，然后Presenter再去更新View。一个Presenter只对应于一个View。根据Presenter和View对逻辑代码分担的程度不同，这种模式又有两种情况：Passive View和Supervisor Controller。</p>
<h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><p>注意这里的“Model”指的是View的Model，跟MVVM中的一个Model不是一回事。所谓View的Model就是包含View的一些数据属性和操作的这么一个东东，这种模式的关键技术就是数据绑定（data binding），View的变化会直接影响ViewModel，ViewModel的变化或者内容也会直接体现在View上。这种模式实际上是框架替应用开发者做了一些工作，开发者只需要较少的代码就能实现比较复杂的交互。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>mvc</tag>
        <tag>mvp</tag>
        <tag>mvvp</tag>
      </tags>
  </entry>
  <entry>
    <title>Android获取当前栈顶Activity</title>
    <url>/2020/03/12/androidgetstacktopact/</url>
    <content><![CDATA[<h3 id="1-Shell"><a href="#1-Shell" class="headerlink" title="1. Shell"></a>1. Shell</h3><p>通过dumpsys命令, 获取当前焦点窗口的包名/类名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dumpsys activity | grep "mFoucsActivty"</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="2-辅助功能-AccessibilityService"><a href="#2-辅助功能-AccessibilityService" class="headerlink" title="2. 辅助功能(AccessibilityService)"></a>2. 辅助功能(AccessibilityService)</h3><p>辅助功能是帮助残障人士使用, 所以能够监听到当前窗口的变化, 需要用户手动开启权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowChangeDetectingService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onServiceConnected();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Configure these here for compatibility with API 13 and below.</span></span><br><span class="line">        AccessibilityServiceInfo config = <span class="keyword">new</span> AccessibilityServiceInfo();</span><br><span class="line">        config.eventTypes = AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED;</span><br><span class="line">        config.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">16</span>)</span><br><span class="line">            <span class="comment">//Just in case this helps</span></span><br><span class="line">            config.flags = AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS;</span><br><span class="line"></span><br><span class="line">        setServiceInfo(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getEventType() == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED) &#123;</span><br><span class="line">            ComponentName componentName = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                event.getPackageName().toString(),</span><br><span class="line">                event.getClassName().toString()</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            ActivityInfo activityInfo = tryGetActivity(componentName);</span><br><span class="line">            <span class="keyword">boolean</span> isActivity = activityInfo != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (isActivity)</span><br><span class="line">                Log.i(<span class="string">"CurrentActivity"</span>, componentName.flattenToShortString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ActivityInfo <span class="title">tryGetActivity</span><span class="params">(ComponentName componentName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getPackageManager().getActivityInfo(componentName, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AndroidManifest.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;</span><br><span class="line">    ....    &lt;service android:label&#x3D;&quot;@string&#x2F;accessibility_service_name&quot; android:name&#x3D;&quot;.WindowChangeDetectingService&quot; android:permission&#x3D;&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;</span><br><span class="line">        &lt;intent-filter&gt;</span><br><span class="line">            &lt;action android:name&#x3D;&quot;android.accessibilityservice.AccessibilityService&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;intent-filter&gt;</span><br><span class="line">        &lt;meta-data android:name&#x3D;&quot;android.accessibilityservice&quot; android:resource&#x3D;&quot;@xml&#x2F;accessibilityservice&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;service&gt;</span><br><span class="line">    ....</span><br><span class="line">&lt;&#x2F;application&gt;</span><br></pre></td></tr></table></figure>

<p>res/xml/accessibilityservice.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!-- These options MUST be specified here in order for the events to be received on first start in Android 4.1.1 --&gt;</span><br><span class="line">&lt;accessibility-service xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">                       android:accessibilityEventTypes&#x3D;&quot;typeWindowStateChanged&quot;</span><br><span class="line">                       android:accessibilityFeedbackType&#x3D;&quot;feedbackGeneric&quot;</span><br><span class="line">                       android:accessibilityFlags&#x3D;&quot;flagIncludeNotImportantViews&quot;</span><br><span class="line">                       android:description&#x3D;&quot;@string&#x2F;accessibility_service_description&quot;</span><br><span class="line">                       xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">                       tools:ignore&#x3D;&quot;UnusedAttribute&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-ActivityManager"><a href="#3-ActivityManager" class="headerlink" title="3. ActivityManager"></a>3. ActivityManager</h3><p>使用 ActivityManager有一定版本限制。官方文档有详细的说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on API-21 as of LOLLIPOP, ActivityManager.getRunningTasks() is no longer available to third partyapplications: the introduction of document-centric recents means it can leak person information to thecaller. For backwards compatibility, it will still return a small subset of its data: at least the caller&#39;s owntasks, and possibly some other tasks such as home that are known to not be sensitive.</span><br></pre></td></tr></table></figure>

<p>网上有人说可以用下面的方法分别调用不同的API，兼容不同的版本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pre-Lollipop: ActivityManager.getRunningTasksLollipop: ActivityManager.getRunningAppProcesses</span><br></pre></td></tr></table></figure>

<p>在 Android5.0 (API-21)及以上，getRunningTasks将只返回自己和 launcher，getRunningTasks 无法正确判断当前应用是否为front, 不同版本测试的结果也不一样：<br>在 Android 5.0版本：  </p>
<ol>
<li>当用户在当前App页面时，runningTasksInfos.get(0) = 当前App  </li>
<li>当用户回到launch页面时，runningTasksInfos.get(0) = launcher  </li>
<li>当用户在其它App页面时，runningTasksInfos.get(0) = launcher<br>在 Android 5.1, 6.0 以上版本：  </li>
<li>当用户在钱盾页面时，runningTasksInfos.get(0) = 当前App  </li>
<li>当用户回到launch页面时，runningTasksInfos.get(0) = launcher  </li>
<li>当用户在其它App页面时，runningTasksInfos.get(0) = 当前App<br>对于getRunningAppProcesses，经过我自己的测试：<br>在Android 5.0(API-21) 版本getRunningAppProcesses可以获取所有应用的process，可以通过其来判断top package; 但是在 Android 5.1.0 (API-22)及其以上Android 6.0 (API-23)上永远只返回应用自身的process，不能用来判断任意top package，但是可以用来判断当前App应用是否在前台：<br>官方文档申明 getRunningAppProcesses() 只是用于debugging and management user interfaces，有一定的局限性，说不定哪天就不支持了<br>依赖反射调用: ActivityManager.RunningAppProcessInfo.processState<br>无法监控 App switcher activity.</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentApplicationPackageRetriever</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentApplicationPackageRetriever</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] get() &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">21</span>)</span><br><span class="line">            <span class="keyword">return</span> getPreLollipop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getLollipop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String[] getPreLollipop() &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        List&lt;ActivityManager.RunningTaskInfo&gt; tasks =</span><br><span class="line">            activityManager().getRunningTasks(<span class="number">1</span>);</span><br><span class="line">        ActivityManager.RunningTaskInfo currentTask = tasks.get(<span class="number">0</span>);</span><br><span class="line">        ComponentName currentActivity = currentTask.topActivity;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; currentActivity.getPackageName() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] getLollipop() &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PROCESS_STATE_TOP = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field processStateField = ActivityManager.RunningAppProcessInfo.class.getDeclaredField("processState");</span><br><span class="line"></span><br><span class="line">            List&lt;ActivityManager.RunningAppProcessInfo&gt; processes =</span><br><span class="line">                activityManager().getRunningAppProcesses();</span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo process : processes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    <span class="comment">// Filters out most non-activity processes</span></span><br><span class="line">                    process.importance &lt;= ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND                    &amp;&amp;</span><br><span class="line">                    <span class="comment">// Filters out processes that are just being</span></span><br><span class="line">                    <span class="comment">// _used_ by the process with the activity</span></span><br><span class="line">                    process.importanceReasonCode == <span class="number">0</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> state = processStateField.getInt(process);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (state == PROCESS_STATE_TOP)</span><br><span class="line">                        <span class="comment">/*                         If multiple candidate processes can get here,                         it's most likely that apps are being switched.                         The first one provided by the OS seems to be                         the one being switched to, so we stop here.                         */</span></span><br><span class="line">                        <span class="keyword">return</span> process.pkgList;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ActivityManager <span class="title">activityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加 GET_TASKS 权限到 AndroidManifest.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--suppress DeprecatedClassUsageInspection --&gt;</span><br><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.GET_TASKS&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-通过反射”android-app-ActivityThread”的方式"><a href="#4-通过反射”android-app-ActivityThread”的方式" class="headerlink" title="4.通过反射”android.app.ActivityThread”的方式"></a>4.通过反射”android.app.ActivityThread”的方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Activity <span class="title">getRunningActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class activityThreadClass = Class.forName(<span class="string">"android.app.ActivityThread"</span>);</span><br><span class="line">        Object activityThread = activityThreadClass.getMethod(<span class="string">"currentActivityThread"</span>)</span><br><span class="line">                .invoke(<span class="keyword">null</span>);</span><br><span class="line">        Field activitiesField = activityThreadClass.getDeclaredField(<span class="string">"mActivities"</span>);</span><br><span class="line">        activitiesField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ArrayMap activities = (ArrayMap) activitiesField.get(activityThread);</span><br><span class="line">        <span class="keyword">for</span> (Object activityRecord : activities.values()) &#123;</span><br><span class="line">            Class activityRecordClass = activityRecord.getClass();</span><br><span class="line">            Field pausedField = activityRecordClass.getDeclaredField(<span class="string">"paused"</span>);</span><br><span class="line">            pausedField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!pausedField.getBoolean(activityRecord)) &#123;</span><br><span class="line">                Field activityField = activityRecordClass.getDeclaredField(<span class="string">"activity"</span>);</span><br><span class="line">                activityField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> (Activity) activityField.get(activityRecord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Didn't find the running activity"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在有些手机上测试时，发现 It’s API &gt; 19,只能获取当前App的Activities</li>
<li>另外在当用“Map” 替换“ArrayMap”发现在4.3的手机可以工作正常. 更高版本的手机还没有测试过</li>
</ul>
<h3 id="5-通过-UsageStatsManager-gt-queryUsageStats方法"><a href="#5-通过-UsageStatsManager-gt-queryUsageStats方法" class="headerlink" title="5.通过 UsageStatsManager -&gt; queryUsageStats方法"></a>5.通过 UsageStatsManager -&gt; queryUsageStats方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    UsageStatsManager usm = (UsageStatsManager) getSystemService(<span class="string">"usagestats"</span>);</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    List&lt;UsageStats&gt; appList = usm.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, time - <span class="number">1000</span> * <span class="number">1000</span>, time);</span><br><span class="line">    <span class="keyword">if</span> (appList != <span class="keyword">null</span> &amp;&amp; appList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        SortedMap&lt;Long, UsageStats&gt; mySortedMap = <span class="keyword">new</span> TreeMap&lt;Long, UsageStats&gt;();</span><br><span class="line">        <span class="keyword">for</span> (UsageStats usageStats : appList) &#123;</span><br><span class="line">            mySortedMap.put(usageStats.getLastTimeUsed(), usageStats);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mySortedMap != <span class="keyword">null</span> &amp;&amp; !mySortedMap.isEmpty()) &#123;</span><br><span class="line">            currentApp = mySortedMap.get(mySortedMap.lastKey()).getPackageName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List&lt;ActivityManager.RunningAppProcessInfo&gt; tasks = am.getRunningAppProcesses();</span><br><span class="line">    currentApp = tasks.get(<span class="number">0</span>).processName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘记添加permission 到Manifest 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.GET_TASKS&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.PACKAGE_USAGE_STATS&quot;</span><br><span class="line">                 tools:ignore&#x3D;&quot;ProtectedPermissions&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>栈顶activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 性能测试 BlockCanary &amp; LeakCanary</title>
    <url>/2020/03/12/androidblockleak/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android对于性能的测试，基本就是两块，执行效率以及内存的占用，执行效率常见的界面绘制，内存的使用常见的图片加载和内存泄漏，BlockCanary 是对界面绘制性能检测的工具， LeakCanary是对内存泄漏进行检测的工具</p>
<a id="more"></a>

<h3 id="1-LeakCanary"><a href="#1-LeakCanary" class="headerlink" title="1.LeakCanary"></a>1.LeakCanary</h3><p>用来检测内存泄露</p>
<p>Github地址 : <a href="https://github.com/square/leakcanary" target="_blank" rel="noopener" title="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h4><p>build.gradle中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;  debugCompile &#39;com.squareup.leakcanary:leakcanary-android:1.5.1&#39;  releaseCompile &#39;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&#39;  testCompile &#39;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>application oncreate中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LeakCanary.install(this);</span><br></pre></td></tr></table></figure>

<h3 id="2-BlockCanary"><a href="#2-BlockCanary" class="headerlink" title="2.BlockCanary"></a>2.BlockCanary</h3><p>检测界面绘制速度ui卡顿</p>
<p>Github地址 : <a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener" title="https://github.com/markzhai/AndroidPerformanceMonitor">https://github.com/markzhai/AndroidPerformanceMonitor</a></p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法:"></a>用法:</h4><p>build.gradle中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;  debugCompile &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;  releaseCompile &#39;com.github.markzhai:blockcanary-no-op:1.5.0&#39;  testCompile &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>application oncreate中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BlockCanary.install(this, new AppBlockCanaryContext()).start();</span><br></pre></td></tr></table></figure>

<p>继承BlockCanaryContext，以及回调函数的作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBlockCanaryContext</span> <span class="keyword">extends</span> <span class="title">BlockCanaryContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Implement in your project.     *     * <span class="doctag">@return</span> Qualifier which can specify this installation, like version + flavor.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">provideQualifier</span><span class="params">()</span> </span>&#123;  <span class="comment">//区分项目版本</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Implement in your project.     *     * <span class="doctag">@return</span> user id     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">provideUid</span><span class="params">()</span> </span>&#123;  <span class="comment">//用户id, 具体用处不清楚, 可能在上传的时候进行用户区分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"uid"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Network type     *     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> String&#125; like 2G, 3G, 4G, wifi, etc.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">provideNetworkType</span><span class="params">()</span> </span>&#123;  <span class="comment">//文件上传的网络类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Config monitor duration, after this time BlockCanary will stop, use     * with &#123;<span class="doctag">@code</span> BlockCanary&#125;'s isMonitorDurationEnd     *     * <span class="doctag">@return</span> monitor last duration (in hour)     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">provideMonitorDuration</span><span class="params">()</span> </span>&#123;   <span class="comment">//监视器的执行时间</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Config block threshold (in millis), dispatch over this duration is regarded as a BLOCK. You may set it     * from performance of device.     *     * <span class="doctag">@return</span> threshold in mills     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">provideBlockThreshold</span><span class="params">()</span> </span>&#123;<span class="comment">//阻塞的临界值, 超过这个值视为一次阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Thread stack dump interval, use when block happens, BlockCanary will dump on main thread     * stack according to current sample cycle.     *      * Because the implementation mechanism of Looper, real dump interval would be longer than     * the period specified here (especially when cpu is busier).     *      *     * <span class="doctag">@return</span> dump interval (in millis)     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">provideDumpInterval</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> provideBlockThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Path to save log, like "/blockcanary/", will save to sdcard if can.     *     * <span class="doctag">@return</span> path of log files     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">providePath</span><span class="params">()</span> </span>&#123; <span class="comment">//log保存路径</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/blockcanary/"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * If need notification to notice block.     *     * <span class="doctag">@return</span> true if need, else if not need.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">displayNotification</span><span class="params">()</span> </span>&#123; <span class="comment">//阻塞是否提醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Implement in your project, bundle files into a zip file.     *     * <span class="doctag">@param</span> src  files before compress     * <span class="doctag">@param</span> dest files compressed     * <span class="doctag">@return</span> true if compression is successful     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">zip</span><span class="params">(File[] src, File dest)</span> </span>&#123;  <span class="comment">//是否打包为zip</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Implement in your project, bundled log files.     *     * <span class="doctag">@param</span> zippedFile zipped file     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">(File zippedFile)</span> </span>&#123; <span class="comment">//上传</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Packages that developer concern, by default it uses process name,     * put high priority one in pre-order.     *     * <span class="doctag">@return</span> null if simply concern only package with process name.     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&amp;amp&gt; concernPackages() &#123; <span class="comment">// 监控的进程, 一个项目可能为多个进程, 默认包名进程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Filter stack without any in concern package, used with @&#123;code concernPackages&#125;.     *     * <span class="doctag">@return</span> true if filter, false it not.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filterNonConcernStack</span><span class="params">()</span> </span>&#123;  <span class="comment">//是否过滤</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Provide white list, entry in white list will not be shown in ui list.     *     * <span class="doctag">@return</span> return null if you don't need white-list filter.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">provideWhiteList</span><span class="params">()</span> </span>&#123; <span class="comment">//白名单, 不进行监视</span></span><br><span class="line">        LinkedList&amp;lt;String&amp;gt; whiteList = <span class="keyword">new</span> LinkedList&amp;lt;&amp;gt;();</span><br><span class="line">        whiteList.add(<span class="string">"org.chromium"</span>);</span><br><span class="line">        <span class="keyword">return</span> whiteList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Whether to delete files whose stack is in white list, used with white-list.     *     * <span class="doctag">@return</span> true if delete, false it not.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteFilesInWhiteList</span><span class="params">()</span> </span>&#123; <span class="comment">//白名单中的文件删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**     * Block interceptor, developer may provide their own actions.     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBlock</span><span class="params">(Context context, BlockInfo blockInfo)</span> </span>&#123; <span class="comment">//检测到阻塞信息回调处理</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>blockcanary</tag>
        <tag>leakcanary</tag>
        <tag>性能测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Logcat获取指定报名日志</title>
    <url>/2020/03/12/androidlogcatyoupack/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于Android开发来说, Logcat肯定是再熟悉不过. 获取日志输出来定位程序问题, logcat是必不可少的, 最近在弄一个log收集的工具, 需要获取指定程序的日志, 再次记录一下.</p>
<a id="more"></a>

<h3 id="1-Logcat源码地址"><a href="#1-Logcat源码地址" class="headerlink" title="1.Logcat源码地址"></a>1.Logcat源码地址</h3><p><a href="https://github.com/android/platform_system_core/tree/master/logcat" target="_blank" rel="noopener" title="https://github.`com`/android/platform_system_core/tree/master/logcat">https://github.com/android/platform_system_core/tree/master/logcat</a></p>
<h3 id="2-源码中两个方法提示logcat用法"><a href="#2-源码中两个方法提示logcat用法" class="headerlink" title="2.源码中两个方法提示logcat用法"></a>2.源码中两个方法提示logcat用法</h3><p>logcat.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_help</span><span class="params">(android_logcat_context_internal* context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;error) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* cmd = <span class="built_in">strrchr</span>(context-&gt;argv[<span class="number">0</span>], <span class="string">'/'</span>);</span><br><span class="line">    cmd = cmd ? cmd + <span class="number">1</span> : context-&gt;argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(context-&gt;error, <span class="string">"Usage: %s [options] [filterspecs]\n"</span>, cmd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(context-&gt;error, <span class="string">"options include:\n"</span></span><br><span class="line">                    <span class="string">"  -s              Set default filter to silent. Equivalent to filterspec '*:S'\n"</span></span><br><span class="line">                    <span class="string">"  -f &lt;file&gt;, --file=&lt;file&gt;               Log to file. Default is stdout\n"</span></span><br><span class="line">                    <span class="string">"  -r &lt;kbytes&gt;, --rotate-kbytes=&lt;kbytes&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Rotate log every kbytes. Requires -f option\n"</span></span><br><span class="line">                    <span class="string">"  -n &lt;count&gt;, --rotate-count=&lt;count&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Sets max number of rotated logs to &lt;count&gt;, default 4\n"</span></span><br><span class="line">                    <span class="string">"  --id=&lt;id&gt;       If the signature id for logging to file changes, then clear\n"</span></span><br><span class="line">                    <span class="string">"                  the fileset and continue\n"</span></span><br><span class="line">                    <span class="string">"  -v &lt;format&gt;, --format=&lt;format&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Sets log print format verb and adverbs, where &lt;format&gt; is:\n"</span></span><br><span class="line">                    <span class="string">"                    brief help long process raw tag thread threadtime time\n"</span></span><br><span class="line">                    <span class="string">"                  and individually flagged modifying adverbs can be added:\n"</span></span><br><span class="line">                    <span class="string">"                    color descriptive epoch monotonic printable uid\n"</span></span><br><span class="line">                    <span class="string">"                    usec UTC year zone\n"</span></span><br><span class="line">                    <span class="string">"                  Multiple -v parameters or comma separated list of format and\n"</span></span><br><span class="line">                    <span class="string">"                  format modifiers are allowed.\n"</span></span><br><span class="line">                    <span class="comment">// private and undocumented nsec, no signal, too much noise</span></span><br><span class="line">                    <span class="comment">// useful for -T or -t &lt;timestamp&gt; accurate testing though.</span></span><br><span class="line">                    <span class="string">"  -D, --dividers  Print dividers between each log buffer\n"</span></span><br><span class="line">                    <span class="string">"  -c, --clear     Clear (flush) the entire log and exit\n"</span></span><br><span class="line">                    <span class="string">"                  if Log to File specified, clear fileset instead\n"</span></span><br><span class="line">                    <span class="string">"  -d              Dump the log and then exit (don't block)\n"</span></span><br><span class="line">                    <span class="string">"  -e &lt;expr&gt;, --regex=&lt;expr&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Only print lines where the log message matches &lt;expr&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  where &lt;expr&gt; is a regular expression\n"</span></span><br><span class="line">                    <span class="comment">// Leave --head undocumented as alias for -m</span></span><br><span class="line">                    <span class="string">"  -m &lt;count&gt;, --max-count=&lt;count&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Quit after printing &lt;count&gt; lines. This is meant to be\n"</span></span><br><span class="line">                    <span class="string">"                  paired with --regex, but will work on its own.\n"</span></span><br><span class="line">                    <span class="string">"  --print         Paired with --regex and --max-count to let content bypass\n"</span></span><br><span class="line">                    <span class="string">"                  regex filter but still stop at number of matches.\n"</span></span><br><span class="line">                    <span class="comment">// Leave --tail undocumented as alias for -t</span></span><br><span class="line">                    <span class="string">"  -t &lt;count&gt;      Print only the most recent &lt;count&gt; lines (implies -d)\n"</span></span><br><span class="line">                    <span class="string">"  -t '&lt;time&gt;'     Print most recent lines since specified time (implies -d)\n"</span></span><br><span class="line">                    <span class="string">"  -T &lt;count&gt;      Print only the most recent &lt;count&gt; lines (does not imply -d)\n"</span></span><br><span class="line">                    <span class="string">"  -T '&lt;time&gt;'     Print most recent lines since specified time (not imply -d)\n"</span></span><br><span class="line">                    <span class="string">"                  count is pure numerical, time is 'MM-DD hh:mm:ss.mmm...'\n"</span></span><br><span class="line">                    <span class="string">"                  'YYYY-MM-DD hh:mm:ss.mmm...' or 'sssss.mmm...' format\n"</span></span><br><span class="line">                    <span class="string">"  -g, --buffer-size                      Get the size of the ring buffer.\n"</span></span><br><span class="line">                    <span class="string">"  -G &lt;size&gt;, --buffer-size=&lt;size&gt;\n"</span></span><br><span class="line">                    <span class="string">"                  Set size of log ring buffer, may suffix with K or M.\n"</span></span><br><span class="line">                    <span class="string">"  -L, --last      Dump logs from prior to last reboot\n"</span></span><br><span class="line">                    <span class="string">"  -b &lt;buffer&gt;, --buffer=&lt;buffer&gt;         Request alternate ring buffer, 'main',\n"</span></span><br><span class="line">                    <span class="string">"                  'system', 'radio', 'events', 'crash', 'default' or 'all'.\n"</span></span><br><span class="line">                    <span class="string">"                  Additionally, 'kernel' for userdebug and eng builds, and\n"</span></span><br><span class="line">                    <span class="string">"                  'security' for Device Owner installations.\n"</span></span><br><span class="line">                    <span class="string">"                  Multiple -b parameters or comma separated list of buffers are\n"</span></span><br><span class="line">                    <span class="string">"                  allowed. Buffers interleaved.\n"</span></span><br><span class="line">                    <span class="string">"                  Default -b main,system,crash,kernel.\n"</span></span><br><span class="line">                    <span class="string">"  -B, --binary    Output the log in binary.\n"</span></span><br><span class="line">                    <span class="string">"  -S, --statistics                       Output statistics.\n"</span></span><br><span class="line">                    <span class="string">"  -p, --prune     Print prune white and ~black list. Service is specified as\n"</span></span><br><span class="line">                    <span class="string">"                  UID, UID/PID or /PID. Weighed for quicker pruning if prefix\n"</span></span><br><span class="line">                    <span class="string">"                  with ~, otherwise weighed for longevity if unadorned. All\n"</span></span><br><span class="line">                    <span class="string">"                  other pruning activity is oldest first. Special case ~!\n"</span></span><br><span class="line">                    <span class="string">"                  represents an automatic quicker pruning for the noisiest\n"</span></span><br><span class="line">                    <span class="string">"                  UID as determined by the current statistics.\n"</span></span><br><span class="line">                    <span class="string">"  -P '&lt;list&gt; ...', --prune='&lt;list&gt; ...'\n"</span></span><br><span class="line">                    <span class="string">"                  Set prune white and ~black list, using same format as\n"</span></span><br><span class="line">                    <span class="string">"                  listed above. Must be quoted.\n"</span></span><br><span class="line">                    <span class="string">"  --pid=&lt;pid&gt;     Only prints logs from the given pid.\n"</span></span><br><span class="line">                    <span class="comment">// Check ANDROID_LOG_WRAP_DEFAULT_TIMEOUT value for match to 2 hours</span></span><br><span class="line">                    <span class="string">"  --wrap          Sleep for 2 hours or when buffer about to wrap whichever\n"</span></span><br><span class="line">                    <span class="string">"                  comes first. Improves efficiency of polling by providing\n"</span></span><br><span class="line">                    <span class="string">"                  an about-to-wrap wakeup.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(context-&gt;error, <span class="string">"\nfilterspecs are a series of \n"</span></span><br><span class="line">                   <span class="string">"  &lt;tag&gt;[:priority]\n\n"</span></span><br><span class="line">                   <span class="string">"where &lt;tag&gt; is a log component tag (or * for all) and priority is:\n"</span></span><br><span class="line">                   <span class="string">"  V    Verbose (default for &lt;tag&gt;)\n"</span></span><br><span class="line">                   <span class="string">"  D    Debug (default for '*')\n"</span></span><br><span class="line">                   <span class="string">"  I    Info\n"</span></span><br><span class="line">                   <span class="string">"  W    Warn\n"</span></span><br><span class="line">                   <span class="string">"  E    Error\n"</span></span><br><span class="line">                   <span class="string">"  F    Fatal\n"</span></span><br><span class="line">                   <span class="string">"  S    Silent (suppress all output)\n"</span></span><br><span class="line">                   <span class="string">"\n'*' by itself means '*:D' and &lt;tag&gt; by itself means &lt;tag&gt;:V.\n"</span></span><br><span class="line">                   <span class="string">"If no '*' filterspec or -s on command line, all filter defaults to '*:V'.\n"</span></span><br><span class="line">                   <span class="string">"eg: '*:S &lt;tag&gt;' prints only &lt;tag&gt;, '&lt;tag&gt;:S' suppresses all &lt;tag&gt; log messages.\n"</span></span><br><span class="line">                   <span class="string">"\nIf not specified on the command line, filterspec is set from ANDROID_LOG_TAGS.\n"</span></span><br><span class="line">                   <span class="string">"\nIf not specified with -v on command line, format is set from ANDROID_PRINTF_LOG\n"</span></span><br><span class="line">                   <span class="string">"or defaults to \"threadtime\"\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show_format_help</span><span class="params">(android_logcat_context_internal* context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context-&gt;error) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(context-&gt;error,</span><br><span class="line">        <span class="string">"-v &lt;format&gt;, --format=&lt;format&gt; options:\n"</span></span><br><span class="line">        <span class="string">"  Sets log print format verb and adverbs, where &lt;format&gt; is:\n"</span></span><br><span class="line">        <span class="string">"    brief long process raw tag thread threadtime time\n"</span></span><br><span class="line">        <span class="string">"  and individually flagged modifying adverbs can be added:\n"</span></span><br><span class="line">        <span class="string">"    color descriptive epoch monotonic printable uid usec UTC year zone\n"</span></span><br><span class="line">        <span class="string">"\nSingle format verbs:\n"</span></span><br><span class="line">        <span class="string">"  brief      — Display priority/tag and PID of the process issuing the message.\n"</span></span><br><span class="line">        <span class="string">"  long       — Display all metadata fields, separate messages with blank lines.\n"</span></span><br><span class="line">        <span class="string">"  process    — Display PID only.\n"</span></span><br><span class="line">        <span class="string">"  raw        — Display the raw log message, with no other metadata fields.\n"</span></span><br><span class="line">        <span class="string">"  tag        — Display the priority/tag only.\n"</span></span><br><span class="line">        <span class="string">"  thread     — Display priority, PID and TID of process issuing the message.\n"</span></span><br><span class="line">        <span class="string">"  threadtime — Display the date, invocation time, priority, tag, and the PID\n"</span></span><br><span class="line">        <span class="string">"               and TID of the thread issuing the message. (the default format).\n"</span></span><br><span class="line">        <span class="string">"  time       — Display the date, invocation time, priority/tag, and PID of the\n"</span></span><br><span class="line">        <span class="string">"             process issuing the message.\n"</span></span><br><span class="line">        <span class="string">"\nAdverb modifiers can be used in combination:\n"</span></span><br><span class="line">        <span class="string">"  color       — Display in highlighted color to match priority. i.e. \x1B[38;5;231mVERBOSE\n"</span></span><br><span class="line">        <span class="string">"                \x1B[38;5;75mDEBUG \x1B[38;5;40mINFO \x1B[38;5;166mWARNING \x1B[38;5;196mERROR FATAL\x1B[0m\n"</span></span><br><span class="line">        <span class="string">"  descriptive — events logs only, descriptions from event-log-tags database.\n"</span></span><br><span class="line">        <span class="string">"  epoch       — Display time as seconds since Jan 1 1970.\n"</span></span><br><span class="line">        <span class="string">"  monotonic   — Display time as cpu seconds since last boot.\n"</span></span><br><span class="line">        <span class="string">"  printable   — Ensure that any binary logging content is escaped.\n"</span></span><br><span class="line">        <span class="string">"  uid         — If permitted, display the UID or Android ID of logged process.\n"</span></span><br><span class="line">        <span class="string">"  usec        — Display time down the microsecond precision.\n"</span></span><br><span class="line">        <span class="string">"  UTC         — Display time as UTC.\n"</span></span><br><span class="line">        <span class="string">"  year        — Add the year to the displayed time.\n"</span></span><br><span class="line">        <span class="string">"  zone        — Add the local timezone to the displayed time.\n"</span></span><br><span class="line">        <span class="string">"  \"&lt;zone&gt;\"    — Print using this public named timezone (experimental).\n\n"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选项解析"><a href="#选项解析" class="headerlink" title="选项解析 :"></a>选项解析 :</h3><ul>
<li><p>“-s”选项 : 设置输出日志的标签, 只显示该标签的日志;</p>
</li>
<li><p>“-f”选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</p>
</li>
<li><p>“-r”选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</p>
</li>
<li><p>“-n”选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</p>
</li>
<li><p>“-v”选项 : 设置日志的输出格式, 注意只能设置一项;</p>
</li>
<li><p>“-c”选项 : 清空所有的日志缓存信息;</p>
</li>
<li><p>“-d”选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;</p>
</li>
<li><p>“-t”选项 : 输出最近的几行日志, 输出完退出, 不阻塞;</p>
</li>
<li><p>“-g”选项 : 查看日志缓冲区信息;</p>
</li>
<li><p>“-b”选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;</p>
</li>
<li><p>“-B”选项 : 以二进制形式输出日志;</p>
</li>
</ul>
<h3 id="3-常用功能"><a href="#3-常用功能" class="headerlink" title="3.常用功能"></a>3.常用功能</h3><ul>
<li><p>logcat -s &lt;过滤标签&gt; — 根据指定标签过滤</p>
</li>
<li><p>logcat -f —- 输出到文件</p>
</li>
<li><p>logcat | grep &lt;过滤内容&gt; —- 根据内容过滤log</p>
</li>
<li><p>logcat -v time — log带有日期, 之前的版本貌似只能添加一个格式, 最新的版本貌似可以添加多个格式 显示你需要的内容, pid 等;</p>
</li>
</ul>
<h3 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h3><p>如何获取指定包名的程序的log, 思路就是通过runtime.exec 执行logcat语句, 读流过滤</p>
<ul>
<li>runtime.exec </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logcat –v time</span><br></pre></td></tr></table></figure>

<p> 带有时间信息以及pid的log , 用来后面过滤进程</p>
<ul>
<li>通过包名获取进程pid, runtime.exec</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps | grep xxx.xxx.xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在读流的过程中去过滤pid, 获取到的 就是你想要得到的应用进程的log</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>logcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Android外置存储设备监听获取</title>
    <url>/2020/03/12/androidexstorageinfo/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android设备可以通过usb口扩展多个外置存储设备，本blog主要讲述如何获取这些外置存储设备的信息</p>
<a id="more"></a>

<h3 id="存储挂载-卸载监听"><a href="#存储挂载-卸载监听" class="headerlink" title="存储挂载/卸载监听"></a>存储挂载/卸载监听</h3><h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;receiver android:name&#x3D;&quot;.USBReceiver&quot;&gt;</span><br><span class="line">                &lt;intent-filter&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_BAD_REMOVAL&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_BUTTON&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_CHECKING&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_EJECT&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_MOUNTED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_NOFS&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_REMOVED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_UNMOUNTED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_SHARED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_SCANNER_FINISHED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_SCANNER_SCAN_FILE&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;action android:name&#x3D;&quot;android.intent.action.MEDIA_SCANNER_STARTED&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;data android:scheme&#x3D;&quot;file&quot;&gt;&lt;&#x2F;data&gt;</span><br><span class="line">                &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;receiver&gt;</span><br></pre></td></tr></table></figure>

<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntentFilter iFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    iFilter.addAction(Intent.ACTION_MEDIA_EJECT);</span><br><span class="line">    iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);</span><br><span class="line">    iFilter.addAction(Intent.ACTION_MEDIA_REMOVED);</span><br><span class="line">    iFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);</span><br><span class="line">    iFilter.addDataScheme(<span class="string">"file"</span>);    <span class="comment">//注意这句一定添加</span></span><br><span class="line">    mBroadcastReceiver = <span class="keyword">new</span> BroadcastRecevicer();</span><br><span class="line">    registerReceiver(mBroadcastReceiver, iFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存储设备信息获取"><a href="#存储设备信息获取" class="headerlink" title="存储设备信息获取"></a>存储设备信息获取</h4><p><img src="/2020/03/12/androidexstorageinfo/20171118162222.png" alt></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateBarActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//获取usb连接的外置设备</span></span><br><span class="line">        showUsbDev();</span><br><span class="line">        <span class="comment">//获取usb外置存储详情</span></span><br><span class="line">        getDiskInfo();</span><br><span class="line">        <span class="keyword">for</span>(DiskInfo info : mDiskList)&#123;</span><br><span class="line">            Log.e(<span class="string">"Seeyou"</span>, <span class="string">"Disk Name : "</span> + info.name + <span class="string">"\n"</span></span><br><span class="line">                    + <span class="string">"Disk diskId : "</span> + info.diskId + <span class="string">"\n"</span>);</span><br><span class="line">            <span class="keyword">for</span>(DiskPartition partition : info.diskPartitions) &#123;</span><br><span class="line">                Log.e(<span class="string">"Seeyou"</span>, <span class="string">"\tPartition Name : "</span> + partition.name + <span class="string">"\n"</span></span><br><span class="line">                        + <span class="string">"\tPartition diskId : "</span> + partition.diskId + <span class="string">"\n"</span></span><br><span class="line">                        + <span class="string">"\tPartition partitionId : "</span> + partition.partitionId + <span class="string">"\n"</span></span><br><span class="line">                        + <span class="string">"\tPartition Path : "</span> + partition.path + <span class="string">"\n"</span></span><br><span class="line">                        + <span class="string">"\tPartition Total Size : "</span> + partition.totalSize + <span class="string">"\n"</span></span><br><span class="line">                        + <span class="string">"\tPartition Avlable Size: "</span> + partition.avlableSize + <span class="string">"\n"</span></span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showUsbDev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, UsbDevice&gt; deviceHashMap = ((UsbManager) getSystemService(USB_SERVICE)).getDeviceList();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry entry : deviceHashMap.entrySet()) &#123;</span><br><span class="line">            Log.e(<span class="string">"Seeyou"</span>, <span class="string">"detectUsbDeviceWithUsbManager: \n"</span> + entry.getKey() + <span class="string">"\n, "</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List mDiskList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDiskInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StorageManager mstorageManager = (StorageManager)<span class="keyword">this</span>.getApplicationContext().getSystemService(Context.STORAGE_SERVICE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method methodGetDisks = StorageManager.class.getMethod("getDisks");</span><br><span class="line">            Method methodGetStorageVolumes = StorageManager.class.getMethod("getVolumeList");</span><br><span class="line">            Method getVolumeById = StorageManager.class.getMethod("findVolumeById", String.class);</span><br><span class="line"></span><br><span class="line">            StorageVolume[] storageVolumes = (StorageVolume[]) methodGetStorageVolumes.invoke(mstorageManager);</span><br><span class="line">            List disks = (List) methodGetDisks.invoke(mstorageManager);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//DiskInfo</span></span><br><span class="line">            Class&lt;?&gt; diskIndoClass = Class.forName(<span class="string">"android.os.storage.DiskInfo"</span>);</span><br><span class="line">            Method mGetDiskId = diskIndoClass.getMethod(<span class="string">"getId"</span>);</span><br><span class="line">            Field diskName = diskIndoClass.getField(<span class="string">"label"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//StorageVolume</span></span><br><span class="line">            Class&lt;?&gt; storageVolumeClass = Class.forName(<span class="string">"android.os.storage.StorageVolume"</span>);</span><br><span class="line">            Method mGetStorageVolId = storageVolumeClass.getMethod(<span class="string">"getId"</span>);</span><br><span class="line">            Method mGetStorageVolDescription = storageVolumeClass.getMethod(<span class="string">"getDescription"</span>, Context<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            Method mGetStorageVolPath = storageVolumeClass.getMethod(<span class="string">"getPath"</span>);</span><br><span class="line">            Method isRemovable = storageVolumeClass.getMethod(<span class="string">"isRemovable"</span>);</span><br><span class="line">            Method getVolumeState = StorageManager.class.getMethod("getVolumeState", String.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//VolumeInfo</span></span><br><span class="line">            Class&lt;?&gt; volumeClass = Class.forName(<span class="string">"android.os.storage.VolumeInfo"</span>);</span><br><span class="line">            Method volumeDiskId = volumeClass.getMethod(<span class="string">"getDiskId"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; disks.size(); i++) &#123;</span><br><span class="line">                DiskInfo diskInfo = <span class="keyword">new</span> DiskInfo();</span><br><span class="line">                Parcelable parcelable = (Parcelable) disks.get(i);</span><br><span class="line">                diskInfo.diskId = (String) mGetDiskId.invoke(parcelable);</span><br><span class="line">                Log.e(<span class="string">"Seeyou"</span>, <span class="string">"diskid : "</span> + diskInfo.diskId);</span><br><span class="line">                String des = (String) diskName.get(parcelable);</span><br><span class="line">                Log.e(<span class="string">"Seeyou"</span>, <span class="string">"diskName : "</span> + des);</span><br><span class="line">                diskInfo.name = des;</span><br><span class="line">                mDiskList.add(diskInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; storageVolumes.length; j++) &#123;</span><br><span class="line">                DiskPartition partition = <span class="keyword">new</span> DiskPartition();</span><br><span class="line">                StorageVolume storageVolume = storageVolumes[j];</span><br><span class="line">                partition.partitionId = (String) mGetStorageVolId.invoke(storageVolume);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"emulated"</span>.equals(partition.partitionId)) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">                partition.name = (String) mGetStorageVolDescription.invoke(storageVolume, <span class="keyword">this</span>);</span><br><span class="line">                partition.path = (String) mGetStorageVolPath.invoke(storageVolume);</span><br><span class="line">                Boolean removeAble = ((Boolean) isRemovable.invoke(storageVolume)).booleanValue();</span><br><span class="line">                String state = (String) getVolumeState.invoke(mstorageManager, partition.path);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"mounted"</span>.equals(state) &amp;&amp; removeAble) &#123;</span><br><span class="line">                    partition.diskId = (String) volumeDiskId.invoke(getVolumeById.invoke(mstorageManager, partition.partitionId));</span><br><span class="line">                    <span class="keyword">for</span>(DiskInfo diskInfo : mDiskList) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(diskInfo.diskId.equals(partition.diskId)) &#123;</span><br><span class="line">                            getStorageBlockInfo(partition);</span><br><span class="line">                            diskInfo.diskPartitions.add(partition);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String diskId;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> ArrayList diskPartitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskPartition</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="keyword">public</span> String partitionId;</span><br><span class="line">        <span class="keyword">public</span> String diskId;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> totalSize;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> avlableSize;</span><br><span class="line">        <span class="keyword">public</span> String path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getStorageBlockInfo</span><span class="params">(DiskPartition info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(info.path))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        android.os.StatFs statfs = <span class="keyword">new</span> android.os.StatFs(info.path);</span><br><span class="line">        <span class="keyword">long</span> nBlocSize = statfs.getBlockSizeLong();</span><br><span class="line">        <span class="keyword">long</span> blockCountLong = statfs.getBlockCountLong();</span><br><span class="line">        <span class="keyword">long</span> nAvailaBlock = statfs.getAvailableBlocksLong();</span><br><span class="line">        info.totalSize = blockCountLong * nBlocSize;</span><br><span class="line">        info.avlableSize = nBlocSize * nAvailaBlock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>外置存储</tag>
        <tag>存储设备信息获取</tag>
      </tags>
  </entry>
  <entry>
    <title>AOSP原生app下载</title>
    <url>/2020/03/12/androidaospappcodedl/</url>
    <content><![CDATA[<p>国内清华大学镜像</p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/</a></p>
<p>单独下载某个module (以TVLauncher为例)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://aosp.tuna.tsinghua.edu.cn/platform/packages/apps/TV</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>aosp</tag>
        <tag>app源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Android获取蓝牙设备列表</title>
    <url>/2020/03/12/androidgetbtdevices/</url>
    <content><![CDATA[<p>Android设备如何获取蓝牙设备列表</p>
<a id="more"></a>

<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>需要BLUETOOTH的权限</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**     * 获取第三方蓝牙连接设备列表, 根据蓝牙设备名称判断, JJMatch为自己的蓝牙设备     */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ArrayList <span class="title">getThirdPartBlueList</span><span class="params">()</span></span>&#123;</span><br><span class="line">      BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();</span><br><span class="line">      Class bluetoothAdapterClass = BluetoothAdapter<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">      ArrayList deviceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Method method = bluetoothAdapterClass.getDeclaredMethod(<span class="string">"getConnectionState"</span>);</span><br><span class="line">          method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">int</span> state = (<span class="keyword">int</span>) method.invoke(adapter, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span>(state == BluetoothAdapter.STATE_CONNECTED || state == BluetoothAdapter.STATE_CONNECTING)&#123;</span><br><span class="line">              Set devices = adapter.getBondedDevices();</span><br><span class="line">              <span class="keyword">for</span>(BluetoothDevice device : devices)&#123;</span><br><span class="line">                  Method isConnectedMethod = BluetoothDevice.class.getDeclaredMethod("isConnected");</span><br><span class="line">                  method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">boolean</span> isConnected = (<span class="keyword">boolean</span>) isConnectedMethod.invoke(device);</span><br><span class="line">                  <span class="keyword">if</span>(isConnected)&#123;</span><br><span class="line">                      deviceList.add(device);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> deviceList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>不足的一点就是即时性, 如果及时刷新的话需要添加监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);</span><br><span class="line">filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);</span><br></pre></td></tr></table></figure>

<h4 id="获取设备名称"><a href="#获取设备名称" class="headerlink" title="获取设备名称:"></a>获取设备名称:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);</span><br></pre></td></tr></table></figure>

<p>如果同学你需要及时的展示蓝牙连接的列表, 则需要自己维护一个集合, 因为接收到蓝牙连接的广播的时候, 这个蓝牙设备还并不在绑定设设备中, 也就是说第一个方法是获取不到刚刚匹配连接的设备. 需要通过广播配合维护自己的集合来进行实时性的展示.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>蓝牙</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架otto简单使用</title>
    <url>/2020/03/12/androidottousage/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>otto 是 Square公司发布的一个发布-订阅模式框架，它基于Google Guava 项目中的event bus模块开发，针对Android平台做了优化和加强。虽然Square已经停止了对otto的更新并推荐使用RxJava和RxAndroid来替代它，但是otto的设计理念和源码仍旧值得学习，这一篇先来学习下otto的使用方法。</p>
<a id="more"></a>

<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h3><p><a href="https://github.com/square/otto" target="_blank" rel="noopener">https://github.com/square/otto</a></p>
<h3 id="定义消息类"><a href="#定义消息类" class="headerlink" title="定义消息类"></a>定义消息类</h3><p>与EventBus一样，我们接着定义消息类，它是一个bean文件，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusData</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message=message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单例封装Bus"><a href="#单例封装Bus" class="headerlink" title="单例封装Bus"></a>单例封装Bus</h3><p>otto的Bus类相当与EventBus中的EventBus类，它封装了otto的主要功能，但它不是个单例，每次都要用new创建出来，这样显然不是很方便，因此我们用单例模式将它封装起来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OttoBus</span> <span class="keyword">extends</span> <span class="title">Bus</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> OttoBus bus;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OttoBus</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OttoBus <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (OttoBus<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(bus==<span class="keyword">null</span>)&#123;</span><br><span class="line">                 bus = <span class="keyword">new</span> OttoBus();</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册和取消注册订阅事件"><a href="#注册和取消注册订阅事件" class="headerlink" title="注册和取消注册订阅事件"></a>注册和取消注册订阅事件</h3><p>otto同样需要注册和取消注册订阅事件，通过OttoBus得到Bus对象，调用Bus的register和unregister方法来注册和取消注册，同时我们定义一个button，点击这个button跳转到SecondActivity，SecondActivity用来发送事件。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button bt_jump;</span><br><span class="line">    <span class="keyword">private</span> TextView tv_message;</span><br><span class="line">    <span class="keyword">private</span> Bus bus;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv_message= (TextView) <span class="keyword">this</span>.findViewById(R.id.tv_message);</span><br><span class="line">        bt_jump= (Button) <span class="keyword">this</span>.findViewById(R.id.bt_jump);</span><br><span class="line">        bt_jump.setText(<span class="string">"跳转到SecondActivity"</span>);</span><br><span class="line">        bt_jump.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bus=OttoBus.getInstance();</span><br><span class="line">        bus.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">         <span class="comment">//取消注册订阅事件</span></span><br><span class="line">        bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="事件订阅者处理事件"><a href="#事件订阅者处理事件" class="headerlink" title="事件订阅者处理事件"></a>事件订阅者处理事件</h3><p>和EventBus一样用@Subscribe来订阅事件，在MainActivity中添加如下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(BusData data)</span> </span>&#123;</span><br><span class="line">      tv_message.setText(data.getMessage());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>同样的用textView来显示接收到的消息。</p>
<h3 id="使用post发送事件"><a href="#使用post发送事件" class="headerlink" title="使用post发送事件"></a>使用post发送事件</h3><p>创建SecondActivity，并设置一个button，点击发送事件，并finish掉自身，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button bt_jump;</span><br><span class="line">    <span class="keyword">private</span> OttoBus bus;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        bt_jump= (Button) <span class="keyword">this</span>.findViewById(R.id.bt_jump);</span><br><span class="line">        bt_jump.setText(<span class="string">"发送事件"</span>);</span><br><span class="line">        bt_jump.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                OttoBus.getInstance().post(<span class="keyword">new</span> BusData(<span class="string">"Hello world!"</span>));</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们运行程序点击MainActivity的”跳转到SecondActivity”按钮直接跳转到SecondActivity，再点击”发送事件”按钮，SecondActivity被finish掉回到MainActivity ，MainActivity 中的textView的文字变为了”刘望舒的博客更新了”。</p>
<h3 id="使用-Produce来发布事件"><a href="#使用-Produce来发布事件" class="headerlink" title="使用@Produce来发布事件"></a>使用@Produce来发布事件</h3><p>Produce注解用来生产发布事件，需要注意的是它生产事件前它需要注册，并且在生产完事件后需要取消注册。如果使用这种方法则在<strong>跳转到发布者所在的类中则会立即产生事件并触发订阅者</strong>，修改SecondActivity，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button bt_jump;</span><br><span class="line">    <span class="keyword">private</span> OttoBus bus;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        bt_jump= (Button) <span class="keyword">this</span>.findViewById(R.id.bt_jump);</span><br><span class="line">        bt_jump.setText(<span class="string">"发送事件"</span>);</span><br><span class="line">        bt_jump.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bus=OttoBus.getInstance();</span><br><span class="line">        bus.register(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Produce</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BusData <span class="title">setInitialContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BusData(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        bus.unregister(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在MainActivity跳转到SecondActivity时，MainActivity会马上收到事件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>otto</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架Eventbus简单使用</title>
    <url>/2020/03/12/androideventbususage/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>EventBus是针一款对Android的发布/订阅事件总线。它可以让我们很轻松的实现在Android各个组件之间传递消息，并且代码的可读性更好，耦合度更低。</p>
<a id="more"></a>

<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h3><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a></p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>(1)首先需要定义一个消息类，该类可以不继承任何基类也不需要实现任何接口。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2)在需要订阅事件的地方注册事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>(3)产生事件，即发送消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure>

<p>(4)处理消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.PostThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXX</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在3.0之前，EventBus还没有使用注解方式。消息处理的方法也只能限定于onEvent、onEventMainThread、onEventBackgroundThread和onEventAsync，分别代表四种线程模型。而在3.0之后，消息处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为PostThread），四种线程模型，下面会讲到。<br>注意，事件处理函数的访问权限必须为public，否则会报异常。</p>
<p>(5)取消消息订阅</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h3 id="有何优点"><a href="#有何优点" class="headerlink" title="有何优点"></a>有何优点</h3><p>采用消息发布/订阅的一个很大的优点就是代码的简洁性，并且能够有效地降低消息发布者和订阅者之间的耦合度。<br>举个例子，比如有两个界面，ActivityA和ActivityB，从ActivityA界面跳转到ActivityB界面后，ActivityB要给ActivityA发送一个消息，ActivityA收到消息后在界面上显示出来。我们最先想到的方法就是使用广播，使用广播实现此需求的代码如下：<br>首先需要在ActivityA中定义一个广播接收器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        mMessageView.setText(<span class="string">"Message from SecondActivity:"</span> + intent.getStringExtra(<span class="string">"message"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还需要在onCreate()方法中注册广播接收器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//注册广播</span></span><br><span class="line">    IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"message_broadcast"</span>);</span><br><span class="line">    mBroadcastReceiver = <span class="keyword">new</span> MessageBroadcastReceiver();</span><br><span class="line">    registerReceiver(mBroadcastReceiver, intentFilter);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在onDestory()方法中取消注册广播接收器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//取消广播注册</span></span><br><span class="line">    unregisterReceiver(mBroadcastReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们需要在ActivityB界面中发送广播消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send_broadcast).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String message = mMessageET.getText().toString();</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(message)) &#123;</span><br><span class="line">            message = <span class="string">"defaule message"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setAction(<span class="string">"message_broadcast"</span>);</span><br><span class="line">        intent.putExtra(<span class="string">"message"</span>, message);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看着上面的实现代码，感觉也没什么不妥，挺好的！下面对比看下使用EventBus如何实现。<br>根据文章最前面所讲的EventBus使用步骤，首先我们需要定义一个消息事件类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageEvent</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ActivityA界面中我们首先需要注册订阅事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    <span class="comment">//注册事件</span></span><br><span class="line">    EventBus.getDefault().register(<span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在onDestory()方法中取消订阅：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    <span class="comment">//取消事件注册</span></span><br><span class="line">    EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还要定义一个消息处理的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MainThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowMessageEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    mMessageView.setText(<span class="string">"Message from SecondActivity:"</span> + messageEvent.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，消息订阅者我们已经定义好了，我们还需要在ActivityB中发布消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    String message = mMessageET.getText().toString();</span><br><span class="line">        <span class="keyword">if</span>(TextUtils.isEmpty(message)) &#123;</span><br><span class="line">            message = <span class="string">"defaule message"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对比代码一看，有人会说了，这尼玛有什么区别嘛！说好的简洁呢？哥们，别着急嘛！我这里只是举了个简单的例子，仅仅从该例子来看，EventBus的优势没有体现出来。现在我将需求稍微改一下，ActivityA收到消息后，需要从网络服务器获取数据并将数据展示出来。如果使用广播，ActivityA中广播接收器代码应该这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//从服务器上获取数据</span></span><br><span class="line">            ......</span><br><span class="line">                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//将获取的数据展示在界面上</span></span><br><span class="line">                    ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这段代码，不知道你何感想，反正我是看着很不爽，嵌套层次太多，完全违反了Clean Code的原则。那使用EventBus来实现又是什么样呢？我们看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BackgroundThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGetDataEvent</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从服务器上获取数据</span></span><br><span class="line">    ......</span><br><span class="line">    EventBus.getDefault().post(<span class="keyword">new</span> ShowMessageEvent());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MainThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowDataEvent</span><span class="params">(ShowMessageEvent showMessageEvent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将获取的数据展示在界面上</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下以上两段代码就能很明显的感觉到EventBus的优势，代码简洁、层次清晰，大大提高了代码的可读性和可维护性。我这只是简单的加了一个小需求而已，随着业务越来越复杂，使用EventBus的优势愈加明显。</p>
<h3 id="常用API介绍"><a href="#常用API介绍" class="headerlink" title="常用API介绍"></a>常用API介绍</h3><h4 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h4><p>在EventBus的事件处理函数中需要指定线程模型，即指定事件处理函数运行所在的想线程。在上面我们已经接触到了EventBus的四种线程模型。那他们有什么区别呢？<br>在EventBus中的观察者通常有四种线程模型，分别是PostThread（默认）、MainThread、BackgroundThread与Async。</p>
<h4 id="PostThread："><a href="#PostThread：" class="headerlink" title="PostThread："></a>PostThread：</h4><p>如果使用事件处理函数指定了线程模型为PostThread，那么该事件在哪个线程发布出来的，事件处理函数就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。在线程模型为PostThread的事件处理函数中尽量避免执行耗时操作，因为它会阻塞事件的传递，甚至有可能会引起ANR。</p>
<h4 id="MainThread："><a href="#MainThread：" class="headerlink" title="MainThread："></a>MainThread：</h4><p>如果使用事件处理函数指定了线程模型为MainThread，那么不论事件是在哪个线程中发布出来的，该事件处理函数都会在UI线程中执行。该方法可以用来更新UI，但是不能处理耗时操作。</p>
<h4 id="BackgroundThread："><a href="#BackgroundThread：" class="headerlink" title="BackgroundThread："></a>BackgroundThread：</h4><p>如果使用事件处理函数指定了线程模型为BackgroundThread，那么如果事件是在UI线程中发布出来的，那么该事件处理函数就会在新的线程中运行，如果事件本来就是子线程中发布出来的，那么该事件处理函数直接在发布事件的线程中执行。在此事件处理函数中禁止进行UI更新操作。</p>
<h4 id="Async："><a href="#Async：" class="headerlink" title="Async："></a>Async：</h4><p>如果使用事件处理函数指定了线程模型为Async，那么无论事件在哪个线程发布，该事件处理函数都会在新建的子线程中执行。同样，此事件处理函数中禁止进行UI更新操作。<br>为了验证以上四个方法，我写了个小例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.PostThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventPostThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"PostThread"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MainThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventMainThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"MainThread"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BackgroundThread)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventBackgroundThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"BackgroundThread"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.Async)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventAsync</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"Async"</span>, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别使用上面四个方法订阅同一事件，打印他们运行所在的线程。首先我们在UI线程中发布一条MessageEvent的消息，看下日志打印结果是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            Log.e(<span class="string">"postEvent"</span>, Thread.currentThread().getName());</span><br><span class="line">            EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2689-2689&#x2F;com.lling.eventbusdemo E&#x2F;postEvent﹕ main2689-2689&#x2F;com.lling.eventbusdemo E&#x2F;PostThread﹕ main2689-3064&#x2F;com.lling.eventbusdemo E&#x2F;Async﹕ pool-1-thread-12689-2689&#x2F;com.lling.eventbusdemo E&#x2F;MainThread﹕ main2689-3065&#x2F;com.lling.eventbusdemo E&#x2F;BackgroundThread﹕ pool-1-thread-2</span><br></pre></td></tr></table></figure>

<p>从日志打印结果可以看出，如果在UI线程中发布事件，则线程模型为PostThread的事件处理函数也执行在UI线程，与发布事件的线程一致。线程模型为Async的事件处理函数执行在名字叫做pool-1-thread-1的新的线程中。而MainThread的事件处理函数执行在UI线程，BackgroundThread的时间处理函数执行在名字叫做pool-1-thread-2的新的线程中。</p>
<p>我们再看看在子线程中发布一条MessageEvent的消息时，会有什么样的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">findViewById(R.id.send).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Log.e(<span class="string">"postEvent"</span>, Thread.currentThread().getName());</span><br><span class="line">                    EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3468-3945&#x2F;com.lling.eventbusdemo E&#x2F;postEvent﹕ Thread-1253468-3945&#x2F;com.lling.eventbusdemo E&#x2F;PostThread﹕ Thread-1253468-3945&#x2F;com.lling.eventbusdemo E&#x2F;BackgroundThread﹕ Thread-1253468-3946&#x2F;com.lling.eventbusdemo E&#x2F;Async﹕ pool-1-thread-13468-3468&#x2F;com.lling.eventbusdemo E&#x2F;MainThread﹕ main</span><br></pre></td></tr></table></figure>

<p>从日志打印结果可以看出，如果在子线程中发布事件，则线程模型为PostThread的事件处理函数也执行在子线程，与发布事件的线程一致（都是Thread-125）。BackgroundThread事件模型也与发布事件在同一线程执行。Async则在一个名叫pool-1-thread-1的新线程中执行。MainThread还是在UI线程中执行。</p>
<p>上面一个例子充分验证了指定不同线程模型的事件处理方法执行所在的线程。</p>
<h4 id="黏性事件"><a href="#黏性事件" class="headerlink" title="黏性事件"></a>黏性事件</h4><p>除了上面讲的普通事件外，EventBus还支持发送黏性事件。何为黏性事件呢？简单讲，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。具体用法如下：</p>
<p>订阅黏性事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().register(StickyModeActivity.<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>黏性事件处理函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XXX</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送黏性事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"test"</span>));</span><br></pre></td></tr></table></figure>

<p>处理消息事件以及取消订阅和上面方式相同。</p>
<p>看个简单的黏性事件的例子，为了简单起见我这里就在一个Activity里演示了。</p>
<p>Activity代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StickyModeActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_sticky_mode);</span><br><span class="line">    findViewById(R.id.post).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            EventBus.getDefault().postSticky(<span class="keyword">new</span> MessageEvent(<span class="string">"test"</span> + index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    findViewById(R.id.regist).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            EventBus.getDefault().registerSticky(StickyModeActivity.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    findViewById(R.id.unregist).setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            EventBus.getDefault().unregister(StickyModeActivity.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.PostThread, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventPostThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"PostThread"</span>, messageEvent.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MainThread, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventMainThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"MainThread"</span>, messageEvent.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BackgroundThread, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventBackgroundThread</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"BackgroundThread"</span>, messageEvent.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.Async, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessageEventAsync</span><span class="params">(MessageEvent messageEvent)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"Async"</span>, messageEvent.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局代码activity_sticky_mode.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:paddingLeft=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingRight=<span class="string">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    android:paddingTop=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    android:orientation=<span class="string">"vertical"</span></span><br><span class="line">    tools:context=<span class="string">"com.lling.eventbusdemo.StickyModeActivity"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button android:id=<span class="string">"@+id/post"</span> android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> android:text=<span class="string">"Post"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button android:id=<span class="string">"@+id/regist"</span> android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> android:text=<span class="string">"Regist"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button android:id=<span class="string">"@+id/unregist"</span> android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span> android:text=<span class="string">"UnRegist"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p>代码很简单，界面上三个按钮，一个用来发送黏性事件，一个用来订阅事件，还有一个用来取消订阅的。首先在未订阅的情况下点击发送按钮发送一个黏性事件，然后点击订阅，会看到日志打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15246-15246&#x2F;com.lling.eventbusdemo E&#x2F;PostThread﹕ test0</span><br><span class="line">15246-15391&#x2F;com.lling.eventbusdemo E&#x2F;Async﹕ test0</span><br><span class="line">15246-15246&#x2F;com.lling.eventbusdemo E&#x2F;MainThread﹕ test0</span><br><span class="line">15246-15393&#x2F;com.lling.eventbusdemo E&#x2F;BackgroundThread﹕ test0</span><br></pre></td></tr></table></figure>

<p>这就是粘性事件，能够收到订阅之前发送的消息。但是它只能收到最新的一次消息，比如说在未订阅之前已经发送了多条黏性消息了，然后再订阅只能收到最近的一条消息。这个我们可以验证一下，我们连续点击5次POST按钮发送5条黏性事件，然后再点击REGIST按钮订阅，打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6980-6980&#x2F;com.lling.eventbusdemo E&#x2F;PostThread﹕ test4</span><br><span class="line">6980-6980&#x2F;com.lling.eventbusdemo E&#x2F;MainThread﹕ test4</span><br><span class="line">6980-7049&#x2F;com.lling.eventbusdemo E&#x2F;Async﹕ test4</span><br><span class="line">6980-7048&#x2F;com.lling.eventbusdemo E&#x2F;BackgroundThread﹕ test4</span><br></pre></td></tr></table></figure>

<p>由打印结果可以看出，确实是只收到最近的一条黏性事件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android框架</tag>
        <tag>eventbus</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架Retorfit简单使用</title>
    <url>/2020/03/12/androidretorfituse/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Retrofit是Square公司开发的一款针对Android网络请求的框架, Retrofit2底层基于OkHttp实现的, 而OkHttp现在已经得到Google官方认可.</p>
<p>Retrofit的官方教程 : <a href="http://square.github.io/retrofit" target="_blank" rel="noopener">http://square.github.io/retrofit</a><br>Githug地址: <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a></p>
<a id="more"></a>

<p>除了Retrofit的依赖包之外, 可能还会用到以下的依赖进行数据的解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Gson: com.squareup.retrofit2:converter-gson</span><br><span class="line">Jackson: com.squareup.retrofit2:converter-jackson</span><br><span class="line">Moshi: com.squareup.retrofit2:converter-moshi</span><br><span class="line">Protobuf: com.squareup.retrofit2:converter-protobuf</span><br><span class="line">Wire: com.squareup.retrofit2:converter-wire</span><br><span class="line">Simple XML: com.squareup.retrofit2:converter-simplexml</span><br><span class="line">Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</span><br></pre></td></tr></table></figure>

<h3 id="GET-amp-POST-请求"><a href="#GET-amp-POST-请求" class="headerlink" title="GET&amp;POST 请求"></a>GET&amp;POST 请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"demo1"</span>)</span><br><span class="line">    <span class="function">Call&lt;String&gt; <span class="title">getDate</span><span class="params">(@Query(<span class="string">"ip"</span>)</span> String ip)</span>;</span><br><span class="line">    <span class="comment">//也可以写成</span></span><br><span class="line">    <span class="comment">//@GET("demo1?ip=80") GET的请求参数直接卸载请求地址里面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"demo2"</span>)</span><br><span class="line">    <span class="function">Call&lt;String&gt; <span class="title">getDate</span><span class="params">(@Field(<span class="string">"ip"</span>)</span> String ip)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> getDate&#123;</span><br><span class="line"> Retrofit mRetrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">"http://www.baidu.com/"</span>)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    Demo1 demo1 = mRetrofit.create(Demo1<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Demo2 demo2 = mRetrofit.create(Demo2<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Call&lt;String&gt; date1 = demo1.getDate(<span class="string">"80"</span>);</span><br><span class="line">    Call&lt;String&gt; date2 = demo2.getDate(<span class="string">"90"</span>);</span><br><span class="line">    Request request1 = date1.request();</span><br><span class="line">    Request request2 = date2.request();</span><br><span class="line"></span><br><span class="line">    Log.e(<span class="string">"Seeyou"</span>, <span class="string">"request1 url : "</span> + request1.url().toString() + <span class="string">" body : "</span> + (request1.body() != <span class="keyword">null</span> ? request1.body().toString() : <span class="string">"null"</span>));</span><br><span class="line">    Log.e(<span class="string">"Seeyou"</span>, <span class="string">"request2 url : "</span> + request2.url().toString() + <span class="string">" body : "</span> + (request2.body() != <span class="keyword">null</span> ? (((FormBody)request2.body()).encodedName(<span class="number">0</span>) + <span class="string">" : "</span> + ((FormBody)request2.body()).encodedValue(<span class="number">0</span>)): <span class="string">"null"</span>));</span><br><span class="line"></span><br><span class="line">        date1.enqueue(<span class="keyword">new</span> retrofit2.Callback&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;String&gt; call, retrofit2.Response&lt;String&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;String&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    date2.enqueue(<span class="keyword">new</span> retrofit2.Callback&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;String&gt; call, retrofit2.Response&lt;String&gt; response)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;String&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android框架</tag>
        <tag>retorfit</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架OkHttp简单使用</title>
    <url>/2020/03/12/androidokttpuse/</url>
    <content><![CDATA[<h3 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址:"></a>Github地址:</h3><p><a href="https://github.com/square/okhttp" target="_blank" rel="noopener">https://github.com/square/okhttp</a></p>
<a id="more"></a>

<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mOkHttpClient=<span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder().url(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line">    <span class="comment">//可以省略，默认是GET请求</span></span><br><span class="line">    requestBuilder.method(<span class="string">"GET"</span>,<span class="keyword">null</span>);</span><br><span class="line">    Request request = requestBuilder.build();</span><br><span class="line">    Call mcall= mOkHttpClient.newCall(request);</span><br><span class="line">    mcall.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != response.cacheResponse()) &#123;</span><br><span class="line">                String str = response.cacheResponse().toString();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.body().string();</span><br><span class="line">                String str = response.networkResponse().toString();</span><br><span class="line">            &#125;</span><br><span class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(getApplicationContext(), <span class="string">"请求成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PostRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mOkHttpClient=<span class="keyword">new</span> OkHttpClient();</span><br><span class="line">     RequestBody formBody = <span class="keyword">new</span> FormBody.Builder()</span><br><span class="line">             .add(<span class="string">"size"</span>, <span class="string">"10"</span>)</span><br><span class="line">             .build();</span><br><span class="line">     Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">             .url(<span class="string">"http://api.1-blog.com/biz/bizserver/article/list.do"</span>)</span><br><span class="line">             .post(formBody)</span><br><span class="line">             .build();</span><br><span class="line">     Call call = mOkHttpClient.newCall(request);</span><br><span class="line">     call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">             String str = response.body().string();</span><br><span class="line">             runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     Toast.makeText(getApplicationContext(), <span class="string">"请求成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postUploadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mOkHttpClient=<span class="keyword">new</span> OkHttpClient();</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"/sdcard/demo.txt"</span>);</span><br><span class="line">    Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">            .url(<span class="string">"https://www.funytao.com"</span>)</span><br><span class="line">            .post(RequestBody.create(MediaType.parse(<span class="string">"text/plain; charset=utf-8"</span>), file))</span><br><span class="line">            .build();</span><br><span class="line">        mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                Log.i(<span class="string">"wangshu"</span>,response.body().string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">     String url = <span class="string">"http://www.baidu/pic/201603/26/1458988468_5804.jpg"</span>;</span><br><span class="line">     Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">     mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line">             InputStream inputStream = response.body().byteStream();</span><br><span class="line">             FileOutputStream fileOutputStream = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"/sdcard/demo.jpg"</span>));</span><br><span class="line">                 <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                 <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                 <span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                     fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">                 &#125;</span><br><span class="line">                 fileOutputStream.flush();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Log.d(<span class="string">"wangshu"</span>, <span class="string">"文件下载成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File sdcache = getExternalCacheDir();</span><br><span class="line"><span class="keyword">int</span> cacheSize = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">        .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">        .readTimeout(<span class="number">20</span>, TimeUnit.SECONDS)</span><br><span class="line">        .cache(<span class="keyword">new</span> Cache(sdcache.getAbsoluteFile(), cacheSize));</span><br><span class="line">OkHttpClient mOkHttpClient=builder.build();</span><br></pre></td></tr></table></figure>

<h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call mcall= mOkHttpClient.newCall(request);</span><br><span class="line">mcall.cancel();</span><br></pre></td></tr></table></figure>

<p>以上就是OkHttp3的简单使用, 需要网络权限, 或者本地存储的读写权限需要注意一下.</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android框架</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Git仓库管理线上代码</title>
    <url>/2020/03/12/gitmangeronlinecode/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇blog主要说明的是如何将本地的项目代码通过git直接push到线上发布，未作更深的权限管理及linux的用户管理问题的考量。</p>
<a id="more"></a>

<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class="line">$ yum install git</span><br></pre></td></tr></table></figure>

<h5 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h5><p>以root用户及目录为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /root</span><br><span class="line">$ mkdir gittest</span><br><span class="line">$ <span class="built_in">cd</span> gittest</span><br><span class="line">$ git init --bare test.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/test.git/</span><br></pre></td></tr></table></figure>

<h5 id="git仓库与项目源码分离"><a href="#git仓库与项目源码分离" class="headerlink" title="git仓库与项目源码分离"></a>git仓库与项目源码分离</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> test.git/hooks</span><br><span class="line">$ vi post-receive</span><br></pre></td></tr></table></figure>

<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git --work-tree&#x3D;&#x2F;root&#x2F;gittest --git-dir&#x3D;&#x2F;root&#x2F;gittest&#x2F;test.git checkout -f</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chtl D 保存</span><br></pre></td></tr></table></figure>



<p>/root/gittest  #代码目录<br>/root/gittest/test.git   #git库目录</p>
<p>文件权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 766 post-receive</span><br></pre></td></tr></table></figure>



<h4 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> root@ServerName:/root/gittest/test.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>即可在服务端/root/gittest目录下查看到提交的文件, 把/root/gittest作为web目录, 即可.</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
        <tag>git远程仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO</title>
    <url>/2020/03/12/nio/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<p>所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</p>
<p>由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO(非阻塞IO).</p>
<a id="more"></a>

<h3 id="Java-NIO-由以下几个核心部分组成："><a href="#Java-NIO-由以下几个核心部分组成：" class="headerlink" title="Java NIO 由以下几个核心部分组成："></a>Java NIO 由以下几个核心部分组成：</h3><ul>
<li>Buffer</li>
<li>Channel</li>
<li>Selector</li>
</ul>
<p>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p>
<h4 id="Buffer的使用"><a href="#Buffer的使用" class="headerlink" title="Buffer的使用"></a>Buffer的使用</h4><p>三个关键概念:</p>
<ol>
<li>capacity容量</li>
<li>position位置</li>
<li>limit限制</li>
</ol>
<h5 id="容量（Capacity）"><a href="#容量（Capacity）" class="headerlink" title="容量（Capacity）"></a>容量（Capacity）</h5><p>作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。</p>
<h5 id="位置（Position）"><a href="#位置（Position）" class="headerlink" title="位置（Position）"></a>位置（Position）</h5><p>当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1。 当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。</p>
<h5 id="上限（Limit）"><a href="#上限（Limit）" class="headerlink" title="上限（Limit）"></a>上限（Limit）</h5><p>在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。 一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。 数据读取的上限时buffer中已有的数据，也就是limit的位置（原position所指的位置）。</p>
<h5 id="使用-利用Buffer读写数据，通常遵循四个步骤："><a href="#使用-利用Buffer读写数据，通常遵循四个步骤：" class="headerlink" title="使用 利用Buffer读写数据，通常遵循四个步骤："></a>使用 利用Buffer读写数据，通常遵循四个步骤：</h5><ol>
<li><p>把数据写入buffer；</p>
</li>
<li><p>调用flip；</p>
</li>
<li><p>从Buffer中读取数据；</p>
</li>
<li><p>调用buffer.clear()</p>
</li>
</ol>
<h5 id="分配一个Buffer（Allocating-a-Buffer）"><a href="#分配一个Buffer（Allocating-a-Buffer）" class="headerlink" title="分配一个Buffer（Allocating a Buffer）"></a>分配一个Buffer（Allocating a Buffer）</h5><p>为了获取一个Buffer对象，你必须先分配。每个Buffer实现类都有一个allocate()方法用于分配内存。下面看一个实例,开辟一个48字节大小的buffer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure>

<p>开辟一个1024个字符的CharBuffer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。</p>
<h5 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h5><p>当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer方式： 调用clear()，一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。</p>
<h4 id="Channel的使用"><a href="#Channel的使用" class="headerlink" title="Channel的使用"></a>Channel的使用</h4><p>Java NIO Channel通道和流非常相似，主要有以下几点区别：</p>
<ul>
<li>通道可以读也可以写，流一般来说是单向的（只能读或者写）。</li>
<li>通道可以异步读写。</li>
<li>通道总是基于缓冲区Buffer来读写。</li>
</ul>
<p>正如上面提到的，我们可以从通道中读取数据，写入到buffer；也可以中buffer内读数据，写入到通道中。</p>
<h5 id="Channel的实现类有："><a href="#Channel的实现类有：" class="headerlink" title="Channel的实现类有："></a>Channel的实现类有：</h5><ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel …</li>
</ul>
<p><strong>FileChannel</strong>用于文件的数据读写。<br><strong>DatagramChannel</strong>用于UDP的数据读写。<br><strong>SocketChannel</strong>用于TCP的数据读写。<br><strong>ServerSocketChannel</strong>允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel。</p>
<h5 id="Channel使用实例"><a href="#Channel使用实例" class="headerlink" title="Channel使用实例"></a>Channel使用实例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">  buf.flip();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> buf.clear();</span><br><span class="line"> bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nio</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器</title>
    <url>/2020/03/12/javacollector/</url>
    <content><![CDATA[<p>Java集合架构</p>
<p><img src="/2020/03/12/javacollector/collector.png" alt></p>
<a id="more"></a>

<h3 id="抽象特性"><a href="#抽象特性" class="headerlink" title="抽象特性"></a>抽象特性</h3><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><p>单数据存储</p>
<ul>
<li>list 有序 可重</li>
<li>set 无需 不可重</li>
<li>queue 有序 可重 队列FIFO</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>键值对映射关系存储</p>
<h3 id="实现特性-简述"><a href="#实现特性-简述" class="headerlink" title="实现特性(简述)"></a>实现特性(简述)</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。</p>
<p><strong>容量(Capacity)和负载因子(Load factor)</strong></p>
<p>简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话，不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。</p>
<p><strong>put函数的实现</strong></p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ol>
<p><strong>get函数的实现</strong></p>
<p>在理解了put之后，get就很简单了。大致思路如下：</p>
<ol>
<li>bucket里的第一个节点，直接命中；</li>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry</li>
</ol>
<p>若为树，则在树中通过key.equals(k)查找，O(logn)；<br>若为链表，则在链表中通过key.equals(k)查找，O(n)。</p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ol>
<li>TreeMap是一个有序的key-value集合, 它内部是通过红-黑树实现的, 它支持序列化.</li>
<li>TreeMap的存储结构是按照红-黑树存储的, 每个key-value对也存储在一个Entry里, 只不过这 个Entry和前面HashMap或者HashTable中的Entry不同, TreeMap的Entry其实是红-黑树的一个节点。</li>
</ol>
<h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><p>LinkedHashMap是Hash表和链表的实现, 并且依靠着双向链表保证了迭代顺序是插入的顺序.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>容器</tag>
        <tag>collector</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Java IO</title>
    <url>/2020/03/12/javaio/</url>
    <content><![CDATA[<h3 id="JavaIO架构"><a href="#JavaIO架构" class="headerlink" title="JavaIO架构"></a>JavaIO架构</h3><p><img src="/2020/03/12/javaio/javaio.png" alt></p>
<a id="more"></a>

<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>InputStream<br>OutputStream</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Reader<br>Writer</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>File</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>Java版本特性</title>
    <url>/2020/03/12/javaversiondetail/</url>
    <content><![CDATA[<h3 id="版本下载列表"><a href="#版本下载列表" class="headerlink" title="版本下载列表:"></a>版本下载列表:</h3><p><a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/archive-139210.html</a></p>
<a id="more"></a>

<h3 id="Java-1-0"><a href="#Java-1-0" class="headerlink" title="Java 1.0"></a>Java 1.0</h3><p>1996-01-23 Oak(橡树)</p>
<blockquote>
<p>初代版本，伟大的一个里程碑，但是是纯解释运行，使用外挂JIT，性能比较差，运行速度慢。</p>
</blockquote>
<h3 id="Java-n-1-1"><a href="#Java-n-1-1" class="headerlink" title="Java n 1.1"></a>Java n 1.1</h3><p>1997-02-19</p>
<blockquote>
<ul>
<li>JDBC(Java DataBase Connectivity);</li>
<li>支持内部类;</li>
<li>RMI(Remote Method Invocation) ;</li>
<li>反射;</li>
<li>Java Bean;</li>
</ul>
</blockquote>
<h3 id="Java-1-2"><a href="#Java-1-2" class="headerlink" title="Java 1.2"></a>Java 1.2</h3><p>1998-12-08 Playground(操场)</p>
<blockquote>
<ul>
<li>集合框架;</li>
<li>JIT(Just In Time)编译器;</li>
<li>对打包的Java文件进行数字签名;</li>
<li>JFC(Java Foundation Classes), 包括Swing 1.0, 拖放和Java2D类库;</li>
<li>Java插件;</li>
<li>JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型;</li>
<li>Applet中添加声音支持.</li>
</ul>
</blockquote>
<h3 id="Java-1-3"><a href="#Java-1-3" class="headerlink" title="Java 1.3"></a>Java 1.3</h3><p>2000-05-08 Kestrel(红隼)</p>
<blockquote>
<ul>
<li>Java Sound API;</li>
<li>jar文件索引;</li>
<li>对Java的各个方面都做了大量优化和增强;</li>
</ul>
</blockquote>
<h3 id="Java-1-4"><a href="#Java-1-4" class="headerlink" title="Java 1.4"></a>Java 1.4</h3><p>2002-02-13 Merlin(隼)</p>
<blockquote>
<ul>
<li>XML处理;</li>
<li>Java打印服务;</li>
<li>Logging API;</li>
<li>Java Web Start;</li>
<li>JDBC 3.0 API;</li>
<li>断言;</li>
<li>Preferences API;</li>
<li>链式异常处理;</li>
<li>支持IPV6;</li>
<li>支持正则表达式;</li>
<li>引入Imgae I/O API.</li>
</ul>
</blockquote>
<h3 id="Java-5"><a href="#Java-5" class="headerlink" title="Java 5"></a>Java 5</h3><p>2004-09-30 Tiger(老虎)</p>
<blockquote>
<ul>
<li>泛型;</li>
<li>增强循环,可以使用迭代方式;</li>
<li>自动装箱与自动拆箱;</li>
<li>类型安全的枚举;</li>
<li>可变参数;</li>
<li>静态引入;</li>
<li>元数据(注解);</li>
<li>Instrumentation;</li>
</ul>
</blockquote>
<h3 id="Java-6"><a href="#Java-6" class="headerlink" title="Java 6"></a>Java 6</h3><p>2006-12-11 Mustang(野马)</p>
<blockquote>
<ul>
<li>支持脚本语言;</li>
<li>JDBC 4.0API;</li>
<li>Java Compiler API;</li>
<li>可插拔注解;</li>
<li>增加对Native PKI(Public Key Infrastructure), Java GSS(Generic Security Service),Kerberos和LDAP(Lightweight Directory Access Protocol)支持;</li>
<li>继承Web Services;</li>
</ul>
</blockquote>
<h3 id="Java-7"><a href="#Java-7" class="headerlink" title="Java 7"></a>Java 7</h3><p>2011-07-28 Dolphin(海豚)</p>
<blockquote>
<ul>
<li>switch语句块中允许以字符串作为分支条件;</li>
<li>在创建泛型对象时应用类型推断;</li>
<li>在一个语句块中捕获多种异常;</li>
<li>支持动态语言;</li>
<li>支持try-with-resources(在一个语句块中捕获多种异常);</li>
<li>引入Java NIO.2开发包;</li>
<li>数值类型可以用二进制字符串表示,并且可以在字符串表示中添加下划线;</li>
<li>钻石型语法(在创建泛型对象时应用类型推断);</li>
<li>null值得自动处理;</li>
</ul>
</blockquote>
<h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><p>2014-03-18 </p>
<blockquote>
<ul>
<li>方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li>
<li>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。</li>
<li>新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li>
<li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li>
<li>Date Time API − 加强对日期与时间的处理。</li>
<li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li>
<li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li>
</ul>
</blockquote>
<p>详细参阅:<a href="https://github.com/MarkTsy/TaoNote/blob/master/JAVA/%E5%8F%82%E9%98%85" target="_blank" rel="noopener">http://www.runoob.com/java/java8-new-features.html</a></p>
<h3 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h3><p>2017-09-22</p>
<blockquote>
<ul>
<li>模块系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。</li>
<li>REPL (JShell)：交互式编程环境。</li>
<li>HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。</li>
<li>改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</li>
<li>多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</li>
<li>集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。</li>
<li>私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。</li>
<li>进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</li>
<li>改进的 Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</li>
<li>改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</li>
<li>改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。</li>
<li>改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。</li>
<li>改进 Optional 类：java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。</li>
<li>多分辨率图像 API：定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。</li>
<li>改进的 CompletableFuture API ： CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。</li>
<li>轻量级的 JSON API：内置了一个轻量级的JSON API</li>
<li>响应式流（Reactive Streams) API: Java 9中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。</li>
</ul>
</blockquote>
<p>详细参考:<a href="https://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.runoob.com/java/java9-new-features.html</a></p>
<h3 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h3><p>2018-03-21</p>
<p>根据官网的公开资料，共有12个重要特性，如下：</p>
<blockquote>
<ul>
<li>JEP286，var 局部变量类型推断。</li>
<li>JEP296，将原来用 Mercurial 管理的众多 JDK 仓库代码，合并到一个仓库中，简化开发和管理过程。</li>
<li>JEP304，统一的垃圾回收接口。</li>
<li>JEP307，G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>JEP310，应用程序类数据 (AppCDS) 共享，通过跨进程共享通用类元数据来减少内存占用空间，和减少启动时间。</li>
<li>JEP312，ThreadLocal 握手交互。在不进入到全局 JVM 安全点 (Safepoint) 的情况下，对线程执行回调。优化可以只停止单个线程，而不是停全部线程或一个都不停。</li>
<li>JEP313，移除 JDK 中附带的 javah 工具。可以使用 javac -h 代替。</li>
<li>JEP314，使用附加的 Unicode 语言标记扩展。</li>
<li>JEP317，能将堆内存占用分配给用户指定的备用内存设备。</li>
<li>JEP317，使用 Graal 基于 Java 的编译器，可以预先把 Java 代码编译成本地代码来提升效能。</li>
<li>JEP318，在 OpenJDK 中提供一组默认的根证书颁发机构证书。开源目前 Oracle 提供的的 Java SE 的根证书，这样 OpenJDK 对开发人员使用起来更方便。</li>
<li>JEP322，基于时间定义的发布版本，即上述提到的发布周期。版本号为$FEATURE.$INTERIM.$UPDATE.$PATCH，分别是大版本，中间版本，升级包和补丁版本。</li>
</ul>
</blockquote>
<h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><p>2018-09-25 </p>
<p>翻译后的新特性有：</p>
<blockquote>
<ul>
<li>181:Nest-Based访问控制</li>
<li>309:动态类文件常量</li>
<li>315:改善Aarch64 intrinsic</li>
<li>318:无操作垃圾收集器</li>
<li>320:消除Java EE和CORBA模块</li>
<li>321:HTTP客户端(标准)</li>
<li>323:局部变量的语法λ参数</li>
<li>324:Curve25519和Curve448关键协议</li>
<li>327:Unicode 10</li>
<li>328:飞行记录器</li>
<li>329:ChaCha20和Poly1305加密算法</li>
<li>330:发射一列纵队源代码程序</li>
<li>331:低开销堆分析</li>
<li>332:传输层安全性(Transport Layer Security,TLS)1.3</li>
<li>333:动作:一个可伸缩的低延迟垃圾收集器 (实验)</li>
<li>335:反对Nashorn JavaScript引擎</li>
<li>336:反对Pack200工具和API</li>
</ul>
</blockquote>
<h3 id="Java-12"><a href="#Java-12" class="headerlink" title="Java 12"></a>Java 12</h3><p>2019-03-19</p>
<p>作为“功能性版本”，JDK 12 总共包含 8 个新的 JEP ，分别为：</p>
<blockquote>
<ul>
<li>189: Shenandoah: A Low-Pause-Time Garbage Collector (Experimental) ：新增一个名为 Shenandoah 的垃圾回收器，它通过在 Java 线程运行的同时进行疏散 (evacuation) 工作来减少停顿时间。</li>
<li>230: Microbenchmark Suite：新增一套微基准测试，使开发者能够基于现有的 Java Microbenchmark Harness（JMH）轻松测试 JDK 的性能，并创建新的基准测试。</li>
<li>325: Switch Expressions (Preview) ：对 switch 语句进行扩展，使其可以用作语句或表达式，简化日常代码。</li>
<li>334: JVM Constants API ：引入一个 API 来对关键类文件 (key class-file) 和运行时工件的名义描述（nominal descriptions）进行建模，特别是那些可从常量池加载的常量。</li>
<li>340: One AArch64 Port, Not Two ：删除与 arm64 端口相关的所有源码，保留 32 位 ARM 移植和 64 位 aarch64 移植。</li>
<li>341: Default CDS Archives ：默认生成类数据共享（CDS）存档。</li>
<li>344: Abortable Mixed Collections for G1 ：当 G1 垃圾回收器的回收超过暂停目标，则能中止垃圾回收过程。</li>
<li>346: Promptly Return Unused Committed Memory from G1 ：改进 G1 垃圾回收器，以便在空闲时自动将 Java 堆内存返回给操作系统。</li>
</ul>
</blockquote>
<hr>
<p>最新的更新信息: <a href="http://openjdk.java.net/jeps/0" target="_blank" rel="noopener">http://openjdk.java.net/jeps/0</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>版本特性</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架Volley使用</title>
    <url>/2020/03/11/androidvolleyuse/</url>
    <content><![CDATA[<p><img src="/2020/03/11/androidvolleyuse/u=4181556078,2857514256&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在2013年Google I/O大会上推出了一个新的网络通信框架Volley。Volley可是说是把AsyncHttpClient和Universal-Image-Loader的优点集于了一身，既可以像AsyncHttpClient一样非常简单地进行HTTP通信，也可以像Universal-Image-Loader一样轻松加载网络上的图片。除了简单易用之外，Volley在性能方面也进行了大幅度的调整，它的<strong>设计目标</strong>就是非常适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。</p>
<p>虽然时至今日，volley在网络框架中的使用度并不高，但是针对它的特性而言，在某些网络请求的需求中，还是可以考虑的. </p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="AndroidStudio"><a href="#AndroidStudio" class="headerlink" title="AndroidStudio"></a>AndroidStudio</h5><p>直接在依赖中搜索添加即可</p>
<h5 id="jar包下载"><a href="#jar包下载" class="headerlink" title="jar包下载:"></a>jar包下载:</h5><p><a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/volley</a> </p>
<h5 id="github地址："><a href="#github地址：" class="headerlink" title="github地址："></a>github地址：</h5><p><a href="https://github.com/mcxiaoke/android-volley" target="_blank" rel="noopener">https://github.com/mcxiaoke/android-volley</a> </p>
<h5 id="基本使用流程"><a href="#基本使用流程" class="headerlink" title="基本使用流程:"></a>基本使用流程:</h5><ol>
<li>创建Request请求实例</li>
<li>获取请求列队</li>
<li>将请求添加到列队</li>
<li>override回调方法</li>
</ol>
<h5 id="创建队列方法"><a href="#创建队列方法" class="headerlink" title="创建队列方法:"></a>创建队列方法:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestQueue mQueue = <span class="keyword">null</span>; mQueue = Volley.newRequestQueue(context);</span><br></pre></td></tr></table></figure>

<h5 id="创建请求-Request"><a href="#创建请求-Request" class="headerlink" title="创建请求(Request):"></a>创建请求(Request):</h5><p><strong>StringRequest</strong></p>
<p>StringRequest的默认请求方式为GET,使用其他请求方式可以用其另一种重载形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">"http://xxx"</span>;</span><br><span class="line">StringRequest request = <span class="keyword">new</span> StringRequest(url,<span class="keyword">new</span> Response.Listener&lt;String&gt;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String response)</span><span class="comment">//success callbacks</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">//handle it &#125;</span></span><br><span class="line"> &#125;, <span class="keyword">new</span> Response.ErrorListener()<span class="comment">//error callbacks</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span></span><br><span class="line"><span class="function"> </span>&#123; error.printStackTrace(); &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//add request to queue...</span></span><br><span class="line"> mQueue.add(request);</span><br></pre></td></tr></table></figure>

<p>Response.Listener处理请求成功时的回调。</p>
<p>Response.ErrorListener处理失败时的回调。</p>
<p><strong>JsonRequest</strong><br>这里的JsonObject是android内置的org.json库，而不是自家的Gson，这点需要注意。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; params = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"> params.put(<span class="string">"name"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"> params.put(<span class="string">"age"</span>,<span class="string">"17"</span>);</span><br><span class="line"> JSONObject jsonRequest = <span class="keyword">new</span> JSONObject(params);</span><br><span class="line"> Log.i(TAG,jsonRequest.toString());</span><br><span class="line"> <span class="comment">//如果json数据为空则是get请求，否则是post请求</span></span><br><span class="line"> <span class="comment">//如果jsonrequest不为null，volley会将jsonObject对象转化为json字符串原封不动的发给服务器,并不会转成k-v对,因为volley不知道应该如何转化</span></span><br><span class="line"> String url = <span class="string">"http://192.168.56.1:8080/volley_test/servlet/JsonServlet"</span>;</span><br><span class="line"> JsonObjectRequest request = <span class="keyword">new</span> JsonObjectRequest(url, jsonRequest, <span class="keyword">new</span> Response.Listener&lt;JSONObject&gt;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JSONObject response)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="comment">//handle it &#125;</span></span><br><span class="line"> &#125;,<span class="keyword">new</span> Response.ErrorListener()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span></span><br><span class="line"><span class="function"> </span>&#123; error.printStackTrace(); &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> mQueue.add(request);</span><br></pre></td></tr></table></figure>

<p><strong>ImageRequest</strong><br>ImageRequest可以控制图片的宽高、照片品质。如果宽高比原始宽高小的话，将会进行压缩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageRequest request = <span class="keyword">new</span> ImageRequest(<span class="string">"http://192.168.56.1:8080/volley_test/image.jpg"</span>,</span><br><span class="line"><span class="keyword">new</span> Response.Listener&lt;Bitmap&gt;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Bitmap response)</span></span></span><br><span class="line"><span class="function"> </span>&#123; mImageView.setImageBitmap(response); &#125;</span><br><span class="line"> &#125;,<span class="number">0</span>,<span class="number">0</span>, Bitmap.Config.ARGB_8888,<span class="keyword">new</span> Response.ErrorListener()</span><br><span class="line"> &#123;<span class="comment">//参数0 0 代表不压缩</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span></span><br><span class="line"><span class="function"> </span>&#123; show(error.getMessage());</span><br><span class="line"> <span class="comment">//可以去显示默认图片</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> mQueue.add(request);</span><br></pre></td></tr></table></figure>

<p><strong>添加请求头</strong><br>有时候我们需要为Request添加请求头，这时候可以去重写Request的getHeaders方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">"http://192.168.56.1:8080/volley_test/servlet/JsonServlet"</span>;</span><br><span class="line">JsonObjectRequest request = <span class="keyword">new</span> JsonObjectRequest(url, <span class="keyword">null</span>,resplistener,errlistener)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//添加自定义请求头</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getHeaders</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"> map.put(<span class="string">"header1"</span>,<span class="string">"header1_val"</span>);</span><br><span class="line"> map.put(<span class="string">"header2"</span>,<span class="string">"header2_val"</span>);</span><br><span class="line"> <span class="keyword">return</span> map;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>添加post请求参数</strong><br>添加Post请求参数可以重写Request的GetParams方法，另需 修改请求参数为POST。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">"http://192.168.56.1:8080/volley_test/servlet/PostServlet"</span>;</span><br><span class="line">StringRequest request = <span class="keyword">new</span> StringRequest(Method.POST,url,listener, errorListener)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//post请求需要复写getParams方法</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"> map.put(<span class="string">"KEY1"</span>,<span class="string">"value1"</span>);</span><br><span class="line"> map.put(<span class="string">"KEY2"</span>, <span class="string">"value2"</span>);</span><br><span class="line"> <span class="keyword">return</span> map;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>Request里面还有一些getXXX方法，大家参考代码自己琢磨吧。</p>
<p><strong>取消请求</strong><br>当Activity销毁时，我们可能需要去取消一些网络请求，这时候可以通过如下方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request req = ...;</span><br><span class="line">request.setTag(<span class="string">"MAIN_ACTIVITY"</span>);</span><br><span class="line">onDestroy() &#123;</span><br><span class="line"> mQueue.cancelAll(<span class="string">"MAIN_ACTIVITY"</span>);</span><br><span class="line">&#125;</span><br><span class="line">为属于该Activity的请求全部加上Tag，然后需要销毁的时候调用cancelAll传入tag即可。</span><br><span class="line">RequestQueue#cancelAll还有另一种重载形式，可以传入RequestFilter，自己指定一个过滤策略。</span><br><span class="line">如果我们需要干掉所有请求，并且后续不再有网络请求，可以干掉RequestQueue，调用其stop方法即可。</span><br></pre></td></tr></table></figure>

<h5 id="全局共享RequestQueue"><a href="#全局共享RequestQueue" class="headerlink" title="全局共享RequestQueue"></a>全局共享RequestQueue</h5><p>RequestQueue没有必要每个Activity里面都创建，全局保有一个即可。这时候自然想到使用Application了。我们可以在Application里面创建RequestQueue，并向外暴露get方法。代码很简单，相信大家都会写。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android框架</tag>
        <tag>volley</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux ThinkPHP5.1 秒级定时任务</title>
    <url>/2020/03/11/thinkphptimer/</url>
    <content><![CDATA[<p><img src="/2020/03/11/thinkphptimer/u=76165371,771060864&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>尝试过thinkphp论坛里面workman扩展的方式，时间间隔不准确，并且有同一时间执行的情况，放弃.  最终还是觉着依托系统提供的crontab方式，虽然crontab自身不能支持秒级的定时，可以通过代码来弥补. 尝试成功，并且时间间隔很准确.</p>
<h3 id="1-thinkphp5-1-创建command"><a href="#1-thinkphp5-1-创建command" class="headerlink" title="1.thinkphp5.1 创建command"></a>1.thinkphp5.1 创建command</h3><p>thinkphp 根目录执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php think make:<span class="built_in">command</span> timer</span><br></pre></td></tr></table></figure>

<p>application/command 会自动生成一个timer类</p>
<p><img src="/2020/03/11/thinkphptimer/20200311172801.png" alt></p>
<h3 id="2-声明timer"><a href="#2-声明timer" class="headerlink" title="2.声明timer"></a>2.声明timer</h3><p>编辑application下的command.php</p>
<p><img src="/2020/03/11/thinkphptimer/20200311172528.png" alt></p>
<h3 id="3-测试command"><a href="#3-测试command" class="headerlink" title="3.测试command"></a>3.测试command</h3><p>thinkphp根目录执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php think timer</span><br></pre></td></tr></table></figure>

<p>看看是否会打印出 \app\commad\timer</p>
<h3 id="4-指定crontab来执行thinkphp的command"><a href="#4-指定crontab来执行thinkphp的command" class="headerlink" title="4.指定crontab来执行thinkphp的command"></a>4.指定crontab来执行thinkphp的command</h3><p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>

<p>编辑：</p>
<p>每10秒来执行一次</p>
<p><img src="/2020/03/11/thinkphptimer/20200311171518.png" alt="20200311171518.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:wq</span><br></pre></td></tr></table></figure>

<h3 id="5-写文件测试"><a href="#5-写文件测试" class="headerlink" title="5.写文件测试"></a>5.写文件测试</h3><p>第一步中timer类的execute中加入 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$holder = fopen(<span class="string">'./timer.txt'</span>, <span class="string">'a+'</span>);</span><br><span class="line">fwrite($holder, time() . PHP_EOL);</span><br><span class="line">fclose($holder);</span><br></pre></td></tr></table></figure>

<p>查看文件</p>
<p><img src="/2020/03/11/thinkphptimer/20200311171618.png" alt></p>
<p>每10s执行一次，完成！</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>thinkphp</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 安装 composer</title>
    <url>/2020/03/10/linuxinstallcomposer/</url>
    <content><![CDATA[<p><img src="/2020/03/10/linuxinstallcomposer/u=2488564289,1129386811&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<h4 id="官方教程地址："><a href="#官方教程地址：" class="headerlink" title="官方教程地址："></a>官方教程地址：</h4><p><a href="https://docs.phpcomposer.com/00-intro.html#Globally" target="_blank" rel="noopener">https://docs.phpcomposer.com/00-intro.html#Globally</a></p>
<h4 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h4><p>要真正获取 Composer，我们需要做两件事。首先安装 Composer （同样的，这意味着它将下载到你的项目中）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure>

<p>注意： 如果上述方法由于某些原因失败了，你还可以通过 php &gt;下载安装器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -r <span class="string">"readfile('https://getcomposer.org/installer');"</span> | php</span><br></pre></td></tr></table></figure>

<p>这将检查一些 PHP 的设置，然后下载 composer.phar 到你的工作目录中。这是 Composer 的二进制文件。这是一个 PHAR 包（PHP 的归档），这是 PHP 的归档格式可以帮助用户在命令行中执行一些操作。</p>
<p>你可以通过 –install-dir 选项指定 Composer 的安装目录（它可以是一个绝对或相对路径）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php -- --install-dir=bin</span><br></pre></td></tr></table></figure>

<h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><p>你可以将此文件放在任何地方。如果你把它放在系统的 PATH 目录中，你就能在全局访问它。 在类Unix系统中，你甚至可以在使用时不加 php 前缀。</p>
<p>你可以执行这些命令让 composer 在你的系统中进行全局调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sS https://getcomposer.org/installer | php</span><br><span class="line">mv composer.phar /usr/<span class="built_in">local</span>/bin/composer</span><br></pre></td></tr></table></figure>

<p>注意： 如果上诉命令因为权限执行失败， 请使用 sudo 再次尝试运行 mv 那行命令。<br>现在只需要运行 composer 命令就可以使用 Composer 而不需要输入 php composer.phar。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 安装PHP7</title>
    <url>/2020/03/10/centosinstallphp7/</url>
    <content><![CDATA[<p><img src="/2020/03/10/centosinstallphp7/u=426857830,3900731748&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<p>一、PHP的安装<br>　1、由于linux的yum源不存在php7.x，所以我们要更改yum源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span></span><br><span class="line"><span class="comment">#rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</span></span><br></pre></td></tr></table></figure>

<p>　2、yum查询安装php71w</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum search php71w</span></span><br></pre></td></tr></table></figure>

<p>　3、yum 安装php71w和各种拓展，选自己需要的即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#yum install php71w php71w-cli php71w-common php71w-devel php71w-embedded php71w-fpm php71w-gd php71w-mbstring php71w-mysqlnd php71w-opcache php71w-pdo php71w-xml</span></span><br></pre></td></tr></table></figure>

<p>　4、安装完成之后，#whereis php 可以看到php的安装目录，然后我们来给php配置环境,实际上在centos7上php.ini已经不用像在Windows上那样配置了。我们只需要修改这个文件的参数设置cgi.fix_pathinfo，默认设置值为“1”，用；进行注释或修改为0即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim vim /etc/profile #在末尾添加</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/php/bin　　<span class="comment">#记得修改为自己php的安装路径</span></span><br><span class="line"><span class="built_in">export</span> PATH</span><br><span class="line"><span class="comment">#：wq保存退出</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile <span class="comment">#运行该句指令使修改生效</span></span><br><span class="line">php -v <span class="comment">#就可以看到PHP版本信息了。</span></span><br></pre></td></tr></table></figure>

<p>　5、测试，在自己的Nginx或Apache或自建的网页目录下新建index.php，编辑内容为<?php  phpinfo(); ?></p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos安装Apache</title>
    <url>/2020/03/10/centosinstallapache/</url>
    <content><![CDATA[<h3 id="安装apache"><a href="#安装apache" class="headerlink" title="安装apache"></a>安装apache</h3><p>通过yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd</span><br></pre></td></tr></table></figure>

<p>安装成功后可以执行启动命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service httpd start</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3><p>启动服务后无法访问</p>
<p>1）在防火墙中开放80端口 现在需要将 http 服务加入防火墙以允许外部访问，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --add-service=http --permanent</span><br></pre></td></tr></table></figure>

<p>–permanent 参数表示这是一条永久防火墙规则，如果不加则重启系统后就没有这条规则了</p>
<p>而对于自定义的端口（如81），也需要添加防火墙规则， firewall-cmd –zone=public –add-port=81/tcp –permanent 重启 Firewalld 使该规则生效， systemctl restart firewalld</p>
<p>2）关闭SELINUX</p>
<p>vi /etc/selinux/config</p>
<p>注释掉如下两句，添加最后一项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#SELINUX&#x3D;enforcing  #注释掉</span><br><span class="line"></span><br><span class="line">#SELINUXTYPE&#x3D;targeted  #注释掉</span><br><span class="line"></span><br><span class="line">SELINUX&#x3D;disabled #增加</span><br><span class="line"></span><br><span class="line">:wq!  保存退出</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 远程登录</title>
    <url>/2020/03/10/mysqlremotelogin/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt;  alter user 'root'@'localhost' identified with mysql_native_password by '123456';</span><br><span class="line">Query OK, 0 rows affected (0.60 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.18 sec)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>记得关闭防火墙或者，取消3306端口的防火墙</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>远程登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos 防火墙/端口 开关</title>
    <url>/2020/03/10/centosfirewallportoc/</url>
    <content><![CDATA[<p><img src="/2020/03/10/centosfirewallportoc/u=3630922114,391211100&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<p>当我们在CentOS服务器中装了一些开发环境（如 tomcat、mysql、nginx 等…）时，希望能从外界访问，就需要配置防火墙对指定端口开放。</p>
<h3 id="CentOS-6-5"><a href="#CentOS-6-5" class="headerlink" title="CentOS 6.5"></a>CentOS 6.5</h3><h4 id="1-开放指定端口"><a href="#1-开放指定端口" class="headerlink" title="1.开放指定端口"></a>1.开放指定端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT //写入修改</span><br><span class="line">/etc/init.d/iptables save //保存修改</span><br><span class="line">service iptables restart //重启防火墙，修改生效</span><br></pre></td></tr></table></figure>

<h4 id="2-关闭指定端口"><a href="#2-关闭指定端口" class="headerlink" title="2.关闭指定端口"></a>2.关闭指定端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport 端口号 -j DROP //写入修改</span><br><span class="line">/etc/init.d/iptables save //保存修改</span><br><span class="line">service iptables restart //重启防火墙，修改生效</span><br></pre></td></tr></table></figure>

<h4 id="3-查看端口状态"><a href="#3-查看端口状态" class="headerlink" title="3.查看端口状态"></a>3.查看端口状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/iptables status</span><br></pre></td></tr></table></figure>

<h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><h4 id="1-防火墙操作"><a href="#1-防火墙操作" class="headerlink" title="1.防火墙操作"></a>1.防火墙操作</h4><p>启动： systemctl start firewalld<br>查看状态： systemctl status firewalld<br>停止： systemctl disable firewalld<br>禁用： systemctl stop firewalld</p>
<h4 id="2-开放指定端口"><a href="#2-开放指定端口" class="headerlink" title="2.开放指定端口"></a>2.开放指定端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent //开放端口</span><br><span class="line">firewall-cmd --reload //重新载入，使其生效</span><br></pre></td></tr></table></figure>

<h4 id="3-关闭指定端口"><a href="#3-关闭指定端口" class="headerlink" title="3.关闭指定端口"></a>3.关闭指定端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent //关闭端口</span><br><span class="line">firewall-cmd --reload //重新载入，使其生效</span><br></pre></td></tr></table></figure>

<h4 id="4-查看端口状态"><a href="#4-查看端口状态" class="headerlink" title="4.查看端口状态"></a>4.查看端口状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=80/tcp //查看端口状态</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>防火墙，端口</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 更改Mysql Root密码</title>
    <url>/2020/03/10/centoschangemysqlpwd/</url>
    <content><![CDATA[<h3 id><a href="#" class="headerlink" title></a><img src="/2020/03/10/centoschangemysqlpwd/u=3853313707,2686910450&fm=26&gp=0.jpg" alt></h3><a id="more"></a>

<h3 id="第一步：修改配置文件免密码登录mysql"><a href="#第一步：修改配置文件免密码登录mysql" class="headerlink" title="第一步：修改配置文件免密码登录mysql"></a>第一步：修改配置文件免密码登录mysql</h3><p>1、进入文件：vi /etc/my.cnf</p>
<p>2、按i键表示可以编辑；添加skip-grant-tables；按esc键，输入:wq保存退出</p>
<p>3、重启mysql:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="第二步免密码登录mysql"><a href="#第二步免密码登录mysql" class="headerlink" title="第二步免密码登录mysql"></a>第二步免密码登录mysql</h3><p>1、登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<p>2、提示输入密码按回车进入</p>
<p>3、进入数据库，输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql；</span><br></pre></td></tr></table></figure>

<p>4、查看root用户信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> host, <span class="keyword">user</span>, authentication_string, <span class="keyword">plugin</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>5、更新root用户信息，把密码设置为空字符串：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string=<span class="string">''</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="第三步、退出mysql；"><a href="#第三步、退出mysql；" class="headerlink" title="第三步、退出mysql；"></a>第三步、退出mysql；</h3><p>注释掉/etc/my.cnf文件最后的 skip-grant-tables ；</p>
<p>重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service mysqld restart</span><br></pre></td></tr></table></figure>

<h3 id="第四步：设置新密码"><a href="#第四步：设置新密码" class="headerlink" title="第四步：设置新密码"></a>第四步：设置新密码</h3><p>1、重新开启一个客户端；</p>
<p>2、登录mysql(这时候还是不用输入密码，因为上面已经把密码设置为空字符串了);</p>
<p>3、修改root用户密码:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">user</span> <span class="string">'root'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>

<p>4、退出mysql后就可以用密码登录了</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>root密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux rpm/yum讲解</title>
    <url>/2020/03/10/linuxrpmyum/</url>
    <content><![CDATA[<p><img src="/2020/03/10/linuxrpmyum/u=302641616,2254540716.jpg" alt></p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h4><p>linux RedHat分支中的<strong>程序包管理器</strong>，全称为Red Hat Linux</p>
<h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p>为前端工具，基于rpm，自动化解决包之间依赖关系</p>
<h4 id="程序包管理器"><a href="#程序包管理器" class="headerlink" title="程序包管理器"></a>程序包管理器</h4><p>所有的软件都是由文件格式的程序代码(即源代码)，经过编译成为一个可执行二进制文件；对于一个软件来说，其包含二进制程序、库文件、配置文件以及帮助文件。在应用中，每次要安装程序时通过找源代码然后去编译成二进制文件，这个过程要花费大量的时间，所以就有了程序包管理器。<strong>程序包管理器的功能是</strong>：将编译好的应用程序的各组文件打包成一个或几个程序包文件，从而更方便地实现程序包的安装、升级、卸载和查询等管理操作。</p>
<p>我们可以将这种软件包管理器称为手动安装程序的软件包管理器，为什么成为手动安装程序的软件包管理器呢？<br>因为这种软件包管理器，在软件安装的过程中不能解决包之间的依赖管理，比如，A程序的运行要基于B程序的某些库文件才能运行，所以在安装A程序之前必须安装A程序；当然也有可能出现这种情况：B程序的运行也要基于A程序的某些库文件才能运行，这样就形成了先有鸡还是先有蛋的问题。</p>
<h4 id="前端工具"><a href="#前端工具" class="headerlink" title="前端工具"></a>前端工具</h4><p>利用这种程序包管理器我们只能手动解决包之间的依赖关系。所谓自动解决依赖关系，无非就是在某个程序安装之前对该程序包文件进行分析看其都依赖哪些程序，然后将这些程序一并安装，从而解决软件包的依赖文件，我们将自动解决依赖关系的工具称为解决依赖关系的<strong>前端工具</strong>。</p>
<p>Linux发行版本主要分为两类：类RedHat和类Debain，不同的发行版本上所使用的程序包管理器各不相同，下图是各发行版本所使用的程序包管理器：</p>
<p><img src="/2020/03/10/linuxrpmyum/4066600603.png" alt></p>
<h3 id="程序包管理器的组成"><a href="#程序包管理器的组成" class="headerlink" title="程序包管理器的组成"></a>程序包管理器的组成</h3><p>1、程序包的组成清单(每个程序包都单独实现)</p>
<p>其中包含文件清单和安全或卸载时运行的脚本</p>
<p>2、数据库(公共)</p>
<p>程序包管理器数据库存放的位置在/var/lib/rpm/目录下，其中包含程序包的名称和版本，依赖关系，功能说明以及安装生成的各文件的文件路径及校验码信息等等。</p>
<h3 id="获取可靠安全程序包的途径"><a href="#获取可靠安全程序包的途径" class="headerlink" title="获取可靠安全程序包的途径"></a>获取可靠安全程序包的途径</h3><p>1、系统发行版的光盘或官方的文件服务器(或镜像站点)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirrors.aliyun.com</span><br><span class="line">http:&#x2F;&#x2F;mirrors.sohu.com</span><br><span class="line">http:&#x2F;&#x2F;mirrors.163.com</span><br></pre></td></tr></table></figure>

<p>2、项目的官方站点</p>
<p>3、第三方组织：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1) EPEL</span><br><span class="line">(2) 专门搜索rpm的搜索引擎</span><br><span class="line">    http:&#x2F;&#x2F;pkgs.org</span><br><span class="line">    http:&#x2F;&#x2F;rpmfind.net</span><br><span class="line">    http:&#x2F;&#x2F;rpm.pbone.net</span><br></pre></td></tr></table></figure>

<p>4、自己做rpm包</p>
<h4 id="rpm包命名格式"><a href="#rpm包命名格式" class="headerlink" title="rpm包命名格式"></a>rpm包命名格式</h4><p>在看rpm包命名格式之前先来看下源代码的命名格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#源代码：name-VERSION.tar.gz</span><br><span class="line">#其中VERSION包含: major.minor.release</span><br></pre></td></tr></table></figure>

<p>rpm包命名格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#name-VERSION-release.arch.rpm</span><br><span class="line">#VERSION: major.minor.release --&gt; 其为源代码的发行号release.arch: rpm包的发行号     </span><br><span class="line">#architecture: i386, x64(amd64), ppc, noarch</span><br><span class="line">#例：redis-3.0.2-1.centos7.x64.rpm</span><br></pre></td></tr></table></figure>

<p>拆包：主包和子包；Linux中的软件包一般有一个主程序的安装包，再就是子程序包，所谓的子程序包就是该软件上的某一功能的安装包，或者说是该程序的一个插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主包: name-VERSION-release.arch.rpm</span><br><span class="line">#子包: name-function-VERSION-release.arch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="rpm使用"><a href="#rpm使用" class="headerlink" title="rpm使用"></a>rpm使用</h3><h4 id="rpm帮助文档"><a href="#rpm帮助文档" class="headerlink" title="rpm帮助文档"></a>rpm帮助文档</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法: rpm [选项...]</span><br><span class="line"></span><br><span class="line">查询&#x2F;验证软件包选项：</span><br><span class="line">  -a, --all                        查询&#x2F;验证所有软件包</span><br><span class="line">  -f, --file                       查询&#x2F;验证文件属于的软件包</span><br><span class="line">  -g, --group                      查询&#x2F;验证组中的软件包</span><br><span class="line">  -p, --package                    查询&#x2F;验证一个软件包</span><br><span class="line">  --pkgid                          query&#x2F;verify package(s) with package identifier</span><br><span class="line">  --hdrid                          query&#x2F;verify package(s) with header identifier</span><br><span class="line">  --triggeredby                    query the package(s) triggered by the package</span><br><span class="line">  --whatrequires                   query&#x2F;verify the package(s) which require a dependency</span><br><span class="line">  --whatprovides                   查询&#x2F;验证提供相关依赖的软件包</span><br><span class="line">  --nomanifest                     不把非软件包文件作为清单处理</span><br><span class="line"></span><br><span class="line">查询选项（用 -q 或 --query）：</span><br><span class="line">  -c, --configfiles                列出所有配置文件</span><br><span class="line">  -d, --docfiles                   列出所有程序文档</span><br><span class="line">  -L, --licensefiles               list all license files</span><br><span class="line">  --dump                           转储基本文件信息</span><br><span class="line">  -l, --list                       列出软件包中的文件</span><br><span class="line">  --queryformat&#x3D;QUERYFORMAT        使用这种格式打印信息</span><br><span class="line">  -s, --state                      显示列出文件的状态</span><br><span class="line"></span><br><span class="line">验证选项（用 -V 或 --verify）：</span><br><span class="line">  --nofiledigest                   不验证文件摘要</span><br><span class="line">  --nofiles                        不验证软件包中文件</span><br><span class="line">  --nodeps                         不验证包依赖</span><br><span class="line">  --noscript                       不执行验证脚本</span><br><span class="line"></span><br><span class="line">安装&#x2F;升级&#x2F;擦除选项：</span><br><span class="line">  --allfiles                       安装全部文件，包含配置文件，否则配置文件会被跳过。</span><br><span class="line">  --allmatches                     移除所有符合 &lt;package&gt; 的软件包(如果 &lt;package&gt;</span><br><span class="line">                                   被指定未多个软件包，常常会导致错误出现)</span><br><span class="line">  --badreloc                       对不可重定位的软件包重新分配文件位置</span><br><span class="line">  -e, --erase&#x3D;&lt;package&gt;+           清除 (卸载) 软件包</span><br><span class="line">  --excludedocs                    不安装程序文档</span><br><span class="line">  --excludepath&#x3D;&lt;path&gt;             略过以 &lt;path&gt; 开头的文件</span><br><span class="line">  --force                          --replacepkgs --replacefiles 的缩写</span><br><span class="line">  -F, --freshen&#x3D;&lt;packagefile&gt;+     如果软件包已经安装，升级软件包</span><br><span class="line">  -h, --hash                       软件包安装的时候列出哈希标记 (和 -v</span><br><span class="line">                                   一起使用效果更好)</span><br><span class="line">  --ignorearch                     不验证软件包架构</span><br><span class="line">  --ignoreos                       不验证软件包操作系统</span><br><span class="line">  --ignoresize                     在安装前不检查磁盘空间</span><br><span class="line">  -i, --install                    安装软件包</span><br><span class="line">  --justdb                         更新数据库，但不修改文件系统</span><br><span class="line">  --nodeps                         不验证软件包依赖</span><br><span class="line">  --nofiledigest                   不验证文件摘要</span><br><span class="line">  --nocontexts                     不安装文件的安全上下文</span><br><span class="line">  --noorder                        不对软件包安装重新排序以满足依赖关系</span><br><span class="line">  --noscripts                      不执行软件包脚本</span><br><span class="line">  --notriggers                     不执行本软件包触发的任何脚本</span><br><span class="line">  --nocollections                  请不要执行任何动作集</span><br><span class="line">  --oldpackage                     更新到软件包的旧版本(带 --force</span><br><span class="line">                                   自动完成这一功能)</span><br><span class="line">  --percent                        安装软件包时打印百分比</span><br><span class="line">  --prefix&#x3D;&lt;dir&gt;                   如果可重定位，便把软件包重定位到 &lt;dir&gt;</span><br><span class="line">  --relocate&#x3D;&lt;old&gt;&#x3D;&lt;new&gt;           将文件从 &lt;old&gt; 重定位到 &lt;new&gt;</span><br><span class="line">  --replacefiles                   忽略软件包之间的冲突的文件</span><br><span class="line">  --replacepkgs                    如果软件包已经有了，重新安装软件包</span><br><span class="line">  --test                           不真正安装，只是判断下是否能安装</span><br><span class="line">  -U, --upgrade&#x3D;&lt;packagefile&gt;+     升级软件包</span><br><span class="line">  --reinstall&#x3D;&lt;packagefile&gt;+       reinstall package(s)</span><br><span class="line"></span><br><span class="line">所有 rpm 模式和可执行文件的通用选项：</span><br><span class="line">  -D, --define&#x3D;“MACRO EXPR”        定义值为 EXPR 的 MACRO</span><br><span class="line">  --undefine&#x3D;MACRO                 undefine MACRO</span><br><span class="line">  -E, --eval&#x3D;“EXPR”                打印 EXPR 的宏展开</span><br><span class="line">  --macros&#x3D;&lt;FILE:…&gt;                从文件 &lt;FILE:...&gt; 读取宏，不使用默认文件</span><br><span class="line">  --noplugins                      don&#39;t enable any plugins</span><br><span class="line">  --nodigest                       不校验软件包的摘要</span><br><span class="line">  --nosignature                    不验证软件包签名</span><br><span class="line">  --rcfile&#x3D;&lt;FILE:…&gt;                从文件 &lt;FILE:...&gt; 读取宏，不使用默认文件</span><br><span class="line">  -r, --root&#x3D;ROOT                  使用 ROOT 作为顶级目录 (default: &quot;&#x2F;&quot;)</span><br><span class="line">  --dbpath&#x3D;DIRECTORY               使用 DIRECTORY 目录中的数据库</span><br><span class="line">  --querytags                      显示已知的查询标签</span><br><span class="line">  --showrc                         显示最终的 rpmrc 和宏配置</span><br><span class="line">  --quiet                          提供更少的详细信息输出</span><br><span class="line">  -v, --verbose                    提供更多的详细信息输出</span><br><span class="line">  --version                        打印使用的 rpm 版本号</span><br><span class="line"></span><br><span class="line">Options implemented via popt alias&#x2F;exec:</span><br><span class="line">  --scripts                        list install&#x2F;erase scriptlets from package(s)</span><br><span class="line">  --setperms                       set permissions of files in a package</span><br><span class="line">  --setugids                       set user&#x2F;group ownership of files in a package</span><br><span class="line">  --setcaps                        set capabilities of files in a package</span><br><span class="line">  --restore                        restore file&#x2F;directory permissions</span><br><span class="line">  --conflicts                      list capabilities this package conflicts with</span><br><span class="line">  --obsoletes                      list other packages removed by installing this package</span><br><span class="line">  --provides                       list capabilities that this package provides</span><br><span class="line">  --requires                       list capabilities required by package(s)</span><br><span class="line">  --info                           list descriptive information from package(s)</span><br><span class="line">  --changelog                      list change logs for this package</span><br><span class="line">  --xml                            list metadata in xml</span><br><span class="line">  --triggers                       list trigger scriptlets from package(s)</span><br><span class="line">  --last                           list package(s) by install time, most recent first</span><br><span class="line">  --dupes                          list duplicated packages</span><br><span class="line">  --filesbypkg                     list all files from each package</span><br><span class="line">  --fileclass                      list file names with classes</span><br><span class="line">  --filecolor                      list file names with colors</span><br><span class="line">  --fscontext                      list file names with security context from file system</span><br><span class="line">  --fileprovide                    list file names with provides</span><br><span class="line">  --filerequire                    list file names with requires</span><br><span class="line">  --filecaps                       list file names with POSIX1.e capabilities</span><br></pre></td></tr></table></figure>

<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>rpm {-i|–install} [install-options] PACKAGE_FILE …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rpm -ivh PACKAGE_FILEGENERAL OPTIONS    </span><br><span class="line">    -v: verbose，详细信息</span><br><span class="line">    -vv: 更详细的输出</span><br></pre></td></tr></table></figure>

<p><strong>[install-options]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h: hash marks 输出进度条；每个#表示2%的进度；</span><br><span class="line">--test: 测试安装，检查并报告依赖关系及冲突消息等；</span><br><span class="line">--nodeps: 忽略依赖关系；</span><br><span class="line">    注意：当忽略依赖关系安装程序时，程序安装完成后，有可能不能正常运行，所以该安装选项不建议使用；--replacepkgs: 重新安装；</span><br><span class="line">    比如说，将某程序的配置文件中信息修改后，想还原该配置文件，但是忘记了之前的配置，此时可以将该配置文件删除后，利用该安装选项对该程序重新安装来恢复其某个配置文件；--nosignature: 不检查包签名信息，不检查包来源的合法性；</span><br><span class="line">--nodigest: 不检查包完整性信息；</span><br><span class="line">--noscripts: 安装时不执行脚本文件</span><br></pre></td></tr></table></figure>

<h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>rpm {-U|–upgrade} [install-options] PACKAGE_FILE …<br>rpm {-F|–freshen} [install-options] PACKAGE_FILE …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-U: 升级或安装</span><br><span class="line">-F: 升级</span><br><span class="line">rpm -Uvh PACKAGE_FILE...rpm -Fvh PACKAGE_FILE...</span><br></pre></td></tr></table></figure>

<p><strong>[install-options]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--oldpackage: 降级</span><br><span class="line">--foece: 强制升级</span><br></pre></td></tr></table></figure>

<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>rpm {-e|–erase} [–allmatches] [–justdb] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME …</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--allmarches: 卸载所有匹配指定名称的程序包的各版本；</span><br><span class="line">--nodeps: 忽略依赖关系；</span><br><span class="line">--test: 测试卸载，dry run模式</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>rpm {-q|–query} [select-options] [query-options]</p>
<p><strong>[select-options]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PACKAGE_NAME: 查询指定程序包是否已经安装，及其版本；-a, --all: 查询所有已经安装过的包；</span><br><span class="line">-f FILE: 查询指定的文件由哪个程序安装包生成；</span><br><span class="line">-p, --package PACKAGE_FILE: 用于实现对未安装的程序包执行查询操作；</span><br><span class="line">--whatprovides CAPABILITY: 查询指定的CAPABILITY由哪个包提供；</span><br><span class="line">--whatrequires CAPABILITY: 查询指定的CAPABILITY被哪个包所依赖；</span><br></pre></td></tr></table></figure>

<p><strong>[query-options]</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--changelog: 查询rpm包的changelog；</span><br><span class="line">-l, --list: 程序包安装生成的所有文件列表；</span><br><span class="line">-i, --info: 程序包相关的信息，版本号、大小、所属组等；</span><br><span class="line">-c, --configfiles: 查询指定的程序提供的配置文件；</span><br><span class="line">-d, --docfiles: 查询指定的程序包提供的文档；</span><br><span class="line">--provides: 列出指定程序包提供的所有CAPABILITY；</span><br><span class="line">-R, --require: 查询指定程序包的依赖关系；</span><br><span class="line">--scripts: 查询程序包自带的脚本片段；</span><br></pre></td></tr></table></figure>

<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>软件包的校验一般是验证其来源的合法性以及软件包完整性的验证；来源合法性验证利用数字签名奇数，完整性验证利用单项函数加密技术。</p>
<p><strong>软件包校验命令</strong></p>
<p>rpm {-V|–verify} [select-options] [verify-options]</p>
<p><strong>校验过程：</strong></p>
<p>(1) 首先获取并导入信任的包制作者的密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于CentOS发行版来说，利用下面的命令进行密钥的导入：# rpm -import &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure>

<p>(2) 验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a. 安装此组织签名的程序时，会自动执行验证；</span><br><span class="line">b. 手动验证：rmp -K PACKAGE_FILE</span><br></pre></td></tr></table></figure>

<h3 id="数据库重建"><a href="#数据库重建" class="headerlink" title="数据库重建"></a>数据库重建</h3><p>rpm管理器数据库的路径/var/lib/rpm/</p>
<p><strong>获取rpm数据库工具的帮助</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CentOS 6: man rpmCentOS 7: man rpmdb</span><br></pre></td></tr></table></figure>

<p><strong>数据库重建的命令</strong></p>
<p>rpm {–initdb|–rebuilddb}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--initdb: 初始化数据库，当前无任何数据库可实现初始化创建一个新的；当前有时不执行任何操作；</span><br><span class="line">--rebuilddb: 重新构建，通过读取当前系统上所有已经安装过的程序 包进行重新创建；</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://segmentfault.com/a/1190000016324835" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016324835</a></p>
<h3 id="yum使用"><a href="#yum使用" class="headerlink" title="yum使用"></a>yum使用</h3><p>yum是以rpm实现的包管理工具， rpm在解决包依赖问题上都需要手动处理，在依赖链或者循环依赖的方式上处理起来非常繁琐，yum应运而生。</p>
<h4 id="一、yum的分类"><a href="#一、yum的分类" class="headerlink" title="一、yum的分类"></a>一、yum的分类</h4><p>1.客户端:客户端的配置非常简单，只要配置要一些基本的参数，就可以通过客户端来安装软件，并且解决软件包的依赖性。</p>
<p>2.服务端:将所有需要的软件包同统一放在一个目录下，该目录可以通过ftp、http、https、file将需要使用软件的客户端传输需要的软件。</p>
<h4 id="二、yum的配置文件"><a href="#二、yum的配置文件" class="headerlink" title="二、yum的配置文件"></a>二、yum的配置文件</h4><p><strong><em>全局配置:</em></strong><code>/etc/yum.conf yum</code><br>cachedir：软件包缓存目录<br>keepcache：缓存是否保存，1保存0不保存<br>debuglevel：调试级别（默认为2）<br>logfile：日志文件路径<br>gpgcheck：是否检查密钥，一种检验软件完整性的方式<br><img src="/2020/03/10/linuxrpmyum/6852280-2074f1a29d628c62.png" alt></p>
<p><strong><em>仓库配置:</em></strong><code>/etc/yum.repo.d/name.repo yum</code><br>[name]：仓库id<br>name ：仓库名字<br>baseurl： 为仓库的地址<br>gpgkey：公钥地址，若是需要检查完整性的话可以添加密钥地址<br>enable：是否开启当前仓库<br>gpgcheck：是否使用密钥验证<br><img src="/2020/03/10/linuxrpmyum/6852280-305f400d2701b29d.png" alt></p>
<h4 id="三、yum仓库中的变量信息"><a href="#三、yum仓库中的变量信息" class="headerlink" title="三、yum仓库中的变量信息"></a>三、yum仓库中的变量信息</h4><p>arch:处理器平台，i386，x86_64,i486,i586<br>releaserver/os/$basearch/<a href="https://mirrors.aliyun.com/centos/6.9/os/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/6.9/os/x86_64/</a></p>
<h4 id="四、yum命令"><a href="#四、yum命令" class="headerlink" title="四、yum命令"></a>四、yum命令</h4><p>1.启用与禁用仓库<br>禁用仓库:<code>yum-config-manager --disable “仓库名&quot;</code><br>启用仓库:<code>yum-config-manager --enable “仓库名”</code></p>
<p>2.显示软件仓库列表<br><code>yum repolist</code></p>
<p>3.显示软件包列表<br><code>yum list</code></p>
<p>4.安装卸载与更新<br>安装：<code>yum install package1 package2...</code><br>重新安装：<code>yum reinstall package</code><br>卸载：<code>yum remove package</code><br>更新：<code>yum update package</code><br>降级：<code>yum downgrage package</code><br>检查可用的更新：<code>yum check-update</code></p>
<p>5.缓存命令<br>清除缓存：<code>yum clean all</code><br>构建缓存：<code>yum makecache</code></p>
<p>6.查看依赖性<br><code>yum deplist package1</code></p>
<p>7.包组相关命令<br>安装：<code>yum groupinstall group1 [group2] [...]</code><br>更新<code>yum groupupdate group1 [group2] [...]</code><br>列表<code>yum grouplist [hidden] [groupwildcard] [...]</code><br>删除<code>yum groupremove group1 [group2] [...]</code><br>信息<code>yum groupinfo group1 [...]</code></p>
<p>参考：<a href="https://www.cnblogs.com/aubin/p/7289207.html" target="_blank" rel="noopener">https://www.cnblogs.com/aubin/p/7289207.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>rpm</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7 yum安装/卸载 Mysql</title>
    <url>/2020/03/10/centos7installmysql/</url>
    <content><![CDATA[<p><img src="/2020/03/10/centos7installmysql/u=3853313707,2686910450&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>

<h3 id="官方教程："><a href="#官方教程：" class="headerlink" title="官方教程："></a>官方教程：</h3><p><a href="https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-yum-repo-quick-guide/en/</a></p>
<h3 id="Mysql官方程序包地址："><a href="#Mysql官方程序包地址：" class="headerlink" title="Mysql官方程序包地址："></a>Mysql官方程序包地址：</h3><p><a href="https://repo.mysql.com/yum/" target="_blank" rel="noopener">https://repo.mysql.com/yum/</a></p>
<h3 id="下载rpm程序包"><a href="#下载rpm程序包" class="headerlink" title="下载rpm程序包"></a>下载rpm程序包</h3><p>(不同的版本可以去上面的程序包的库里找)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="安装程序包"><a href="#安装程序包" class="headerlink" title="安装程序包"></a>安装程序包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install mysql mysql-server mysql-devel</span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>查看临时root密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/mysqld.log | grep <span class="string">'temporary password'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p  <span class="comment">#回车 密码</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化数据库root密码"><a href="#初始化数据库root密码" class="headerlink" title="初始化数据库root密码"></a>初始化数据库root密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一种</span></span><br><span class="line">alter user user() identified by <span class="string">"xxxxx"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种</span></span><br><span class="line"><span class="comment">#选择数据库</span></span><br><span class="line">use mysql </span><br><span class="line"></span><br><span class="line"><span class="comment">#修改root用户密码：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.7版本之前</span></span><br><span class="line">update user <span class="built_in">set</span> password=password(<span class="string">'root'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.7及以后版本</span></span><br><span class="line">update user <span class="built_in">set</span> authentication_string=password(<span class="string">'root'</span>) <span class="built_in">where</span> user=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#刷新权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line">quit;</span><br></pre></td></tr></table></figure>

<p>至此安装完成！</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld.service</span><br></pre></td></tr></table></figure>

<p>查看已安装软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure>

<p>卸载安装软件 根据上一步列出的安装软件进行卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum remove mysql-community-client mysql-community-common mysql-community-server mysql-community-libs mysql-community-libs-compat</span><br></pre></td></tr></table></figure>

<p>查看残留文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis mysql</span><br><span class="line">#或</span><br><span class="line">find &#x2F; -name mysql</span><br><span class="line"></span><br><span class="line">rm -rf xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7安装</title>
    <url>/2020/03/10/centos7install/</url>
    <content><![CDATA[<h3 id="Centos7下载"><a href="#Centos7下载" class="headerlink" title="Centos7下载"></a>Centos7下载</h3><p>官网下载地址：<a href="https://www.centos.org/" target="_blank" rel="noopener">https://www.centos.org/</a></p>
<a id="more"></a>

<p><img src="/2020/03/10/centos7install/20200310111555.png" alt></p>
<p><img src="/2020/03/10/centos7install/20200310111618.png" alt></p>
<p><img src="/2020/03/10/centos7install/20200310111637.png" alt></p>
<p><img src="/2020/03/10/centos7install/20200310111901.png" alt></p>
<p><img src="/2020/03/10/centos7install/20200310111953.png" alt></p>
<h3 id="Centos7安装"><a href="#Centos7安装" class="headerlink" title="Centos7安装"></a>Centos7安装</h3><p>虚拟机以及Centos6的安装流程在上一篇博客有介绍，本篇直接讲述7的安装流程</p>
<p><img src="/2020/03/10/centos7install/20200310112001.jpg" alt></p>
<h4 id="选择语言"><a href="#选择语言" class="headerlink" title="选择语言"></a>选择语言</h4><p><img src="/2020/03/10/centos7install/2018071122433632.png" alt></p>
<h4 id="选择时区"><a href="#选择时区" class="headerlink" title="选择时区"></a>选择时区</h4><p><img src="/2020/03/10/centos7install/2018071122434772.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224410105.png" alt></p>
<h4 id="选择预装软件"><a href="#选择预装软件" class="headerlink" title="选择预装软件"></a>选择预装软件</h4><p><img src="/2020/03/10/centos7install/20180711224421911.png" alt></p>
<p>图像化界面</p>
<p><img src="/2020/03/10/centos7install/20180711224438720.png" alt></p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p><img src="/2020/03/10/centos7install/20180711224452307.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224505907.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224522794.png" alt></p>
<p>分三个区即可 “/”  “/boot” “/swap”</p>
<p><img src="/2020/03/10/centos7install/20180711224533382.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224549412.png" alt></p>
<h4 id="网络设置"><a href="#网络设置" class="headerlink" title="网络设置"></a>网络设置</h4><p><img src="/2020/03/10/centos7install/20180711224603320.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224618785.png" alt></p>
<h4 id="设置root用户"><a href="#设置root用户" class="headerlink" title="设置root用户"></a>设置root用户</h4><p><img src="/2020/03/10/centos7install/2018071122464660.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224658899.png" alt></p>
<h4 id="添加普通用户"><a href="#添加普通用户" class="headerlink" title="添加普通用户"></a>添加普通用户</h4><p><img src="/2020/03/10/centos7install/20180711224711277.png" alt></p>
<p><img src="/2020/03/10/centos7install/2018071122472498.png" alt></p>
<p><img src="/2020/03/10/centos7install/20180711224741348.png" alt></p>
<p>完成！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 Vmware虚拟机安装Centos6</title>
    <url>/2020/03/09/vmcentos/</url>
    <content><![CDATA[<p><img src="/2020/03/09/vmcentos/wmware_20200309.jpg" alt></p>
<a id="more"></a>

<h3 id="Vmware官网下载地址"><a href="#Vmware官网下载地址" class="headerlink" title="Vmware官网下载地址:"></a>Vmware官网下载地址:</h3><p><a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">https://www.vmware.com/cn.html</a></p>
<p><img src="/2020/03/09/vmcentos/20200309142020.png" alt></p>
<p><img src="/2020/03/09/vmcentos/20200309142308.png" alt></p>
<h3 id="Centos官网下载地址"><a href="#Centos官网下载地址" class="headerlink" title="Centos官网下载地址:"></a>Centos官网下载地址:</h3><p><a href="https://www.centos.org/" target="_blank" rel="noopener">https://www.centos.org/</a></p>
<p><img src="/2020/03/09/vmcentos/20200309142507.png" alt></p>
<h3 id="Vmware安装"><a href="#Vmware安装" class="headerlink" title="Vmware安装"></a>Vmware安装</h3><p>无特殊配置, 一路下一步即可完成, 激活方式自行百度, 建议购买正版授权</p>
<h3 id="Vmware创建虚拟机"><a href="#Vmware创建虚拟机" class="headerlink" title="Vmware创建虚拟机"></a>Vmware创建虚拟机</h3><p><img src="/2020/03/09/vmcentos/20200309143738.png" alt="20200309143738.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309143804.png" alt="20200309143804.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309143823.png" alt="20200309143823.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309143849.png" alt="20200309143849.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309143943.png" alt="20200309143943.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309144050.png" alt="20200309144050.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309144606.png" alt="20200309144606.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309144814.png" alt="20200309144814.png"></p>
<p>! 桥接方式,局域网都可访问</p>
<p>! 地址转换,只可以本机访问</p>
<p>图片里的标注反了👇👇👇</p>
<p><img src="/2020/03/09/vmcentos/20200309144933.png" alt="20200309144933.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145001.png" alt="20200309145001.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145013.png" alt="20200309145013.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145100.png" alt="20200309145100.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145409.png" alt="20200309145409.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145428.png" alt="20200309145428.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145451.png" alt="20200309145451.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309145638.png" alt="20200309145638.png"></p>
<h3 id="vmware安装centos6"><a href="#vmware安装centos6" class="headerlink" title="vmware安装centos6"></a>vmware安装centos6</h3><p><img src="/2020/03/09/vmcentos/20200309151705.png" alt="20200309151705.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309151750.png" alt="20200309151750.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309151824.png" alt="20200309151824.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309151937.png" alt="20200309151937.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152158.png" alt="20200309152158.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152219.png" alt="20200309152219.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152243.png" alt="20200309152243.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152356.png" alt="20200309152356.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152515.png" alt="20200309152515.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152547.png" alt="20200309152547.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152622.png" alt="20200309152622.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152714.png" alt="20200309152714.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152812.png" alt="20200309152812.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152832.png" alt="20200309152832.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309152919.png" alt="20200309152919.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309153017.png" alt="20200309153017.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309153051.png" alt="20200309153051.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154054.png" alt="20200309154054.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154216.png" alt="20200309154216.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154241.png" alt="20200309154241.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154321.png" alt="20200309154321.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154349.png" alt="20200309154349.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154434.png" alt="20200309154434.png"></p>
<p><img src="/2020/03/09/vmcentos/20200309154535.png" alt="20200309154535.png"></p>
<p>至此安装完成!!</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>vmware</tag>
        <tag>centos6</tag>
      </tags>
  </entry>
  <entry>
    <title>Android自定义属性</title>
    <url>/2020/03/09/androidviewdiyattr/</url>
    <content><![CDATA[<h3 id="Android-自定义属性"><a href="#Android-自定义属性" class="headerlink" title="Android 自定义属性"></a>Android 自定义属性</h3><h4 id="1-定义自定义属性-values下创建attrs-xml-或者可根据模块创建attr-xml"><a href="#1-定义自定义属性-values下创建attrs-xml-或者可根据模块创建attr-xml" class="headerlink" title="1.定义自定义属性, values下创建attrs.xml, 或者可根据模块创建attr_***.xml"></a>1.定义自定义属性, values下创建attrs.xml, 或者可根据模块创建attr_***.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"***"</span> <span class="attr">format</span>=<span class="string">"***"</span> /&gt;</span> //定义属性</span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"test_color"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span>  //定义一个属性名称为test_color, 接收color的类型</span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"test_text"</span> <span class="attr">format</span>=<span class="string">"string"</span>/&gt;</span>  //定义一个属性名称为test_text, 接受String类型</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"test_attr"</span>&gt;</span>  //算是定义一个属性的集合, 包含多条自定义属性</span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"test_text"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="自定义属性能接受哪些格式"><a href="#自定义属性能接受哪些格式" class="headerlink" title="自定义属性能接受哪些格式"></a>自定义属性能接受哪些格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reference:引用资源</span><br><span class="line">string:字符串</span><br><span class="line">Color：颜色</span><br><span class="line">boolean：布尔值</span><br><span class="line">dimension：尺寸值</span><br><span class="line">float：浮点型</span><br><span class="line">integer：整型</span><br><span class="line">fraction：百分数</span><br><span class="line">enum：枚举类型</span><br><span class="line">flag：位或运算</span><br><span class="line"> enum自定义属性声明方式</span><br><span class="line">&lt;attr name&#x3D;&quot;type&quot;&gt;</span><br><span class="line">            &lt;enum name&#x3D;&quot;password&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;</span><br><span class="line">            &lt;enum name&#x3D;&quot;checkButton&quot; value&#x3D;&quot;2&quot; &#x2F;&gt;</span><br><span class="line">            &lt;enum name&#x3D;&quot;phone&quot; value&#x3D;&quot;3&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;attr&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义属性的使用"><a href="#2-自定义属性的使用" class="headerlink" title="2. 自定义属性的使用"></a>2. 自定义属性的使用</h3><p>   自定义控件中使用自定义属性</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.seeyou.demos.CustomTextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"?attr/test_color"</span> //获取主题中的数值</span></span><br><span class="line"><span class="tag">        <span class="attr">app:test_text</span>=<span class="string">"hhhhhhh"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<!--more-->

<h4 id="主题中使用自定义属性"><a href="#主题中使用自定义属性" class="headerlink" title="主题中使用自定义属性"></a>主题中使用自定义属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"AppTheme"</span> <span class="attr">parent</span>=<span class="string">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"style_1"</span> <span class="attr">parent</span>=<span class="string">"AppTheme"</span>&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"test_color"</span>&gt;</span>#558866<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="代码中获取自定属性"><a href="#代码中获取自定属性" class="headerlink" title="代码中获取自定属性"></a>代码中获取自定属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> CharSequence title;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//将attrs中的属性在test_attr中的自定数值提取到TypedArray中</span></span><br><span class="line">        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.test_attr);  </span><br><span class="line">        <span class="comment">//获取值</span></span><br><span class="line">        title = ta.getText(R.styleable.test_attr_test_text);</span><br><span class="line">        ta.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">        setText(title);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Android @ / @* / ?/ @+ 的含义和区别</title>
    <url>/2020/03/09/androidcodeinlayout/</url>
    <content><![CDATA[<h3 id="一-代表引用资源"><a href="#一-代表引用资源" class="headerlink" title="一.@代表引用资源"></a>一.@代表引用资源</h3><p>1.引用自定义资源。格式：@[package:]type/name</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android：text="@string/hello"</span><br></pre></td></tr></table></figure>

<p>2.引用系统资源。格式：@android:type/name</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:textColor="@android:color/opaque_red"</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注意：其实@android:type/name是@[package:]type/name 的一个子类</p>
<h3 id="二-代表引用系统的非public资源。"><a href="#二-代表引用系统的非public资源。" class="headerlink" title="二.@*代表引用系统的非public资源。"></a>二.@*代表引用系统的非public资源。</h3><p>格式：@*android:type/name</p>
<p>系统资源定义分public和非public。public的声明在：</p>
<p>\platforms\android-8\data\res\values\public.xml</p>
<p>@*android:type/name：可以调用系统定义的所有资源</p>
<p>@android:type/name：只能够调用publi属性的资源。</p>
<p>注意：没在public.xml中声明的资源是google不推荐使用的。</p>
<h3 id="三-？代表引用主题属性"><a href="#三-？代表引用主题属性" class="headerlink" title="三.？代表引用主题属性"></a>三.？代表引用主题属性</h3><p>另外一种资源值允许你引用当前主题中的属性的值。这个属性值只能在style资源和XML属性中使用；它允许你通过将它们改变为当前主题提供的标准变化来改变UI元素的外观，而不是提供具体的值。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:textColor="?android:textDisabledColor"</span><br></pre></td></tr></table></figure>

<p>注意，这和资源引用非常类似，除了我们使用一个”?”前缀代替了”@”。当你使用这个标记时，你就提供了属性资源的名称，它将会在主题中被查找，所以你不需要显示声明这个类型(如果声明，其形式就是?android:attr/android:textDisabledColor)。除了使用这个资源的标识符来查询主题中的值代替原始的资源，其命名语法和”@”形式一致：?[namespace:]type/name，这里类型可选。</p>
<h3 id="四-代表在创建或引用资源-。格式：-type-name"><a href="#四-代表在创建或引用资源-。格式：-type-name" class="headerlink" title="四.@+代表在创建或引用资源 。格式：@+type/name"></a>四.@+代表在创建或引用资源 。格式：@+type/name</h3><p>含义：”+”表示在R.java中名为type的内部类中添加一条记录。如”@+id/button”的含义是在R.java 文件中的id 这个静态内部类添加一条常量名为button。该常量就是该资源的标识符。如果标示符（包括系统资源）已经存在则表示引用该标示符。最常用的就是在定义资源ID中，例如：</p>
<p>@+id/资源ID名 新建一个资源ID</p>
<p>@id/资源ID名 应用现有已定义的资源ID，包括系统ID</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@android:id/资源ID名 引用系统ID，其等效于@id/资源ID名</span><br><span class="line"></span><br><span class="line"> android:id="@+id/selectdlg"</span><br><span class="line"></span><br><span class="line"> android:id="@android:id/text1"</span><br><span class="line"></span><br><span class="line"> android:id="@id/button3"</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android布局符号</tag>
      </tags>
  </entry>
  <entry>
    <title>Android View四个构造函数</title>
    <url>/2020/03/09/androidviewconstruct/</url>
    <content><![CDATA[<p>四个构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//2:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>//1 代码中new view时调用;<br>//2 xml布局中创建view时调用;</p>
<p>//3 //4<br>前两个比较好理解, 后两个是干什么的呢?<br>defStyleAttr 和 defStyleRes是干什么的呢?</p>
<p>有些时候我们给控件设置style属性, 可以通过theme或者xml指定style, defStyleAttr就是接收这个style的, defStyleRes我们可以在代码中手动去指定,并且其它地方没有指定style属性的前提下才会defStyleRes指定的style, 中心思想是为了版本的兼容.</p>
<p>属性优先级顺序为:<br>Xml定义 &gt; xml的style定义 &gt; theme style&gt; defStyleRes&gt; theme直接定义</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Android布局(include/merge/ViewStub)</title>
    <url>/2020/03/09/androidviewlay/</url>
    <content><![CDATA[<p>在布局优化中，Androi的官方提到了这三种布局 include、merge、ViewStub，并介绍了这三种布局各有的优势，下面也是简单说一下他们的优势，以及怎么使用，记下来权当做笔记。</p>
<a id="more"></a>

<h4 id="1-布局重用include"><a href="#1-布局重用include" class="headerlink" title="1.布局重用include"></a>1.布局重用include</h4><p>include标签能够重用布局文件，简单的使用如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android</span></span></span><br><span class="line"><span class="tag"><span class="string">    android:orientation="</span><span class="attr">vertical</span>"</span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/app_bg"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"center_horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/titlebar"</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:text</span>=<span class="string">"@string/hello"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:padding</span>=<span class="string">"10dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1)include标签可以使用单独的layout属性，这个也是必须使用的。<br>2)可以使用其他属性。include标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。</p>
<p>3)在include标签中所有的Android:layout_*都是有效的，前提是必须要写layout_width和layout_height两个属性。</p>
<p>4)布局中可以包含两个相同的include标签，引用时可以使用如下方法解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View bookmarks_container_2 = findViewById(R.id.bookmarks_favourite);</span><br><span class="line">bookmarks_container_2.findViewById(R.id.bookmarks_list);</span><br></pre></td></tr></table></figure>

<h4 id="2-减少视图层级merge"><a href="#2-减少视图层级merge" class="headerlink" title="2.减少视图层级merge"></a>2.减少视图层级merge</h4><p>merge标签在UI的结构优化中起着非常重要的作用，它可以删减多余的层级，优化UI。merge多用于替换FrameLayout或者当一个布局包含另一个时，merge标签消除视图层次结构中多余的视图组。例如你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用merge标签优化。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/add"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/delete"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，当你添加该布局文件时(使用include标签)，系统忽略merge节点并且直接添加两个Button。</p>
<h4 id="3-需要时使用-ViewStub"><a href="#3-需要时使用-ViewStub" class="headerlink" title="3.需要时使用 ViewStub"></a>3.需要时使用 ViewStub</h4><p>ViewStub标签最大的优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。各种不常用的布局想进度条、显示错误消息等可以使用ViewStub标签，以减少内存使用量，加快渲染速度。ViewStub是一个不可见的，大小为0的View。ViewStub标签使用如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/stub_import"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inflatedId</span>=<span class="string">"@+id/panel_import"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout</span>=<span class="string">"@layout/progress_overlay"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">"bottom"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你想加载布局时，可以使用下面其中一种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((ViewStub) findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);  </span><br><span class="line"><span class="comment">// or  </span></span><br><span class="line">View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate();</span><br></pre></td></tr></table></figure>

<p>当调用inflate()函数的时候，ViewStub被引用的资源替代，并且返回引用的view。 这样程序可以直接得到引用的view而不用再次调用函数findViewById()来查找了。<br>注：ViewStub目前有个缺陷就是还不支持merge标签。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>include</tag>
        <tag>merge</tag>
        <tag>viewstub</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架Image-Loader使用</title>
    <url>/2020/03/09/androidframworkimageloader/</url>
    <content><![CDATA[<h4 id="Github地址"><a href="#Github地址" class="headerlink" title="Github地址"></a>Github地址</h4><p><a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener" title="https://github.com/nostra13/Android-Universal-Image-Loader">https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<a id="more"></a>

<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DisplayImageOptions options = <span class="keyword">new</span> DisplayImageOptions.Builder()</span><br><span class="line">        <span class="comment">//图片加载时显示的内容  有重载方法</span></span><br><span class="line">        .showImageOnLoading(R.mipmap.ic_launcher)</span><br><span class="line">        <span class="comment">//url为空的时候显示的内容  有重载方法</span></span><br><span class="line">        .showImageForEmptyUri(R.mipmap.ic_launcher)</span><br><span class="line">        <span class="comment">//图片请求失败的时候显示的图片  有重载方法</span></span><br><span class="line">        .showImageOnFail(R.mipmap.ic_launcher)</span><br><span class="line">        <span class="comment">//图片加载前会进行重置 有重载方法</span></span><br><span class="line">        .resetViewBeforeLoading()</span><br><span class="line">        <span class="comment">//是否在内存中缓存图片 有重载方法</span></span><br><span class="line">        .cacheInMemory(<span class="keyword">true</span>)</span><br><span class="line">        <span class="comment">//是否在磁盘中缓存图片 有重载方法</span></span><br><span class="line">        .cacheOnDisk(<span class="keyword">true</span>)</span><br><span class="line">        <span class="comment">//设置图片以如何的编码方式显示</span></span><br><span class="line">        .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2)</span><br><span class="line">        <span class="comment">//设置图片的解码类型</span></span><br><span class="line">        .bitmapConfig(Bitmap.Config.RGB_565)</span><br><span class="line">        <span class="comment">//解码配置</span></span><br><span class="line">        <span class="comment">//.decodingOptions(BitmapFactory.Options decodingOptions)</span></span><br><span class="line">        <span class="comment">//延迟加载时间</span></span><br><span class="line">        .delayBeforeLoading(<span class="number">500</span>)</span><br><span class="line">        <span class="comment">//下载器需要的辅助信息</span></span><br><span class="line">        .extraForDownloader(<span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//是否考虑图片的 EXIF 信息（括机身、镜头型号、拍摄时间、相机快门次数）</span></span><br><span class="line">        .considerExifParams(<span class="keyword">true</span>)</span><br><span class="line">        <span class="comment">//缓存在内存之前的处理程序</span></span><br><span class="line">        <span class="comment">//.preProcessor(BitmapProcessor preProcessor)</span></span><br><span class="line">        <span class="comment">//缓存在内存之后的处理程序</span></span><br><span class="line">        <span class="comment">//.postProcessor(BitmapProcessor postProcessor)</span></span><br><span class="line">        <span class="comment">//设置图片显示方式 BitmapDisplayer的子类 (圆角, 淡入)</span></span><br><span class="line">        <span class="comment">//.displayer(BitmapDisplayer displayer)</span></span><br><span class="line">        <span class="comment">//是否同步下载</span></span><br><span class="line">        <span class="comment">//.syncLoading(boolean isSyncLoading)</span></span><br><span class="line">        <span class="comment">//handler 对象,消息处理</span></span><br><span class="line">        <span class="comment">//.handler(Handler handler)</span></span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ImageLoaderConfiguration configuration = <span class="keyword">new</span> ImageLoaderConfiguration.Builder(<span class="keyword">this</span>)</span><br><span class="line">        <span class="comment">//内存缓存配置, 内存中图片的最大宽高, 默认值为屏幕宽高</span></span><br><span class="line">        .memoryCacheExtraOptions(<span class="number">1080</span>, <span class="number">1920</span>)</span><br><span class="line">        <span class="comment">//磁盘缓存配置, 磁盘中图片的最大宽高, 以及图片处理, 不推荐使用, 影响imageloader的效率</span></span><br><span class="line">        .diskCacheExtraOptions(<span class="number">1080</span>, <span class="number">1920</span>, <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//自定义线程执行者, 配置的线程设置将不起作用</span></span><br><span class="line">        <span class="comment">//.taskExecutor(new Executor() &#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//自定义图片缓存的任务线程执行者</span></span><br><span class="line">        <span class="comment">//.taskExecutorForCachedImages(new Executor() &#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//线程池的大小</span></span><br><span class="line">        .threadPoolSize(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">//线程优先级</span></span><br><span class="line">        .threadPriority(Thread.NORM_PRIORITY - <span class="number">2</span>)</span><br><span class="line">        <span class="comment">//禁止同一张图片在内存中缓存多个尺寸</span></span><br><span class="line">        .denyCacheImageMultipleSizesInMemory()</span><br><span class="line">        <span class="comment">//任务线程排序方式(FIFO/LIFO)</span></span><br><span class="line">        .tasksProcessingOrder(QueueProcessingType.FIFO)</span><br><span class="line">        <span class="comment">//设置最大内存缓存大小</span></span><br><span class="line">        .memoryCacheSize(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="comment">//设置最大内存缓存 达到应用可用内存的百分比 (大于0 小于100)</span></span><br><span class="line">        .memoryCacheSizePercentage(<span class="number">20</span>)</span><br><span class="line">        <span class="comment">//通过实现接口MemoryCache, 使用自己的缓存机制</span></span><br><span class="line">        <span class="comment">//.memoryCache(new MemoryCache() &#123;...&#125;)</span></span><br><span class="line">        .diskCacheSize(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">50</span>)</span><br><span class="line">        <span class="comment">//设置磁盘缓存的最大文件数量</span></span><br><span class="line">        .diskCacheFileCount(<span class="number">50</span>)</span><br><span class="line">        <span class="comment">//文件名成加密, 指定自己的文件名称生成方式</span></span><br><span class="line">        <span class="comment">//.diskCacheFileNameGenerator(new FileNameGenerator()&#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//通过实现接口, 使用自己的磁盘缓存机制, 通过DiskCache的子类可以指定保存时间和路径</span></span><br><span class="line">        <span class="comment">//.diskCache(new DiskCache()&#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//使用自己的图片下载器 Imagedownloader的子类BaseImageDownloader可以设定连接超时和读取超时</span></span><br><span class="line">        <span class="comment">//.imageDownloader(new ImageDownloader() &#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//设置bitmap解码器</span></span><br><span class="line">        <span class="comment">//.imageDecoder(new ImageDecoder() &#123;...&#125;)</span></span><br><span class="line">        <span class="comment">//设置默认的图片显示配置</span></span><br><span class="line">        .defaultDisplayImageOptions(options)</span><br><span class="line">        <span class="comment">//允许log输出</span></span><br><span class="line">        .writeDebugLogs()</span><br><span class="line">        .build();</span><br><span class="line">ImageLoader.getInstance().init(configuration);</span><br></pre></td></tr></table></figure>

<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageLoader.getInstance().loadImage(...);    <span class="comment">// 需要在ImageLoaderListener中添加显示图片的操作</span></span><br><span class="line"></span><br><span class="line">ImageLoader.getInstance().displayImage(...);  <span class="comment">// 可直接传入ImageView, 加载完成后自动显示</span></span><br><span class="line"></span><br><span class="line">ImageLoader.getInstance().loadImageSync(...);  <span class="comment">// 同步方法, 需要自线程中调用, 回到主线程显示图片</span></span><br></pre></td></tr></table></figure>

<h4 id="支持的Scheme"><a href="#支持的Scheme" class="headerlink" title="支持的Scheme"></a>支持的Scheme</h4><p>显示图片所使用的uri：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String imageUri = <span class="string">"http://site.com/image.png"</span>; <span class="comment">// from Web</span></span><br><span class="line">String imageUri = <span class="string">"https://site.com/image.png"</span>; <span class="comment">//from Web</span></span><br><span class="line">String imageUri = <span class="string">"file:///mnt/sdcard/image.png"</span>; <span class="comment">// from SD card</span></span><br><span class="line">String imageUri = <span class="string">"content://media/external/audio/albumart/13"</span>; <span class="comment">// from content provider 手机媒体文件</span></span><br><span class="line">String imageUri = <span class="string">"assets://image.png"</span>; <span class="comment">// from assets</span></span><br><span class="line">String imageUri = <span class="string">"drawable://"</span> + R.drawable.image; <span class="comment">// from drawables (only images, non-9patch)</span></span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong><br>使用drawable://除非你真的需要他。时刻要注意使用本地图片加载方法：setImageResource带代替ImageLoader。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android框架</tag>
        <tag>图片加载</tag>
        <tag>Imageloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Android框架Glide使用</title>
    <url>/2020/03/09/androidframworkglide/</url>
    <content><![CDATA[<p><img src="/2020/03/09/androidframworkglide/glide_logo.png" alt></p>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址:"></a>GitHub地址:</h4><p><a href="https://github.com/bumptech/glide" target="_blank" rel="noopener" title="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></p>
<h4 id="Gradle引用"><a href="#Gradle引用" class="headerlink" title="Gradle引用:"></a>Gradle引用:</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line"> mavenCentral()</span><br><span class="line"> google()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"> implementation <span class="string">'com.github.bumptech.glide:glide:4.9.0'</span></span><br><span class="line"> annotationProcessor <span class="string">'com.github.bumptech.glide:compiler:4.9.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="权限"><a href="#权限" class="headerlink" title="权限:"></a>权限:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;android.permission.INTERNET&quot;&#x2F;&gt;</span><br><span class="line"> &lt;uses-permission android:name&#x3D;&quot;android.permission.ACCESS_NETWORK_STATE&quot;&#x2F;&gt;</span><br><span class="line"> &lt;uses-permission android:name&#x3D;&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&#x2F;&gt;</span><br><span class="line"> &lt;uses-permission android:name&#x3D;&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆:"></a>混淆:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-keep public class * implements com.bumptech.glide.module.GlideModule</span><br><span class="line">-keep public class * extends com.bumptech.glide.module.AppGlideModule</span><br><span class="line">-keep public enum com.bumptech.glide.load.ImageHeaderParser$** &#123;  </span><br><span class="line">   **[] $VALUES;  public *;</span><br><span class="line"> &#125;</span><br><span class="line"># for DexGuard only</span><br><span class="line">-keepresourcexmlelements manifest&#x2F;application&#x2F;meta-data@value&#x3D;GlideModule</span><br></pre></td></tr></table></figure>

<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法:"></a>基础用法:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(Context)</span><br><span class="line">    .load(Url)</span><br><span class="line">    .into(ImageView);</span><br></pre></td></tr></table></figure>

<h3 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用:"></a>进阶使用:</h3><ul>
<li><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestOptions options = <span class="keyword">new</span> RequestOptions()</span><br><span class="line">    <span class="comment">//加载成功之前占位图</span></span><br><span class="line">    .placeholder(R.mipmap.icon) </span><br><span class="line">     <span class="comment">//加载错误之后的错误图</span></span><br><span class="line">    .error(R.mipmap.ic_launcher)</span><br><span class="line">    <span class="comment">//指定图片的尺寸</span></span><br><span class="line">    .override(<span class="number">100</span>,<span class="number">100</span>)  </span><br><span class="line">     <span class="comment">//指定图片的缩放类型为fitCenter,等比例缩放图片,宽或者是高等于</span></span><br><span class="line">     <span class="comment">//ImageView的宽或者是高.是指其中一个满足即可不会一定铺满imageview</span></span><br><span class="line">    .fitCenter()  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定图片的缩放类型为centerCrop,等比例缩放图片,直到图片的宽高都 </span></span><br><span class="line">    <span class="comment">//大于等于ImageView的宽度,然后截取中间的显示.</span></span><br><span class="line">    .centerCrop()</span><br><span class="line">    <span class="comment">//不使用内存缓存</span></span><br><span class="line">    .skipMemoryCache(<span class="keyword">true</span>)  </span><br><span class="line">    <span class="comment">//缓存所有版本的图像</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.ALL)</span><br><span class="line">    <span class="comment">//不使用硬盘本地缓存   </span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.NONE)  </span><br><span class="line">    <span class="comment">//只缓存原来分辨率的图片</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.DATA) </span><br><span class="line">    <span class="comment">//只缓存最终的图片</span></span><br><span class="line">    .diskCacheStrategy(DiskCacheStrategy.RESOURCE)  </span><br><span class="line"></span><br><span class="line">Glide.with(Context)</span><br><span class="line">    .load(Url)</span><br><span class="line">    .apply(options)</span><br><span class="line">    .into(ImageView);</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="回调监听"><a href="#回调监听" class="headerlink" title="回调监听"></a>回调监听</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RequestListener listener = <span class="keyword">new</span> RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLoadFailed</span><span class="params">(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, <span class="keyword">boolean</span> isFirstResource)</span> </span>&#123;</span><br><span class="line">     Log.e(TAG,<span class="string">" task is error"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onResourceReady</span><span class="params">(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, <span class="keyword">boolean</span> isFirstResource)</span> </span>&#123;</span><br><span class="line">     Log.e(TAG,<span class="string">"task is ok"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Glide.with(Context)</span><br><span class="line"> .load(Url)</span><br><span class="line"> .listener(listener)</span><br><span class="line"> .into(ImageView);</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="过度-amp-变换"><a href="#过度-amp-变换" class="headerlink" title="过度&amp;变换"></a>过度&amp;变换</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(Context)</span><br><span class="line">    .load(Url)</span><br><span class="line">    .transition() <span class="comment">//过度(渐近渐出...)</span></span><br><span class="line">    .transforms() <span class="comment">//变换(圆角...)</span></span><br><span class="line">    .into(ImageView);</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="自定义GlideModule"><a href="#自定义GlideModule" class="headerlink" title="自定义GlideModule"></a>自定义GlideModule</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line"> android:name&#x3D;&quot;com.project.practice.imageviewloader.MyGlideModule&quot;</span><br><span class="line"> android:value&#x3D;&quot;GlideModule&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGlideModule</span> <span class="keyword">implements</span> <span class="title">GlideModule</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyOptions</span><span class="params">(@NonNull Context context, @NonNull GlideBuilder builder)</span> </span>&#123;</span><br><span class="line">        builder.setDefaultRequestOptions(<span class="keyword">new</span> RequestOptions().format(DecodeFormat.PREFER_RGB_565));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(@NonNull Context context, @NonNull Glide glide, @NonNull Registry registry)</span> </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide使用</tag>
        <tag>Android框架</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD 设置编码集为UTF-8</title>
    <url>/2020/03/08/cmdsetcode/</url>
    <content><![CDATA[<h4 id="设置utf-8"><a href="#设置utf-8" class="headerlink" title="设置utf-8"></a>设置utf-8</h4><p>打开cmd, 输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>

<p>属性里面将cmd的字体设置为Lucida Console</p>
<a id="more"></a>

<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><p>打开cmd,输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chcp 936</span><br></pre></td></tr></table></figure>

<p>将属性里面将cmd的字体设置为宋体</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cmd编码</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计七大原则</title>
    <url>/2020/03/08/designpattern/</url>
    <content><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>原则都是前人总结出来的经验，遵循这些原则，让我们开发的程序更加健壮易维护。</p>
<p>七大原则之间并不是相互孤立的，彼此间存在着一定关联，一个可以是另一个原则的加强或是基础。违反其中的某一个，可能同时违反了其余的原则。</p>
<a id="more"></a>

<p>开闭原则是面向对象的可复用设计的基石。其他设计原则是实现开闭原则的手段和工具。<br>一般地，可以把这七个原则分成了以下两个部分：</p>
<p><strong>设计目标:</strong> 开闭原则、里氏代换原则、迪米特原则<br><strong>设计方法:</strong> 单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则</p>
<h3 id="1-单一职责原则-SRP"><a href="#1-单一职责原则-SRP" class="headerlink" title="1. 单一职责原则(SRP)"></a>1. 单一职责原则(SRP)</h3><p><strong>定义：所谓一个类的一个职责是指引起该类变化的一个原因.  如果你能想到一个类存在多个使其改变的原因，那么这个类就存在多个职责.</strong></p>
<p>从这句定义我们很难理解它的含义，通俗讲就是我们不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力. 这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏.</p>
<p>比如我经常看到一些Android开发在Activity中写Bean文件，网络数据处理，如果有列表的话Adapter 也写在Activity中，问他们为什么除了好找也没啥理由了，把他们拆分到其他类岂不是更好找，如果Activity过于臃肿行数过多，显然不是好事，如果我们要修改Bean文件，网络处理和Adapter都需要上这个Activity来修改，就会导致引起这个Activity变化的原因太多，我们在版本维护时也会比较头疼。也就严重违背了定义“就一个类而言，应该仅有一个引起它变化的原因”.<br>当然如果想争论的话，这个模式是可以引起很多争论的，但请记住一点，你写代码不只是为了你也是为了其他人.</p>
<h3 id="2-开闭原则-ASD"><a href="#2-开闭原则-ASD" class="headerlink" title="2. 开闭原则(ASD)"></a>2. 开闭原则(ASD)</h3><p><strong>定义：类、模块、函数等等, 应该是可以拓展的, 但是不可修改。</strong></p>
<p>开放封闭有两个含义，一个是对于拓展是开放的，另一个是对于修改是封闭的。对于开发来说需求肯定是要变化的，但是新需求一来，我们就要把类重新改一遍这显然是令人头疼的，所以我们设计程序时面对需求的改变要尽可能的保证相对的稳定，尽量用新代码实现拓展来修改需求，而不是通过修改原有的代码来实现.<br>假设我们要实现一个列表，一开始只有查询的功能，如果产品又要增加添加功能，过几天又要增加删除功能，大多数人的做法是写个方法然后通过传入不同的值来控制方法来实现不同的功能，但是如果又要新增功能我们还得修改我们的方法。用开发封闭原则解决就是增加一个抽象的功能类，让增加和删除和查询的作为这个抽象功能类的子类，这样如果我们再添加功能，你会发现我们不需要修改原有的类，只需要添加一个功能类的子类实现功能类的方法就可以了.</p>
<h3 id="3-里氏替换原则-LSP"><a href="#3-里氏替换原则-LSP" class="headerlink" title="3.里氏替换原则(LSP)"></a>3.里氏替换原则(LSP)</h3><p><strong>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong></p>
<p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象.<br>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象.<br>在使用里氏代换原则时需要注意如下几个问题：</p>
<p>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法.<br>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一.<br>Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p>
<h3 id="4-依赖倒置原则-DIP"><a href="#4-依赖倒置原则-DIP" class="headerlink" title="4.依赖倒置原则(DIP)"></a>4.依赖倒置原则(DIP)</h3><p><strong>定义：高层模块不应该依赖低层模块，两个都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</strong></p>
<p>在Java中，抽象就是指接口或者抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或者继承抽象类而产生的就是细节，也就是可以加上一个关键字new产生的对象。高层模块就是调用端，低层模块就是具体实现类.<br>依赖倒置原则在Java中的表现就是：模块间通过抽象发生，实现类之间不发生直接依赖关系，其依赖关系是通过接口或者抽象类产生的。如果类与类直接依赖细节，那么就会直接耦合，那么当修改时，就会同时修改依赖者代码，这样限制了可扩展性。</p>
<h3 id="5-迪米特原则-LOD"><a href="#5-迪米特原则-LOD" class="headerlink" title="5.迪米特原则(LOD)"></a>5.迪米特原则(LOD)</h3><p><strong>定义：一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p>
<p>也称为最少知识原则。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系.<br>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度.<br>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p>
<h3 id="6-接口隔离原则-ISP"><a href="#6-接口隔离原则-ISP" class="headerlink" title="6.接口隔离原则(ISP)"></a>6.接口隔离原则(ISP)</h3><p><strong>定义：一个类对另一个类的依赖应该建立在最小的接口上。</strong></p>
<p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用.<br>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度.<br>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系.<br>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情.<br>这六个原则，可以使我们在应用的迭代维护中更加方便、轻松的应对，让我们的软件更加灵活。在后续的文章中我会给大家介绍其他的设计模式。</p>
<h3 id="7-组合-聚合复用原则（CARP）"><a href="#7-组合-聚合复用原则（CARP）" class="headerlink" title="7.组合/聚合复用原则（CARP）"></a>7.组合/聚合复用原则（CARP）</h3><p><strong>定义:即在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的</strong></p>
<p>聚合表示整体和部分的关系，表示“拥有”。组合则是一种更强的“拥有”，部分和整体的生命周期一样。</p>
<p>组合的新的对象完全支配其组成部分，包括它们的创建和湮灭等。一个组合关系的成分对象是不能与另一个组合关系共享的。</p>
<p>组合是值的聚合（Aggregation by Value），而一般说的聚合是引用的聚合（Aggregation by Reference）。</p>
<p>在面向对象设计中，有两种基本的办法可以实现复用：第一种是通过组合/聚合，第二种就是通过继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>面向对象</tag>
        <tag>七大原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 Apache 下载/安装/卸载</title>
    <url>/2020/03/08/win10apache/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载地址:<br><a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">https://www.apachelounge.com/download/</a></p>
<a id="more"></a>

<p><img src="/2020/03/08/win10apache/20200308162340.png" alt></p>
<p>注意:</p>
<ol>
<li>Apache 的版本以及支持多少位的系统  </li>
<li>需要的vc依赖</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.解压</p>
<p>2.配置 bin 目录到全局环境变量</p>
<p>3.Apache配置<br>配置conf/httpd.conf ${SRVROOT}</p>
<p>4.检测语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpd -t</span><br></pre></td></tr></table></figure>

<p>5.安装服务<br>采用默认的服务名称 “Apache2.4”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpd -k install</span><br></pre></td></tr></table></figure>

<p>指定服务名称为apache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpd -k install -n apache</span><br></pre></td></tr></table></figure>

<p>6.启动/停止 服务</p>
<ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start&#x2F; stop Apache2.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>windows系统<br>程序界面 右键Apache2.4 启动/停止/重新启动</p>
</li>
<li><p>Apache监视器<br>bin目录下的ApacheMonitor</p>
</li>
</ul>
<p>7.卸载<br>一定要先卸载apache服务，然后删除安装文件</p>
<p>建议先停止 再卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">httpd -k stop</span><br><span class="line">httpd -k uninstall</span><br></pre></td></tr></table></figure>

<p>目录简介</p>
<p><img src="/2020/03/08/win10apache/20160505100706326.png" alt="loading-ag-8092"></p>
]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Apache安装</tag>
        <tag>Apahce配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 MySQL 下载/安装</title>
    <url>/2020/03/08/win10mysql/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载地址:<br><a href="https://www.mysql.com/" target="_blank" rel="noopener">https://www.mysql.com/</a></p>
<a id="more"></a>

<p><img src="/2020/03/08/win10mysql/20200308154339.png" alt><br><img src="/2020/03/08/win10mysql/20200308154405.png" alt><br><img src="/2020/03/08/win10mysql/20200308154428.png" alt><br><img src="/2020/03/08/win10mysql/20200308154702.png" alt></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.解压缩</p>
<p>2.配置bin目录到环境变量</p>
<p>3.my.ini 数据库默认配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=E:\Program Files\mysql-8.0.12-winx64</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录</span></span><br><span class="line">datadir=E:\Program Files\mysql-8.0.12-winx64\data</span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="comment"># 允许连接失败的次数。</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="comment"># 默认使用“mysql_native_password”插件认证</span></span><br><span class="line"><span class="comment"># mysql_native_password</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"><span class="comment"># 设置默认时区为东八区</span></span><br><span class="line">default-time-zone = <span class="string">'+8:00'</span></span><br><span class="line">[mysql]</span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line"><span class="comment"># 设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8`</span><br></pre></td></tr></table></figure>

<p>4.管理员运行cmd</p>
<p>5.初始化数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure //(root 空密码)</span><br><span class="line">mysqld --initialize //(root 随机密码)</span><br></pre></td></tr></table></figure>

<p>6.安装Mysql服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld install</span><br></pre></td></tr></table></figure>

<p>7.运行Mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>也可在系统服务中开启</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> 数据库名;</span><br></pre></td></tr></table></figure>

<p>选择要操作的Mysql数据库，使用该命令后所有Mysql命令都只针对该数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br></pre></td></tr></table></figure>

<p>列出 MySQL 数据库管理系统的数据库列表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure>

<p>显示指定数据库的所有表，使用该命令前需要使用 use 命令来选择要操作的数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> 数据表;</span><br></pre></td></tr></table></figure>

<p>显示数据表的属性，属性类型，主键信息 ，是否为 NULL，默认值等其他信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> 数据表;</span><br></pre></td></tr></table></figure>

<p>显示数据表的详细索引信息，包括PRIMARY KEY（主键）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> [<span class="keyword">FROM</span> db_name] / [<span class="keyword">LIKE</span> <span class="string">'pattern'</span>];</span><br></pre></td></tr></table></figure>

<p>该命令将输出Mysql数据库管理系统的性能及统计信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc tablename;</span><br></pre></td></tr></table></figure>

<p>查看表的结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename;</span><br></pre></td></tr></table></figure>

<p>查看创建表的sql语句</p>
<h2 id="root密码重置"><a href="#root密码重置" class="headerlink" title="root密码重置"></a>root密码重置</h2><p>1.以管理员身份运行cmd 停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<p>2.设置跳过验证，进入到mysql安装目录下的bin路径，在mysql/bin/目录下输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --shared-memory --skip-grant-tables</span><br></pre></td></tr></table></figure>

<p>（注意：一定要有–shared-memory，否则无法正常设置–skip-grant-tables并启动mysql服务）<br>正常情况下，输完这条命令，该命令行窗口应该卡住不动。</p>
<p>3.无密码登录:新开一个CMD窗口,进入到mysql安装目录下的bin路径,无需重复启动mysql服务,在mysql/bin/目录下输入”mysql”,此时应该可以连接成功,作者尝试的时候大多是卡在了这里,原因参照第二步.</p>
<p>4.重置root密码为空(注意：这里需先置为空密码，否则无法登陆):<br>在第三步的cmd窗口中输入命令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> authentication_string=<span class="string">''</span> <span class="keyword">where</span> <span class="keyword">User</span> = <span class="string">'root'</span>;.</span><br></pre></td></tr></table></figure>

<p>5.退出所有命令行，重新登陆数据库，（若显示服务未启动，需先启动MySQL服务，输入net start mysql）<br>使用如下命令重新修改root密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'123'</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>MySQL安装</tag>
        <tag>MySQL卸载</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10 PHP 安装/配置</title>
    <url>/2020/03/08/win10php/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址:"></a>下载地址:</h3><p><a href="http://windows.php.net/" target="_blank" rel="noopener" title="http://windows.php.net/">http://windows.php.net/</a></p>
<a id="more"></a>

<p><img src="/2020/03/08/win10php/20200308153010.jpg" alt><br><img src="/2020/03/08/win10php/20200308153238.png" alt></p>
<p><strong>注意:</strong><br>系统位数以及vc版本</p>
<h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h2><p>1.解压<br>2.配置php环境变量<br>3.配置Apache 支持PHP<br>编辑文件 /apache24/conf/httpd.conf<br>修改：ServerRoot “C:/Software/apache24”<br>添加php7对apache的处理接口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHPIniDir “D:/web/php-7.0.0-Win32-VC14-x86/”</span><br><span class="line">LoadModule php7_module “C:/Software/apache24/php7apache2_4.dll”</span><br></pre></td></tr></table></figure>

<p>添加 php的minetype，在 标签中添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure>

<p>添加DirectoryIndex 添加 php index (可选)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DirectoryIndex index.html index.php</span><br></pre></td></tr></table></figure>

<p>4.配置 php.ini<br>打开php目录, 复制1个php.ini-development, 修改为php.ini.<br>编辑 php.ini, 找到 ;extension_dir = “ext” ,<br>把前面的分号去掉，修改为实际的ext文件路径:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">extension_dir = “C:\Software\php7\ext”</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP下载</tag>
        <tag>PHP安装</tag>
        <tag>PHP Apache配置</tag>
      </tags>
  </entry>
  <entry>
    <title>GithubPage 搭建 Hexo博客</title>
    <url>/2020/03/08/hexo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>之前都是用Wordpress搭建Blog, 需要自己购买域名服务器, 服务器和域名每年花钱不说, 而且如果想要迁移的话, 资源的管理也比较烦. 发现Hexo之后, 感觉这种静态页面的方式真的爽的一匹, 有点一处编写处处上传的感觉, 本地Markdown软件写blog, 通过Hexo编译静态页面, 然后上传到服务器就可以了. 使用GithubPage或者码云Page, 不用花钱, 而且用Git管理, 舒服!!! 本篇博客记录一下我搭建的流程, 也方便别人了解</p>
<a id="more"></a>

<h2 id="基本搭建-win10"><a href="#基本搭建-win10" class="headerlink" title="基本搭建(win10):"></a>基本搭建(win10):</h2><h3 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h3><p>官网: <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
<h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p>官网:<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h3 id="3-GitHub上创建库"><a href="#3-GitHub上创建库" class="headerlink" title="3.GitHub上创建库"></a>3.GitHub上创建库</h3><p>名称位&lt;用户名&gt;.github.io的库</p>
<p><img src="/2020/03/08/hexo/hexo_github_repo_creat.png" alt="creat_repo"></p>
<p>大概几分钟之后就可以通过<username>.github.io访问了</username></p>
<h3 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h3><p> 创建一个文件夹用来存放博客文件, 通过GitBashHere执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Hexo框架 npm是node.js包管理工具</span></span><br><span class="line">npm install -g hexo-cli </span><br><span class="line"><span class="meta">#</span><span class="bash">初始化Hexo</span></span><br><span class="line">hexo init &lt;文件夹路径&gt;</span><br><span class="line">cd &lt;文件夹路径&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash">安装博客所需依赖, 依赖配置文件可以查看package.json</span></span><br><span class="line">npm install </span><br><span class="line"></span><br><span class="line">hexo g #编译静态文件</span><br><span class="line"></span><br><span class="line">hexo s #开启服务器 地址 localhost:4000</span><br></pre></td></tr></table></figure>

<h3 id="5-搭建完成"><a href="#5-搭建完成" class="headerlink" title="5.搭建完成"></a>5.搭建完成</h3><p>如果你可以在本地进行访问了, 恭喜你环境搭建完成, 接下来只需要通过Git, push /public文件夹内容到第3步创建的库中, 便可通过Githubpages来查看你的blog了. </p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>官方theme地址:<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<h3 id="主题使用流程"><a href="#主题使用流程" class="headerlink" title="主题使用流程"></a>主题使用流程</h3><p>1.下载主题到themes文件夹</p>
<p>2.修改博客_config.yml 中的 theme:</p>
<p>推荐Next主题<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a></p>
<p>可以在主题内的_config.yml中进行一些自定义的配置</p>
<h3 id="Next主题推荐"><a href="#Next主题推荐" class="headerlink" title="Next主题推荐"></a>Next主题推荐</h3><h4 id="1-搜索功能"><a href="#1-搜索功能" class="headerlink" title="1.搜索功能"></a>1.搜索功能</h4><p>1.安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2.在根目录下的/theme/next/_config.yml文件中添加配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search:  </span><br><span class="line">path: search.xml  </span><br><span class="line">field: post  </span><br><span class="line">format: html  </span><br><span class="line"><span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>

<p>3.在根目录下的/theme/next/_config.yml文件中搜索local_search，将enable改为true：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">local_search:  </span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-About-Categories-About"><a href="#2-About-Categories-About" class="headerlink" title="2.About/Categories/About"></a>2.About/Categories/About</h4><p>主题文件下的_config.yml</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line">  <span class="symbol">home:</span> / <span class="params">||</span> home  </span><br><span class="line">  <span class="symbol">about:</span> /about/ <span class="params">||</span> user  </span><br><span class="line">  <span class="symbol">archives:</span> /archives/ <span class="params">||</span> archive  </span><br><span class="line">  <span class="symbol">tags:</span> /tags/ <span class="params">||</span> tags  </span><br><span class="line">  <span class="symbol">categories:</span> /categories/ <span class="params">||</span> th  </span><br><span class="line">  <span class="symbol">schedule:</span> /schedule/ <span class="params">||</span> calendar  </span><br><span class="line">  <span class="symbol">sitemap:</span> /sitemap.xml <span class="params">||</span> sitemap </span><br><span class="line">  <span class="comment"># commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>

<p>需要什么开启什么, 然后文章中需要指定tag 和 category</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">title</span>: 利用<span class="selector-tag">GitHub</span>和<span class="selector-tag">HEXO</span>免费搭建个人博客</span><br><span class="line"><span class="selector-tag">date</span>: 2019<span class="selector-tag">-01-29</span> 22<span class="selector-pseudo">:58</span><span class="selector-pseudo">:56</span></span><br><span class="line"><span class="selector-tag">tags</span>: <span class="selector-attr">[hexo建站,hexo部署,github部署,个人博客]</span>      #添加的标签</span><br><span class="line"><span class="selector-tag">categories</span>: <span class="selector-tag">hexo</span>博客                              #添加的分类</span><br></pre></td></tr></table></figure>

<h4 id="3-上传图片"><a href="#3-上传图片" class="headerlink" title="3.上传图片"></a>3.上传图片</h4><p>1、cd到博客根目录下 查看_config.yml文件 </p>
<p>查找 post_asset_folder 字段</p>
<p>确定post_asset_folder 设置为true</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">post_asset_folder</span><span class="selector-pseudo">:true</span></span><br></pre></td></tr></table></figure>

<p>2、当您设置 post_asset_folder 参数后，在建立文件时，Hexo 会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到此文件夹内，这样就可以更方便的使用资源。</p>
<p>3、到博客的根目录下执行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>命令来进行插件的安装。</p>
<p>4、然后创建一文章 hexo new “test” 然后查看博客的 ../source/_posts 目录下的文件，会看到存在一个test 文件夹 和 test.md 文件</p>
<p>使用:</p>
<p><img src="/2020/03/08/hexo/hexo_upload__pic_to_use.webp" alt="opload_pic"></p>
<h2 id="多端提交"><a href="#多端提交" class="headerlink" title="多端提交"></a>多端提交</h2><p>中心思想，博客文件放置远程仓库hexo分支，静态页面放在远程仓库master分支</p>
<p>本地安装号node.js以及git， 就可以下载配置好的博客程序</p>
<h3 id="本地博客文件推到远程仓库"><a href="#本地博客文件推到远程仓库" class="headerlink" title="本地博客文件推到远程仓库"></a>本地博客文件推到远程仓库</h3><p>添加 /.deploy_git, /public 到.gitignore文件末尾,一个一行</p>
<p>初始化本地仓库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>将本地仓库与远程仓库对接 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin 远程仓库</span><br></pre></td></tr></table></figure>

<p>添加所有本地文件到git </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>注意:如果自己的主题是克隆下来的,先把主题下的.git文件夹和.gitignore文件删除,不然上传不上去</p>
<p>git提交 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"提交hexo配置文件"</span></span><br></pre></td></tr></table></figure>

<p>新建分之并切换 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch hexo</span><br><span class="line">git checkout hexo</span><br></pre></td></tr></table></figure>

<p>push到Github项目的hexo分支上 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>

<h2 id="Git覆盖远程提交"><a href="#Git覆盖远程提交" class="headerlink" title="Git覆盖远程提交"></a><strong>Git覆盖远程提交</strong></h2><p>我的hexo项目管理方式是, 程序推送到远程仓库的hexo分支, blog静态页面推到远程仓库的master分支,  有时多地上传或者更换theme导致冲突, 那就覆盖提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin xxx --force</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p>超级详细搭建教程</p>
<p><a href="https://cloud.tencent.com/developer/article/1577027" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1577027</a></p>
<p>多端更新</p>
<p><a href="https://www.jianshu.com/p/1ae341483683" target="_blank" rel="noopener">https://www.jianshu.com/p/1ae341483683</a></p>
<p>分类/标签/关于</p>
<p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533" target="_blank" rel="noopener">https://blog.csdn.net/mqdxiaoxiao/article/details/93644533</a></p>
<p><a href="https://www.jianshu.com/p/f138032e7539" target="_blank" rel="noopener">https://www.jianshu.com/p/f138032e7539</a></p>
<p>本地搜索</p>
<p><a href="https://www.jianshu.com/p/202c9e789c8f" target="_blank" rel="noopener">https://www.jianshu.com/p/202c9e789c8f</a></p>
<p>hexo博客 图片显示</p>
<p><a href="https://www.jianshu.com/p/8d28027fec76" target="_blank" rel="noopener">https://www.jianshu.com/p/8d28027fec76</a></p>
<p>git覆盖远程提交</p>
<p><a href="https://www.cnblogs.com/davidgu/p/9072493.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidgu/p/9072493.html</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
        <tag>GithubPages</tag>
      </tags>
  </entry>
</search>
